{"query": "Why are semantic validations complaining about missing swagger, info, paths in TypeSpec resources.json file?", "ground_truth": "The resources.json file is a middle output generated during the conversion process from Swagger to TypeSpec. It is not part of the final TypeSpec and can be safely removed after the conversion is complete. This file contains the operations and is produced as an intermediate step in the migration process.", "response": "The semantic validations are likely complaining about missing `swagger`, `info`, and `paths` in the `resources.json` file because these are essential components required for generating valid OpenAPI specifications. In TypeSpec, these elements are typically defined using decorators such as `@service`, `@server`, and operation definitions. If these are not properly configured, the OpenAPI emitter or validation tools will flag them as missing.\n\nTo resolve this issue:\n\n1. **Ensure `@service` and `@server` definitions are correct**:\n   - The `@service` decorator specifies the service name and description.\n   - The `@server` decorator defines the server URL and variables.\n\n   Example:\n   ```tsp\n   @service(\"WidgetService\", \"Service for managing widgets\")\n   @server(\"{endpoint}/widget\", \"Widget API\", {\n     endpoint: url,\n   })\n   namespace WidgetService;\n   ```\n\n2. **Define paths and operations**:\n   - Use operation templates to define API paths and methods (e.g., `GET`, `POST`).\n   - Ensure each operation has a valid route using the `@route` decorator.\n\n   Example:\n   ```tsp\n   @route(\"/widgets\")\n   op listWidgets(): Widget[];\n   ```\n\n3. **Include `info` and versioning**:\n   - Use the `@versioned` decorator to specify API versions.\n   - Ensure the `info` section is implicitly generated by providing proper documentation and metadata.\n\n   Example:\n   ```tsp\n   @versioned(\"v1\")\n   namespace WidgetService;\n   ```\n\nBy addressing these elements, the semantic validation errors should be resolved.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n✅ **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n✅ **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 19.40381669998169, "response_length": 1509}
{"query": "Why are examples not getting linked via \"x-ms-example\" on compilation?", "ground_truth": "The reason examples are not getting linked via \"x-ms-example\" on compilation is due to the operation ID not following the correct naming convention. The operation ID should be in the format \"ResourceNameInPlural_Verb\", such as \"SignupRequests_Create\" instead of \"SignupRequest_Create\".", "response": "The issue of examples not being linked via `x-ms-example` during compilation is likely due to incorrect placement or structure of the example files. According to the provided documentation, the `x-ms-examples` are automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter. However, for this to work, the examples must be placed in the `examples-directory` (defaulting to `{project-root}/examples`) and must include the `operationId` property. \n\nAdditionally, the documentation explicitly states not to use `@extension(\"x-ms-examples\", \"<value>\")`. Instead, ensure that the examples are correctly structured and located in the appropriate directory. If the examples are not being linked, verify the following:\n\n1. The examples are placed in the correct directory (`{project-root}/examples`).\n2. Each example file includes the `operationId` property that matches the declared operations in TypeSpec.\n3. The `typespec-autorest` emitter is being used correctly.\n\nIf these conditions are met, the examples should be linked automatically during compilation.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#x-ms-examples.mdx\n- document_title: x-ms-examples example files\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\n- document_content: # migrate-swagger#faq#x-ms-examples.mdx\n\n# x-ms-examples example files\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe `x-ms-examples` is automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter.\r\nThe examples must be placed in the `examples-directory` (default to `{project-root}/examples`) and have the `operationdId` property.\r\n\r\n:::caution\r\nDo not use `@extension(\"x-ms-examples\", \"<value>\")`.\r\n:::\n\n## Example structure\n\nExample below assume `example-directory` is `{project-root}/examples`.\r\n\r\n- Single version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - example1.json\r\n  - example2.json\r\n</FileTree>\r\n\r\n- Multi version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - 2021-01-01/\r\n    - example1.json\r\n    - example2.json\r\n  - 2021-01-02/\r\n    - example1.json\r\n    - example2.json\r\n</FileTree>\n\n## Generate the examples\n\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\r\n\r\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\r\n\r\n```bash\r\noav generate-examples openapi.json\r\n```\r\n\r\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\r\n\r\n- include `title` field and make sure it is descriptive and unique for each operation.\r\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\r\n\r\n:::caution\r\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\r\n:::\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n", "latency": 16.313961029052734, "response_length": 1089}
{"query": "Why are semantic validations complaining about missing swagger, info, paths in TypeSpec resources.json file?", "ground_truth": "Semantic validations might be complaining about missing 'swagger', 'info', and 'paths' in the TypeSpec resources.json file because these are essential components required for a valid OpenAPI (formerly known as Swagger) specification. The 'swagger' or 'openapi' field specifies the version of the OpenAPI specification being used. The 'info' section provides metadata about the API, such as its title and version. The 'paths' section describes the endpoints of the API and their operations. If these components are missing, the file does not conform to the OpenAPI specification standards, leading to validation errors.", "response": "The semantic validations are likely complaining about missing `swagger`, `info`, and `paths` in the `resources.json` file because these are essential components required for generating a valid OpenAPI specification. In TypeSpec, these elements are typically defined using decorators such as `@service`, `@server`, and operation definitions. If these are not properly configured, the OpenAPI emitter or validation tools will flag them as missing.\n\nTo resolve this issue:\n\n1. **Ensure `@service` and `@server` definitions are correct**:\n   - The `@service` decorator specifies the service name and description.\n   - The `@server` decorator defines the base URL and endpoint structure.\n\n   Example:\n   ```tsp\n   @service(\"WidgetService\", \"Service for managing widgets\")\n   @server(\"{endpoint}/widget\", \"Widget API\", {\n     endpoint: url,\n   })\n   namespace WidgetService;\n   ```\n\n2. **Define operations and paths**:\n   - Use operation templates to define API paths and methods (e.g., `GET`, `POST`).\n   - Ensure each operation has a valid route using the `@route` decorator.\n\n   Example:\n   ```tsp\n   @route(\"/widgets\")\n   op listWidgets(): Widget[];\n   ```\n\n3. **Include `info` metadata**:\n   - Ensure the `info` section is populated with details like title, version, and description.\n   - This is typically handled by the `@versioned` decorator and version enum.\n\n   Example:\n   ```tsp\n   @versioned(\"v1\")\n   namespace WidgetService;\n   ```\n\nBy addressing these areas, you should resolve the semantic validation errors related to missing `swagger`, `info`, and `paths`.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n✅ **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n✅ **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 18.975184202194214, "response_length": 1568}
{"query": "Why is the code-gen securityDefinitions using AadOauth2Auth violating the swagger lintDiff rules requirement?", "ground_truth": "The code-gen securityDefinitions using AadOauth2Auth is violating the swagger lintDiff rules requirement because it does not adhere to the required structure for security definitions in OpenAPI (swagger) specifications. Specifically, the `type`, `authorizationUrl`, `flow`, `description`, and `scopes` must match a certain format and content. To fix the error, one could adjust the OAuth2 definition to match the required `azure_auth` structure, including the correct `type`, `authorizationUrl`, `flow`, `description`, and `scopes` as specified in the guidelines.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#status-read-only-error.md\n- document_title: `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\n- document_content: # troubleshoot#status-read-only-error.md\n\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\r\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Symptoms\n\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\r\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Cause\n\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\r\ntype schema referenced by the properties to be `readOnly` instead.\n\n## Workaround\n\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\r\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\r\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\r\nenabled automatically.\r\n\r\n```diff lang=yaml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n+    use-read-only-status-schema: true\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#suppresswarnings.md\n- document_title: How to suppress warnings\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\n- document_content: # troubleshoot#suppresswarnings.md\n\n# How to suppress warnings\n\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\n\n## Symptoms\n\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\n\n## Cause\n\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\n\n## Workaround\n\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\r\n\r\nFor example:\r\n\r\n```tsp\r\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\r\n/** An array of details about specific errors that led to this reported error. */\r\ndetails: Error[];\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#auth-required.md\n- document_title: auth-required\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/auth-required\n- document_content: # libraries#azure-core#rules#auth-required.md\n\n# auth-required\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/auth-required\r\n```\r\n\r\nEnsure Azure services define their authentication requirements. See https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@service\r\nnamespace Azure.Service;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n- OAuth2\r\n\r\n```tsp\r\n@useAuth(AADToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** The Azure Active Directory OAuth2 Flow */\r\nmodel AADToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\n- Api Key\r\n\r\n```tsp\r\n@useAuth(AzureKey)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** The secret key for your Azure Cognitive Services subscription. */\r\nmodel AzureKey is ApiKeyAuth<ApiKeyLocation.header, \"Ocp-Apim-Subscription-Key\">;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#05-authentication.md\n- document_title: Authentication\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/05-authentication\n- document_content: # getting-started#getting-started-rest#05-authentication.md\n\n# Authentication\n\n## Introduction\n\nIn this section, we'll focus on adding [authentication](../../../libraries/http/authentication/) to your REST API. We'll introduce the `@useAuth` decorator, show how to enforce authentication on specific operations, and provide an example using Bearer authentication.\n\n## Introduction to the `@useAuth` Decorator\n\nThe [@useAuth](../../../libraries/http/reference/decorators/#@TypeSpec.Http.useAuth) decorator is used to enforce authentication on specific operations in your REST API. This decorator allows you to specify the authentication mechanism that should be used for the operation. The TypeSpec HTTP library provides support for several authentication models, including `BearerAuth` for Bearer authentication.\r\n\r\nBearer authentication uses tokens for access control. The server generates a token upon login, and the client includes it in the Authorization header for protected resource requests. The server validates the token to grant access to the resource.\n\n### Example: Enforcing Authentication on Specific Operations\n\nLet's update our existing operations by enforcing authentication using the `@useAuth` decorator.We'll add authentication to the operations that modify pet data, such as creating, updating, and deleting pets. We'll also add a new error model for unauthorized access.\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  // highlight-next-line\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n        // highlight-start\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n        // highlight-end\r\n      };\r\n\r\n  @put\r\n  // highlight-next-line\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\n\n}\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n        // highlight-start\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n        // highlight-end\r\n      };\r\n\r\n  @put\r\n  // highlight-next-line\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        // highlight-start\r\n        @statusCode statusCode: 401;\r\n\r\n        @body error: UnauthorizedError;\r\n        // highlight-end\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  // highlight-next-line\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n    // highlight-end\r\n  };\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n// highlight-start\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n// highlight-end\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@useAuth(BearerAuth)` decorator is applied to the `createPet`, `updatePet`, and `deletePet` operations to enforce authentication using the Bearer authentication mechanism.\n\n{\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n// highlight-end\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@useAuth(BearerAuth)` decorator is applied to the `createPet`, `updatePet`, and `deletePet` operations to enforce authentication using the Bearer authentication mechanism.\r\n- A new error model, `UnauthorizedError`, is defined to handle unauthorized access errors.\r\n- The `UnauthorizedError` model is used in the `createPet`, `updatePet`, and `deletePet` operations to indicate unauthorized access.\n\n### Example: OpenAPI Specification with Authentication\n\nLet's take a closer look at how the `@useAuth` decorator affects the generated OpenAPI specification for the `deletePet` operation.\r\n\r\n```yaml\r\npaths:\r\n  /pets/{petId}:\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n        - $ref: \"#/components/parameters/CommonParameters.requestID\"\r\n        - $ref: \"#/components/parameters/CommonParameters.locale\"\r\n        - $ref: \"#/components/parameters/CommonParameters.clientVersion\"\r\n      // highlight-start\r\n      security:\r\n        - BearerAuth: []\r\n      // highlight-end\r\n      responses:\r\n        \"204\":\r\n          description: \"There is no content to send for this request, but the headers may be useful.\"\r\n        \"404\":\r\n          description: \"Not Found\"\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/NotFoundError\"\r\ncomponents:\r\n  parameters:\r\n    CommonParameters.clientVersion:\r\n      name: client-version\r\n      in: header\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.locale:\r\n      name: locale\r\n      in: query\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.requestID:\r\n      name: request-id\r\n      in: header\r\n      required: true\r\n      schema:\r\n        type: string\r\n  // highlight-start\r\n  securitySchemes:\r\n    BearerAuth:\r\n      type: http\r\n      scheme: bearer\r\n  // highlight-end\r\n  schemas:\r\n    NotFoundError:\r\n      type: object\r\n      properties:\r\n        code:\r\n          type: string\r\n          example: \"NOT_FOUND\"\r\n        message:\r\n          type: string\r\n```\n\n### Explanation\n\n- **Security Section**: The `security` section in the `deletePet` operation specifies that Bearer authentication is required. This is indicated by the `BearerAuth` security scheme.\r\n- **Security Schemes**: The `components` section includes a `securitySchemes` definition for `BearerAuth`, specifying that it uses the HTTP bearer authentication scheme.\n\n### Benefits\n\n1. **Security**: Ensures that only authorized clients can perform certain actions by enforcing authentication on specific operations.\r\n2. **Consistency**: The use of common parameters and authentication mechanisms is consistently applied across relevant operations.\r\n3. **Clarity**: The generated OpenAPI specification clearly shows which operations require authentication and which parameters are needed, improving the documentation and usability of the API.\n\n## Conclusion\n\nIn this section, we focused on adding authentication to your REST API using TypeSpec. By using the `@useAuth` decorator, we can enforce authentication on specific operations, ensuring that only authorized clients can perform certain actions.\r\n\r\nIn the next section, we'll dive into versioning your REST API. Versioning allows you to introduce new features and improvements while maintaining backward compatibility for existing clients.\n", "latency": 8.574022054672241, "response_length": 79}
{"query": "Why is the command 'npx tsv specification/voiceservices/VoiceServices.Management' now giving an error when it was working fine before?", "ground_truth": "The command 'npx tsv specification/voiceservices/VoiceServices.Management' may be giving an error due to several reasons: missing documentation for enum members, changes in the `voiceservices.json` file that could be considered a breaking change, and the use of enums that are not marked with `@fixed`, which is now required as enums have become FIXED to prevent breaking changes. It's suggested to add documentation for clarity, ensure enums are correctly marked, and restart the Visual Studio or the TypeSpec VSCode extension if updates have been made. Additionally, the error might be related to deprecated packages or the need to migrate or suppress linter rules due to updates in best practices. It's also important to check for any pop-up notifications about failures when restarting services or extensions.", "response": "The error you are encountering with the command 'npx tsv specification/voiceservices/VoiceServices.Management' could be due to several reasons:\n\n1. **Missing Peer Dependencies**: If the TypeSpec library or tool you are using has peer dependencies that are not installed, you might encounter errors. This is common when using npm versions prior to 7 or yarn, as they do not automatically install peer dependencies. You can resolve this by upgrading npm or manually installing the missing dependencies.\n\n2. **Changes in TypeSpec Version or Configuration**: If the TypeSpec compiler or related libraries were updated, there might be changes in how commands or configurations are handled. Ensure that your TypeSpec project and dependencies are compatible with the latest version of the TypeSpec compiler.\n\n3. **Linting or Compilation Errors**: If there are issues in your TypeSpec specification files, such as missing decorators or required parameters (e.g., `apiVersion` for operations), the compilation might fail. Check the diagnostics output for specific errors and warnings.\n\n4. **Incorrect Command or Path**: Verify that the command and path you are using are correct. Ensure that the `tsv` tool is installed and accessible via `npx`, and that the path `specification/voiceservices/VoiceServices.Management` exists and contains valid TypeSpec files.\n\nTo troubleshoot further, you can:\n- Check for missing dependencies and install them.\n- Review the diagnostics output for specific errors.\n- Ensure your TypeSpec files comply with linting rules and required decorators.\n- Confirm the compatibility of your TypeSpec project with the installed compiler version.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#operation-missing-api-version.md\n- document_title: operation-missing-api-version\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/operation-missing-api-version\n- document_content: # libraries#azure-core#rules#operation-missing-api-version.md\n\n# operation-missing-api-version\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/operation-missing-api-version\r\n```\r\n\r\nEnsure all operations have an `apiVersion` parameter.\r\n\r\n:::caution\r\nSeeing this error is also a sign that you are not using the Azure Standard templates. First double check why you cannot use them.\r\n:::\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nop createPet(pet: Pet): void;\r\n```\n\n### ✅ Correct\n\n```tsp\r\nop createPet(pet: Pet, ...Azure.Core.Foundations.ApiVersionParameter): void;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#faq.md\n- document_title: FAQ\n- document_link: https://typespec.io/docs/handbook/faq\n- document_content: # handbook#faq.md\n\n# FAQ\n\n#### I'm getting the error `Cannot find package 'x' imported from 'y'`, but I'm not using this package. Why?\r\n\r\nThis issue typically arises when package 'y' has a `peerDependency` on package 'x', and package 'x' isn't installed. This can occur if you're using a package manger that doesn't auto install implicit peer dependencies. It is the case for\r\n\r\n- `npm` (before version 7)\r\n- `yarn`\r\n\r\n##### How can I fix this?\r\n\r\n| Package Manager | Action                                                            |\r\n| --------------- | ----------------------------------------------------------------- |\r\n| `npm`           | Upgrade npm `npm install -g npm`                                  |\r\n| `yarn`          | Add `x` intermediate dependency to your package.json dependencies |\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#basics.md\n- document_title: Creating a TypeSpec Library\n- document_link: https://typespec.io/docs/extending-typespec/basics\n- document_content: # extending-typespec#basics.md\n\n# Creating a TypeSpec Library\n\nA TypeSpec library is a package that includes TypeSpec types, decorators, emitters or linters. These libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional TypeSpec-specific metadata and conventions. This guide will walk you through the process of creating a new TypeSpec library, adding types to it, and distributing it on the public npm registry. Further sections will delve into the specifics of creating [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\r\n\r\nWhile this guide assumes that you'll be using [TypeScript](https://typescriptlang.org) to develop your library, you can skip the TypeScript-related steps if you prefer to use plain JavaScript.\n\n## Prerequisites\n\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\n\n## Setting up with templates\n\nYou can use the following templates:\r\n\r\n```bash\n\n# Create a TypeSpec library (Decorators & Linters) with TypeScript enabled.\n\ntsp init --template library-ts\n\n# Create a TypeSpec emitter with TypeScript enabled.\n\ntsp init --template emitter-ts\r\n```\n\n## Standard package structure\n\nHere's a high-level overview of what a TypeSpec package typically contains. Each of these files will be explained in more detail in the following sections.\r\n\r\n- **dist/index.js** - The main file for your Node library\r\n- **lib/main.tsp** - The main file for your TypeSpec types (optional)\r\n- **src/index.ts** - The main file for your Node library in TypeScript\r\n- **src/lib.ts** - The file that defines your TypeSpec library\r\n- **package.json** - Metadata about your TypeSpec package\n\n## Step 1: Initial setup\n\nYou can skip this step if you've used one of the templates above.\n\n### a. Initialize your package directory & package.json\n\nRun the following commands:\r\n\r\n```bash\r\nmkdir myLibrary\r\ncd myLibrary\r\nnpm init\r\n```\r\n\r\nAfter completing the wizard, you'll have a package.json file that defines your TypeSpec library.\r\n\r\nUnlike Node libraries which support CommonJS (cjs), TypeSpec libraries must be ECMAScript Modules. To specify this, open your `package.json` and add the following top-level configuration key:\r\n\r\n```jsonc\r\n  \"type\": \"module\"\r\n```\n\n### b. Install TypeSpec dependencies\n\nRun the following command:\r\n\r\n```bash\r\nnpm install --save-peer @typespec/compiler\r\n```\r\n\r\nYou might need to install other dependencies from the TypeSpec standard library. For example, if you want to use the metadata found in `@typespec/openapi`, you'll need to install that as well.\r\n\r\nRefer to the [dependency section](#step-3-defining-dependencies) for more information on defining your dependencies.\n\n### c. Define your main files\n\nYour package.json needs to refer to two main files: your Node module main file, and your TypeSpec main. The Node module main file is specified by the `\"main\"` key in your package.json file, and it defines the entry point for your library when it's used as a Node library. This must reference a JS file. The TypeSpec main defines the entry point for your library when it's used from a TypeSpec program, and it can reference either a JS file (when your library doesn't contain any TypeSpec types) or a TypeSpec file.\r\n\r\n```jsonc\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"typespec\": \"./lib/main.tsp\"\r\n    },\r\n    // Additional named export are possible\r\n    \"./experimental\": {\r\n      \"typespec\": \"./lib/experimental.tsp\"\r\n    },\r\n    // Wildcard export as well\r\n    \"./lib/*\": {\r\n      \"typespec\": \"./lib/*.tsp\"\r\n    }\r\n  }\r\n```\n\n### d. Install and initialize TypeScript\n\nRun the following commands:\r\n\r\n```bash\r\nnpm install -D typescript\r\nnpx tsc --init --strict\r\n```\r\n\r\nThis will create a `tsconfig.json` file. You'll need to make a few changes to this file. Open `tsconfig.json` and set the following settings:\r\n\r\n```jsonc\r\n\"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\r\n\"moduleResolution\": \"Node16\",\r\n\"target\": \"es2019\",\r\n\"rootDir\": \".\",\r\n\"outDir\": \"./dist\",\r\n\"sourceMap\": true,\r\n```\n\n### e. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\r\n\r\n:::caution\r\nIf `$lib` is not accessible from your library package (for example, `import {$lib} from \"my-library\";`), some features such as linting and emitter option validation will not be available.\r\n:::\r\n\r\nFor example:\r\n\r\n```typescript\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"myLibrary\",\r\n  diagnostics: {},\r\n} as const);\r\n\r\n// Optional but convenient, these are meant to be used locally in your library.\r\nexport const { reportDiagnostic, createDiagnostic } = $lib;\r\n```\r\n\r\nDiagnostics are used for linters and decorators, which are covered in subsequent topics.\n\n### f. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\r\n\r\n```typescript\r\n// Re-export $lib so the compiler can access it and register your library correctly.\r\nexport { $lib } from \"./lib.js\";\r\n```\n\n### g. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any changes made to TypeScript sources need to be compiled before they are visible to TypeSpec. To do this, run `npx tsc -p .` in your library's root directory. If you want to re-run the TypeScript compiler whenever files are changed, you can run `npx tsc -p . --watch`.\r\n\r\nAlternatively, you can add these as scripts in your `package.json` to make them easier to invoke. Consider adding the following:\r\n\r\n```jsonc\r\n  \"scripts\": {\r\n    \"clean\": \"rimraf ./dist ./temp\",\r\n    \"build\": \"tsc -p .\",\r\n    \"watch\": \"tsc -p . --watch\",\r\n    \"test\": \"node --test ./dist/test/**/*.test.js\", // Node 22+\r\n    \"test\": \"node --test ./dist/test/\"              // Node 18, 20\r\n  }\r\n```\r\n\r\nYou can then run `npm run build` or `npm run watch` to build or watch your library.\n\n### h. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when TypeSpec imports your library, the code to define the library is run. When we add decorators in later topics, this import will ensure those get exposed as well.\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n```\n\n## Step 2: Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It's strongly recommended to put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n\r\nnamespace MyLibrary;\r\nmodel Person {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\n\n## Step 3: Defining dependencies\n\nWhen defining dependencies in a TypeSpec library, follow these rules:\r\n\r\n- Use `peerDependencies` for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\r\n- Use `devDependencies` for other TypeSpec libraries that are only used in tests.\r\n- Use `dependencies` or `devDependencies` for any other packages, depending on whether they're used in library code or in test/dev scripts.\r\n\r\nTypeSpec libraries are defined using `peerDependencies` to avoid having multiple versions of the compiler or library running at the same time.\r\n\r\n**Example**\r\n\r\n```jsonc\r\n{\r\n  \"dependencies\": {\r\n    \"yaml\": \"~2.3.1\", // This is a regular package this library/emitter will use\r\n  },\r\n  \"peerDependencies\": {\r\n    // These are all TypeSpec libraries this library/emitter depends on\r\n    \"@typespec/compiler\": \"~0.43.0\",\r\n    \"@typespec/http\": \"~0.43.1\",\r\n    \"@typespec/openapi\": \"~0.43.0\",\r\n  },\r\n  \"devDependencies\": {\r\n    // This TypeSpec library is only used in the tests but is not required to use this library.\r\n    \"@typespec/versioning\": \"~0.43.0\",\r\n    // TypeScript is only used during development\r\n    \"typescript\": \"~5.0.2\",\r\n  },\r\n}\r\n```\n\n## Step 4: Testing your TypeSpec library\n\nTypeSpec provides a testing framework to assist in testing libraries. The examples here are shown using Node.js's built-in test framework (available in Node 20+), but any other JS test framework can be used that will provide more advanced features like vitest, which is used in this project.\n\n### a. Add devDependencies\n\nEnsure that you have the following in your `package.json`:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types/node\": \"~18.11.9\",\r\n  \"source-map-support\": \"^0.5.21\"\r\n}\r\n```\r\n\r\nAlso add a `vitest.config.ts` file at the root of your project.\r\n\r\n```ts\r\nimport { defineConfig, mergeConfig } from \"vitest/config\";\r\n\r\nexport default defineConfig({\r\n  test: {\r\n    environment: \"node\",\r\n    // testTimeout: 10000, // Uncomment to increase the default timeout\r\n    isolate: false, // Your test shouldn't have side effects to this will improve performance.\r\n  },\r\n});\r\n```\n\n### b. Define the testing library\n\nThe first step is to define how your library can be loaded from the test framework. This will allow your library to be reused by other library tests.\r\n\r\n1. Create a new file `./src/testing/index.ts` with the following content\r\n\r\n```ts\r\nimport { createTestLibrary, findTestPackageRoot } from \"@typespec/compiler/testing\";\r\n\r\nexport const MyTestLibrary = createTestLibrary({\r\n  name: \"<name-of-npm-pkg>\",\r\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\r\n  packageRoot: await findTestPackageRoot(import.meta.url),\r\n});\r\n```\r\n\r\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\r\n\r\n```jsonc\r\n{\r\n  // ...\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"default\": \"./dist/src/index.js\",\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n    },\r\n    \"./testing\": {\r\n      \"default\": \"./dist/src/testing/index.js\",\r\n      \"types\": \"./dist/src/testing/index.d.ts\",\r\n    },\r\n  },\r\n}\r\n```\n\n### c. Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There are 2 functions:\r\n\r\n- `createTestHost`: This is a lower-level API that provides a virtual file system.\r\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\r\n\r\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\r\n\r\n```ts\r\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\r\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\r\nimport { MyTestLibrary } from \"../src/testing/index.js\";\r\n\r\nexport async function createMyTestHost() {\r\n  return createTestHost({\r\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\r\n  });\r\n}\r\nexport async function createMyTestRunner() {\r\n  const host = await createMyTestHost();\r\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\r\n}\r\n```\n\n### d. Write tests\n\nAfter setting up that infrastructure you can start writing tests. By default Node.js will run all files matching these patterns:\r\n\r\n```\r\n**/*.test.?(c|m)js\r\n**/*-test.?(c|m)js\r\n**/*_test.?(c|m)js\r\n**/test-*.?(c|m)js\r\n**/test.?(c|m)js\r\n**/test/**/*.?(c|m)js\r\n```\r\n\r\n[See nodejs doc](https://nodejs.org/api/test.html)\r\n\r\n```ts\r\nimport { createMyTestRunner } from \"./test-host.js\";\r\nimport { describe, beforeEach, it } from \"node:test\";\r\n\r\ndescribe(\"my library\", () => {\r\n  let runner: BasicTestRunner;\r\n\r\n  beforeEach(async () => {\r\n    runner = await createMyTestRunner();\r\n  });\r\n\r\n  // Check everything works fine\r\n  it(\"does this\", async () => {\r\n    const { Foo } = await runner.compile(`\r\n      @test model Foo {}\r\n    `);\r\n    strictEqual(Foo.kind, \"Model\");\r\n  });\r\n\r\n  // Check diagnostics are emitted\r\n  it(\"errors\", async () => {\r\n    const diagnostics = await runner.diagnose(`\r\n       model Bar {}\r\n    `);\r\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\r\n  });\r\n});\r\n```\r\n\r\n#### e. `@test` decorator\r\n\r\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\r\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annotated with the `@test` decorator.\r\n\r\n```ts\r\nconst { Foo, CustomName } = await runner.compile(`\r\n  @test model Foo {}\r\n\r\n  model Bar {\r\n    @test(\"CustomName\") name: string\r\n  }\r\n`);\r\n\r\nFoo; // type of: model Foo {}\r\nCustomName; // type of : Bar.name\r\n```\r\n\r\n#### f. Install VS Code extension for the test framework\r\n\r\nIf you are using VS Code, you can install the [Node test runner](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing) to run your tests from the editor. This will also allow you to easily debug your tests.\r\n\r\nAfter installing the extension, you should be able to discover, run, and debug your tests from the test explorer.\n\n## Step 5: Publishing your TypeSpec library\n\nTo publish your library to the public npm registry, follow the instructions in the [npm documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Step 6: Importing your TypeSpec library\n\nOnce your TypeSpec library is published, users can install and use it just like any of the standard TypeSpec libraries. First, they need to install it:\r\n\r\n```bash\r\nnpm install $packageName\r\n```\r\n\r\nNext, they can import it into their TypeSpec program and use the namespace (if desired):\r\n\r\n```typespec\r\nimport \"MyLibrary\";\r\nusing MyLibrary;\r\n\r\nmodel Employee extends Person {\r\n  job: string;\r\n}\r\n```\n\n## Step 7: Next steps\n\nTypeSpec libraries can contain more than just types. For more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md), refer to the subsequent topics.\n", "latency": 17.578603506088257, "response_length": 1660}
{"query": "What configs are needed to add sdk-for-go support?", "ground_truth": "To add support for the SDK-for-Go, ensure that 'azure-sdk-for-go' is included in the 'tspconfig.yaml' file and address any issues of duplication in schema definitions by modifying the 'TypeSpec'.", "response": "To add SDK support for Go using TypeSpec, you need to configure the appropriate client emitter in your project. While the provided Context does not explicitly mention a Go emitter, the general steps for adding SDK support for other languages can be adapted if a Go emitter exists. Here's how you can proceed:\n\n1. **Install the Go emitter dependency**:\n   Add the Go emitter package to your `package.json` file under `dependencies`. For example:\n   ```json\n   \"dependencies\": {\n     \"@typespec/http-client-go\": \"^<version>\"\n   }\n   ```\n   Replace `<version>` with the appropriate version of the Go emitter.\n\n2. **Update `tspconfig.yaml`**:\n   Configure the emitter in your `tspconfig.yaml` file. Specify the output directory for the generated Go SDK files:\n   ```yaml\n   emit:\n     - \"@typespec/http-client-go\"\n   options:\n     \"@typespec/http-client-go\":\n       emitter-output-dir: \"{project-root}/clients/go\"\n   ```\n\n3. **Generate the SDK**:\n   Run the TypeSpec compiler to generate the Go SDK:\n   ```bash\n   tsp compile {path to main.tsp}/main.tsp\n   ```\n\nIf a Go emitter is not available, you may need to create a custom emitter or check for updates in the TypeSpec ecosystem for Go support.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#basics.md\n- document_title: Creating a TypeSpec Library\n- document_link: https://typespec.io/docs/extending-typespec/basics\n- document_content: # extending-typespec#basics.md\n\n# Creating a TypeSpec Library\n\nA TypeSpec library is a package that includes TypeSpec types, decorators, emitters or linters. These libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional TypeSpec-specific metadata and conventions. This guide will walk you through the process of creating a new TypeSpec library, adding types to it, and distributing it on the public npm registry. Further sections will delve into the specifics of creating [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\r\n\r\nWhile this guide assumes that you'll be using [TypeScript](https://typescriptlang.org) to develop your library, you can skip the TypeScript-related steps if you prefer to use plain JavaScript.\n\n## Prerequisites\n\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\n\n## Setting up with templates\n\nYou can use the following templates:\r\n\r\n```bash\n\n# Create a TypeSpec library (Decorators & Linters) with TypeScript enabled.\n\ntsp init --template library-ts\n\n# Create a TypeSpec emitter with TypeScript enabled.\n\ntsp init --template emitter-ts\r\n```\n\n## Standard package structure\n\nHere's a high-level overview of what a TypeSpec package typically contains. Each of these files will be explained in more detail in the following sections.\r\n\r\n- **dist/index.js** - The main file for your Node library\r\n- **lib/main.tsp** - The main file for your TypeSpec types (optional)\r\n- **src/index.ts** - The main file for your Node library in TypeScript\r\n- **src/lib.ts** - The file that defines your TypeSpec library\r\n- **package.json** - Metadata about your TypeSpec package\n\n## Step 1: Initial setup\n\nYou can skip this step if you've used one of the templates above.\n\n### a. Initialize your package directory & package.json\n\nRun the following commands:\r\n\r\n```bash\r\nmkdir myLibrary\r\ncd myLibrary\r\nnpm init\r\n```\r\n\r\nAfter completing the wizard, you'll have a package.json file that defines your TypeSpec library.\r\n\r\nUnlike Node libraries which support CommonJS (cjs), TypeSpec libraries must be ECMAScript Modules. To specify this, open your `package.json` and add the following top-level configuration key:\r\n\r\n```jsonc\r\n  \"type\": \"module\"\r\n```\n\n### b. Install TypeSpec dependencies\n\nRun the following command:\r\n\r\n```bash\r\nnpm install --save-peer @typespec/compiler\r\n```\r\n\r\nYou might need to install other dependencies from the TypeSpec standard library. For example, if you want to use the metadata found in `@typespec/openapi`, you'll need to install that as well.\r\n\r\nRefer to the [dependency section](#step-3-defining-dependencies) for more information on defining your dependencies.\n\n### c. Define your main files\n\nYour package.json needs to refer to two main files: your Node module main file, and your TypeSpec main. The Node module main file is specified by the `\"main\"` key in your package.json file, and it defines the entry point for your library when it's used as a Node library. This must reference a JS file. The TypeSpec main defines the entry point for your library when it's used from a TypeSpec program, and it can reference either a JS file (when your library doesn't contain any TypeSpec types) or a TypeSpec file.\r\n\r\n```jsonc\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"typespec\": \"./lib/main.tsp\"\r\n    },\r\n    // Additional named export are possible\r\n    \"./experimental\": {\r\n      \"typespec\": \"./lib/experimental.tsp\"\r\n    },\r\n    // Wildcard export as well\r\n    \"./lib/*\": {\r\n      \"typespec\": \"./lib/*.tsp\"\r\n    }\r\n  }\r\n```\n\n### d. Install and initialize TypeScript\n\nRun the following commands:\r\n\r\n```bash\r\nnpm install -D typescript\r\nnpx tsc --init --strict\r\n```\r\n\r\nThis will create a `tsconfig.json` file. You'll need to make a few changes to this file. Open `tsconfig.json` and set the following settings:\r\n\r\n```jsonc\r\n\"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\r\n\"moduleResolution\": \"Node16\",\r\n\"target\": \"es2019\",\r\n\"rootDir\": \".\",\r\n\"outDir\": \"./dist\",\r\n\"sourceMap\": true,\r\n```\n\n### e. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\r\n\r\n:::caution\r\nIf `$lib` is not accessible from your library package (for example, `import {$lib} from \"my-library\";`), some features such as linting and emitter option validation will not be available.\r\n:::\r\n\r\nFor example:\r\n\r\n```typescript\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"myLibrary\",\r\n  diagnostics: {},\r\n} as const);\r\n\r\n// Optional but convenient, these are meant to be used locally in your library.\r\nexport const { reportDiagnostic, createDiagnostic } = $lib;\r\n```\r\n\r\nDiagnostics are used for linters and decorators, which are covered in subsequent topics.\n\n### f. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\r\n\r\n```typescript\r\n// Re-export $lib so the compiler can access it and register your library correctly.\r\nexport { $lib } from \"./lib.js\";\r\n```\n\n### g. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any changes made to TypeScript sources need to be compiled before they are visible to TypeSpec. To do this, run `npx tsc -p .` in your library's root directory. If you want to re-run the TypeScript compiler whenever files are changed, you can run `npx tsc -p . --watch`.\r\n\r\nAlternatively, you can add these as scripts in your `package.json` to make them easier to invoke. Consider adding the following:\r\n\r\n```jsonc\r\n  \"scripts\": {\r\n    \"clean\": \"rimraf ./dist ./temp\",\r\n    \"build\": \"tsc -p .\",\r\n    \"watch\": \"tsc -p . --watch\",\r\n    \"test\": \"node --test ./dist/test/**/*.test.js\", // Node 22+\r\n    \"test\": \"node --test ./dist/test/\"              // Node 18, 20\r\n  }\r\n```\r\n\r\nYou can then run `npm run build` or `npm run watch` to build or watch your library.\n\n### h. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when TypeSpec imports your library, the code to define the library is run. When we add decorators in later topics, this import will ensure those get exposed as well.\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n```\n\n## Step 2: Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It's strongly recommended to put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n\r\nnamespace MyLibrary;\r\nmodel Person {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\n\n## Step 3: Defining dependencies\n\nWhen defining dependencies in a TypeSpec library, follow these rules:\r\n\r\n- Use `peerDependencies` for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\r\n- Use `devDependencies` for other TypeSpec libraries that are only used in tests.\r\n- Use `dependencies` or `devDependencies` for any other packages, depending on whether they're used in library code or in test/dev scripts.\r\n\r\nTypeSpec libraries are defined using `peerDependencies` to avoid having multiple versions of the compiler or library running at the same time.\r\n\r\n**Example**\r\n\r\n```jsonc\r\n{\r\n  \"dependencies\": {\r\n    \"yaml\": \"~2.3.1\", // This is a regular package this library/emitter will use\r\n  },\r\n  \"peerDependencies\": {\r\n    // These are all TypeSpec libraries this library/emitter depends on\r\n    \"@typespec/compiler\": \"~0.43.0\",\r\n    \"@typespec/http\": \"~0.43.1\",\r\n    \"@typespec/openapi\": \"~0.43.0\",\r\n  },\r\n  \"devDependencies\": {\r\n    // This TypeSpec library is only used in the tests but is not required to use this library.\r\n    \"@typespec/versioning\": \"~0.43.0\",\r\n    // TypeScript is only used during development\r\n    \"typescript\": \"~5.0.2\",\r\n  },\r\n}\r\n```\n\n## Step 4: Testing your TypeSpec library\n\nTypeSpec provides a testing framework to assist in testing libraries. The examples here are shown using Node.js's built-in test framework (available in Node 20+), but any other JS test framework can be used that will provide more advanced features like vitest, which is used in this project.\n\n### a. Add devDependencies\n\nEnsure that you have the following in your `package.json`:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types/node\": \"~18.11.9\",\r\n  \"source-map-support\": \"^0.5.21\"\r\n}\r\n```\r\n\r\nAlso add a `vitest.config.ts` file at the root of your project.\r\n\r\n```ts\r\nimport { defineConfig, mergeConfig } from \"vitest/config\";\r\n\r\nexport default defineConfig({\r\n  test: {\r\n    environment: \"node\",\r\n    // testTimeout: 10000, // Uncomment to increase the default timeout\r\n    isolate: false, // Your test shouldn't have side effects to this will improve performance.\r\n  },\r\n});\r\n```\n\n### b. Define the testing library\n\nThe first step is to define how your library can be loaded from the test framework. This will allow your library to be reused by other library tests.\r\n\r\n1. Create a new file `./src/testing/index.ts` with the following content\r\n\r\n```ts\r\nimport { createTestLibrary, findTestPackageRoot } from \"@typespec/compiler/testing\";\r\n\r\nexport const MyTestLibrary = createTestLibrary({\r\n  name: \"<name-of-npm-pkg>\",\r\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\r\n  packageRoot: await findTestPackageRoot(import.meta.url),\r\n});\r\n```\r\n\r\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\r\n\r\n```jsonc\r\n{\r\n  // ...\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"default\": \"./dist/src/index.js\",\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n    },\r\n    \"./testing\": {\r\n      \"default\": \"./dist/src/testing/index.js\",\r\n      \"types\": \"./dist/src/testing/index.d.ts\",\r\n    },\r\n  },\r\n}\r\n```\n\n### c. Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There are 2 functions:\r\n\r\n- `createTestHost`: This is a lower-level API that provides a virtual file system.\r\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\r\n\r\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\r\n\r\n```ts\r\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\r\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\r\nimport { MyTestLibrary } from \"../src/testing/index.js\";\r\n\r\nexport async function createMyTestHost() {\r\n  return createTestHost({\r\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\r\n  });\r\n}\r\nexport async function createMyTestRunner() {\r\n  const host = await createMyTestHost();\r\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\r\n}\r\n```\n\n### d. Write tests\n\nAfter setting up that infrastructure you can start writing tests. By default Node.js will run all files matching these patterns:\r\n\r\n```\r\n**/*.test.?(c|m)js\r\n**/*-test.?(c|m)js\r\n**/*_test.?(c|m)js\r\n**/test-*.?(c|m)js\r\n**/test.?(c|m)js\r\n**/test/**/*.?(c|m)js\r\n```\r\n\r\n[See nodejs doc](https://nodejs.org/api/test.html)\r\n\r\n```ts\r\nimport { createMyTestRunner } from \"./test-host.js\";\r\nimport { describe, beforeEach, it } from \"node:test\";\r\n\r\ndescribe(\"my library\", () => {\r\n  let runner: BasicTestRunner;\r\n\r\n  beforeEach(async () => {\r\n    runner = await createMyTestRunner();\r\n  });\r\n\r\n  // Check everything works fine\r\n  it(\"does this\", async () => {\r\n    const { Foo } = await runner.compile(`\r\n      @test model Foo {}\r\n    `);\r\n    strictEqual(Foo.kind, \"Model\");\r\n  });\r\n\r\n  // Check diagnostics are emitted\r\n  it(\"errors\", async () => {\r\n    const diagnostics = await runner.diagnose(`\r\n       model Bar {}\r\n    `);\r\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\r\n  });\r\n});\r\n```\r\n\r\n#### e. `@test` decorator\r\n\r\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\r\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annotated with the `@test` decorator.\r\n\r\n```ts\r\nconst { Foo, CustomName } = await runner.compile(`\r\n  @test model Foo {}\r\n\r\n  model Bar {\r\n    @test(\"CustomName\") name: string\r\n  }\r\n`);\r\n\r\nFoo; // type of: model Foo {}\r\nCustomName; // type of : Bar.name\r\n```\r\n\r\n#### f. Install VS Code extension for the test framework\r\n\r\nIf you are using VS Code, you can install the [Node test runner](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing) to run your tests from the editor. This will also allow you to easily debug your tests.\r\n\r\nAfter installing the extension, you should be able to discover, run, and debug your tests from the test explorer.\n\n## Step 5: Publishing your TypeSpec library\n\nTo publish your library to the public npm registry, follow the instructions in the [npm documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Step 6: Importing your TypeSpec library\n\nOnce your TypeSpec library is published, users can install and use it just like any of the standard TypeSpec libraries. First, they need to install it:\r\n\r\n```bash\r\nnpm install $packageName\r\n```\r\n\r\nNext, they can import it into their TypeSpec program and use the namespace (if desired):\r\n\r\n```typespec\r\nimport \"MyLibrary\";\r\nusing MyLibrary;\r\n\r\nmodel Employee extends Person {\r\n  job: string;\r\n}\r\n```\n\n## Step 7: Next steps\n\nTypeSpec libraries can contain more than just types. For more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md), refer to the subsequent topics.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#repo_setup.md\n- document_title: Repo setup\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/repo_setup\n- document_content: # howtos#generate-with-tsp-client#repo_setup.md\n\n# Repo setup\n\nEach repository that intends to support `tsp-client` for generating and updating client libraries will need to set up an `emitter-package.json` file under the `eng/` directory at the root of the repository. Client libraries generated with this tool will be outputted based on the information in the tspconfig.yaml file of the TypeSpec specification. The service directory is specified through the `parameters.service-dir.default` parameter in the tspconfig.yaml, additionally the `package-dir` option for the specific emitter is appended to the end of the path.\r\n\r\nSee the following example of a valid tspconfig.yaml file: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n\r\nUsing the tspconfig.yaml linked above, by default, the client libraries will be generated in the following directory for C#: `<repo>/sdk/contosowidgetmanager/Azure.Template.Contoso/`.\n\n### Required set up\n\nPlease note that these requirements apply on the repository where the client library is going to be generated. Repo owners should make sure to follow these requirements. Users working within a repository that already accepts this tool can refer to the [Usage](https://aka.ms/azsdk/tsp-client) doc.\r\n\r\n- Add an emitter-package.json to the repo following this [configuration](#emitter-packagejson-required).\r\n- Add the [TempTypeSpecFiles](#temptypespecfiles) directory to the .gitignore file for your repository.\n\n### TempTypeSpecFiles\n\nThis tool creates a `TempTypeSpecFiles` directory when syncing a TypeSpec project to your local repository. This temporary folder will contain a copy of the TypeSpec project specified by the parameters set in the tsp-location.yaml file. If you pass the `--save-inputs` flag to the commandline tool, this directory will not be deleted. You should add a new entry in the .gitignore of your repo so that none of these files are accidentally checked in if `--save-inputs` flag is passed in.\r\n\r\n```diff title=\".gitignore\" lang=\"sh\"\r\n+ TempTypeSpecFiles/\r\n```\n\n### emitter-package.json (Required)\n\n`emitter-package.json` will be used the same as a `package.json` file. If the is no `emitter-package-lock.json` file, the tool will run `npm install` on the contents of `emitter-package.json`. This file allows each repository to pin the version of their emitter and other dependencies to be used when generating client libraries.\r\nThe file should be checked into this location `<root of repo>/eng/emitter-package.json`\r\n\r\nExample:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-python\": \"0.21.0\"\r\n  }\r\n}\r\n```\r\n\r\n:::note\r\ntsp compile currently requires the \"main\" line to be there.\r\n:::\r\n\r\nThis file replaces the package.json checked into the `azure-rest-api-spec` repository.\n\n### emitter-package-lock.json (Optional)\n\n`emitter-package-lock.json` will be used the same as a `package-lock.json`. The tool will run a clean npm installation before generating client libraries. This file allows consistent dependency trees and allows each repository to control their dependency installation.\r\nThe file should be checked into this location: `<root of repo>/eng/emitter-package-lock.json`\r\n\r\n:::caution\r\nThe tool will run `npm ci` to install dependencies, so ensure that the `emitter-package-lock.json` and `emitter-package.json` files both exist and are in sync with each other.\r\n:::\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n", "latency": 12.31596064567566, "response_length": 1194}
{"query": "Why did the pipeline fail due to an inability to import '@azure-tools/typespec-providerhub'?", "ground_truth": "The pipeline failed due to an inability to import '@azure-tools/typespec-providerhub' because the package has been deprecated. The latest versions of typespec-providerhub-controller no longer require typespec-providerhub. The package was primarily providing validation, which has now been moved to the standard Azure core ruleset and a new 'canonical' ruleset in Azure core. To resolve the issue, it is necessary to remove the import of '@azure-tools/typespec-providerhub' from the specification and ensure that any dependencies are updated accordingly.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#suppresswarnings.md\n- document_title: How to suppress warnings\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\n- document_content: # troubleshoot#suppresswarnings.md\n\n# How to suppress warnings\n\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\n\n## Symptoms\n\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\n\n## Cause\n\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\n\n## Workaround\n\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\r\n\r\nFor example:\r\n\r\n```tsp\r\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\r\n/** An array of details about specific errors that led to this reported error. */\r\ndetails: Error[];\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step05.md\n- document_title: 5. Defining standard resource operations\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step05\n- document_content: # getstarted#azure-core#step05.md\n\n# 5. Defining standard resource operations\n\nThe `Azure.Core` namespace provides a variety of [standard lifecycle operations](https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/interfaces#Azure.Core.ResourceOperations) for resource types. These operations adhere to the requirements of the [Azure REST API Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md).\n\n## Operation interface definition\n\nTo define standard operations for a resource type, create an instance of the `ResourceOperations` interface that is tailored to your service. Here's an example:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nIn this example:\r\n\r\n1. `ServiceTraits` is defined as the intersection of three trait model types available in `Azure.Core`. Learn more about interface-level service traits [here](https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types).\r\n2. `Operations` is defined as the instantiation of `Azure.Core.ResourceOperations` with the service trait types you defined.\r\n\r\n> **Note:** The name `Operations` is used for convenience, but you might define multiple aliases of `ResourceOperation` for a single service to apply different customizations for some operations. You might choose a more explicit name like `StandardOperations`.\r\n\r\nNext, we'll use this interface alias to define the standard resource operations we need.\n\n## Resource operations definition\n\nWe'll define the standard set of CRUD (Create, Read, Update, Delete) operations typically needed for a resource type in an Azure service. We'll do this by defining an interface called `Widgets`:\r\n\r\n```typespec\r\ninterface Widgets {\r\n  /** Fetch a Widget by name. */\r\n  getWidget is Operations.ResourceRead<Widget>;\r\n\r\n  /** Creates or updates a Widget. */\r\n  createOrUpdateWidget is Operations.ResourceCreateOrUpdate<Widget>;\r\n\r\n  /** Delete a Widget. */\r\n  deleteWidget is Operations.ResourceDelete<Widget>;\r\n\r\n  /** List Widget resources. */\r\n  listWidgets is Operations.ResourceList<Widget>;\r\n}\r\n```\r\n\r\n> **Note:** It's not necessary to define your resource operations inside of an `interface`. You can also define them in a sub-namespace of your service or inside the top-level namespace of the service. However, it's a best practice in TypeSpec to use `interface` to encapsulate the operations of a particular resource type.\r\n\r\nThe `Widget` interface defines the following standard lifecycle operations:\r\n\r\n- `ResourceRead<TResource>`: Defines a \"read\" operation for a single resource instance.\r\n- `ResourceCreateOrUpdate<TResource>`: Defines an \"upsert\" operation which either creates or updates an instance of the resource type depending on whether it already exists.\r\n- `ResourceDelete<TResource>`: Defines a \"delete\" operation to delete a specific instance of the resource.\r\n- `ResourceList<TResource>`: Defines an operation that lists all instances of the resource type.\r\n\r\n> **Note:** There are both instantaneous and long-running versions of \"create\", \"update\", and \"delete\" operations for resource types depending on what you need for a particular resource!\r\n\r\nThese operations will all exist under the route path `/widgets/{widgetName}`, with the list operation generating the path `/widgets`.\n\n## Error response customization\n\nIf your service needs to use a custom error response type for all resource operations (which is uncommon), you may pass in a custom error response type to the `ResourceOperations` interface:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\n/** A custom error response type. */\r\n@error\r\nmodel ErrorResponse {\r\n  /** The error code. */\r\n  code: string;\r\n\r\n  /** The error message. */\r\n  message: string;\r\n}\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits, ErrorResponse>;\r\n```\r\n\r\nYou can also reuse the standard Azure Core error types with minor customizations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\n/** A custom error type. */\r\nmodel Error is Azure.Core.Foundations.Error {\r\n  /** The environment where the error occurred. */\r\n  environment: string;\r\n}\r\n\r\nalias Operations = Azure.Core.ResourceOperations<\r\n  ServiceTraits,\r\n  Azure.Core.Foundations.ErrorResponseBase<Error>\r\n>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n", "latency": 4.6070332527160645, "response_length": 79}
{"query": "Does typespec-providerhub-controller need to be updated to be compatible with typespec-autorest@0.41.0?", "ground_truth": "The typespec-providerhub-controller needed an update for compatibility with typespec-autorest@0.41.0, which was addressed in version 0.41.1. Although the provider hub controller package release tends to be delayed, there are plans to open the dependency range to prevent similar issues in the future, provided there are no major breaking changes.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: intro.md\n- document_title: Introduction\n- document_link: https://azure.github.io/typespec-azure/docs/intro\n- document_content: # intro.md\n\n# Introduction\n\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\r\n\r\nYou can find more information at https://typespec.io/docs.\r\n\r\nThis site is focused on using TypeSpec in the context of Azure. We have published a set of libraries with standard patterns and templates to make defining Azure management and data-plane services easy and compliant with Azure API guidelines. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\n\n# TypeSpec Azure Libraries\n\n## Packages\n\n| ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\r\n\r\n[typespec-autorest_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest\r\n[typespec-autorest_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest/CHANGELOG.md\r\n[typespec-azure-core_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core\r\n[typespec-azure-core_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core/CHANGELOG.md\r\n[typespec-azure-resource-manager_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager\r\n[typespec-azure-resource-manager_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/CHANGELOG.md\r\n\r\n`@next` version of the package are the latest versions available on the `main` branch.\n\n| Name                                                                          | Type    | Changelog                                        | Latest                                                                                                                                                       | Next                                                                              |\r\n| ----------------------------------------------------------------------------- | ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |\r\n| [@azure-tools/typespec-azure-core][typespec-azure-core_src]                   | Library | [Changelog][typespec-azure-core_chg]             | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-core)](https://www.npmjs.com/package/@azure-tools/typespec-azure-core)                         | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-core/next)             |\r\n| [@azure-tools/typespec-resource-manager][typespec-azure-resource-manager_src] | Library | [Changelog][typespec-azure-resource-manager_chg] | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-resource-manager)](https://www.npmjs.com/package/@azure-tools/typespec-azure-resource-manager) | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\n\n### Package Layering\n\nThe main packages in this repository can be considered a series of layers which progressively add functionality\r\nfor specific scenarios:\r\n\r\n- [**@azure-tools/typespec-azure-core:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core) Provides core models and interfaces for Azure service modelling\r\n- [**@azure-tools/typespec-azure-resource-manager:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager) Provides additional models and interfaces for modelling Azure Resource Manager services\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](./typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest#index.md\n- document_title: TypeSpec AutoRest Library\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/index\n- document_content: # emitters#typespec-autorest#index.md\n\n# TypeSpec AutoRest Library\n\nThis is a TypeSpec library that will emit an enriched OpenAPI 2.0 specification that can be consumed by AutoRest.\r\nThe generated OpenAPI spec will have custom `x-ms-` extensions properties and conform to standards required by AutoRest to generate a more accurate SDK.\n\n## Getting started\n\n1. Include `@azure-tools/typespec-autorest` dependencies in package.json\r\n\r\n```json\r\n{\r\n  ...\r\n  \"dependencies\": {\r\n    ...\r\n    \"@azure-tools/typespec-autorest\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\n2. Run `npm install` to install the dependency\r\n3. Import `@azure-tools/typespec-autorest` in your `main.tsp` file\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-autorest\";\r\n```\r\n\r\n4. Run `tsp compile`. This will result in a `swagger.json` file crated in `./tsp-output/swagger.json`\n\n## Use in autorest\n\nGenerate the OpenAPI spec as shown above then run autorest cli directly on it.\r\n\r\n```bash\r\nautorest --input-file=<path/to/generated/file.json>\n\n# Example\n\nautorest --input-file=./tsp-output/@azure-tools/typespec-autorest/openapi.json --python\r\n```\n\n## Configuration\n\n### Emitter options:\n\nEmitter options can be configured via the `tspconfig.yaml` configuration:\r\n\r\n```yaml\r\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    <optionName>: <value>\n\n# For example\n\n`openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\r\n\r\nDirectory where the x-ms-examples are located so the emitter can automatically link.\r\n\r\n#### `version`\r\n\r\nSelect which version should be emitted if the spec support versioning. By default all the version with be emitted in this format `<outputFileName>.<version>.json`\n\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    output-file: my-custom-swagger.json\r\n```\r\n\r\nor via the command line with\r\n\r\n```bash\r\n--option \"@azure-tools/typespec-autorest.<optionName>=<value>\"\r\n\r\n--option \"@azure-tools/typespec-autorest.output-file=my-custom-swagger.json\"\r\n```\r\n\r\n#### `azure-resource-provider-folder`\r\n\r\n`resource-manager` directory under your service folder are located so the emitter can emit correct sub-folder structure and swagger files for each of the API versions. You must specify it for ARM specs with folder path relative to the TypeSpec files.\r\n\r\n#### `emitter-output-dir`\r\n\r\nSet the emitter output-dir. [See here](https://typespec.io/docs/handbook/configuration#emitter-output-dir)\r\n\r\n#### `output-file`\r\n\r\nConfigure the name of the swagger output file relative to the `output-dir`.\r\n\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- version: Version of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\r\n\r\nExample: Single service no versioning\r\n\r\n- `openapi.yaml`\r\n\r\nExample: Multiple services no versioning\r\n\r\n- `openapi.Org1.Service1.yaml`\r\n- `openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\n\n### `new-line`\n\nSet the newline character for emitting files. Can be either:\r\n\r\n- `lf`(Default)\r\n- `crlf`\n\n### `omit-unreachable-types`\n\nOnly include types referenced via an operation.\n\n## Decorators\n\n- [@collectionFormat](#collectionformat)\r\n- [@example](#example)\r\n- [@useRef](#useref)\n\n### @collectionFormat\n\nSyntax:\r\n\r\n```\r\n@collectionFormat(formatString)\r\n```\r\n\r\n`@collectionFormat` specifies array property type serialization format. Valid format strings are \"csv\", \"multi\", \"ssv\", \"tsv\", \"pipes\" though \"csv\" or \"multi\" are recommended.\r\n\r\n`@collectionFormat` can only be specified on model properties that are arrays.\n\n### @example\n\nSyntax:\r\n\r\n```\r\n@example(pathOrUri, title)\r\n```\r\n\r\n`@example` attaches example files to an operation. Multiple examples can be specified.\r\n\r\n`@example` can only be specified on operations.\n\n### @useRef\n\nSyntax:\r\n\r\n```\r\n@useRef(urlString)\r\n```\r\n\r\n`@useRef` is used to replace the TypeSpec model type in emitter output with a pre-existing named OpenAPI schema such as ARM common types.\n\n## How to\n\n### Include `x-ms-skip-url-encoding` in `x-ms-parmaeterized-host` parameter\n\nEvery parameter of type `uri` in `@server` will be marked with `x-ms-skip-url-encoding`.\r\n\r\n```typespec\r\n@server(\"{endpoint}/v2\", \"Account endpoint\", {endpoint: url})\r\n```\r\n\r\nResult in\r\n\r\n```json5\r\n{\r\n  in: \"path\",\r\n  name: \"endpoint\",\r\n  required: true,\r\n  type: \"string\",\r\n  format: \"uri\",\r\n  \"x-ms-skip-url-encoding\": true,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n", "latency": 4.611675262451172, "response_length": 79}
{"query": "How can we introduce ApiVersion=B into our flow while continuing to produce OpenAPI spec, contracts, and client DLLs for both the new ApiVersion=B and all prior versions?", "ground_truth": "To introduce ApiVersion=B while continuing to produce OpenAPI spec, contracts, and client DLLs for both the new version and all prior versions, it's recommended to utilize the TypeSpec versioning library. This approach allows for the management of multiple API versions within the same project, generating separate Swagger files for each version. Documentation and examples on versioning can be found in the TypeSpec Azure documentation and the azure-rest-api-specs GitHub repository.", "response": "To introduce a new API version (ApiVersion=B) into your flow while continuing to produce OpenAPI specifications, contracts, and client DLLs for both the new version and all prior versions, you can use the `@versioned` decorator provided by the `@typespec/versioning` library. This approach allows you to define multiple API versions and manage changes across them. Here's how you can achieve this:\n\n1. **Add the Versioning Library**:\n   - Update your `package.json` to include `@typespec/versioning` in both `peerDependencies` and `devDependencies`.\n   - Install the dependencies using `tsp install`.\n\n2. **Define API Versions**:\n   - Use the `@versioned` decorator to define the versions supported by your API. For example:\n     ```tsp\n     import \"@typespec/http\";\n     import \"@typespec/versioning\";\n\n     using Http;\n     using Versioning;\n\n     @service(#{ title: \"My API\" })\n     @versioned(Versions)\n     namespace MyAPI;\n\n     enum Versions {\n       v1: \"1.0\",\n       v2: \"2.0\",\n       vB: \"B\",\n     }\n     ```\n\n3. **Version-Specific Models and Operations**:\n   - Use the `@added` decorator to specify models and operations introduced in specific versions. For example:\n     ```tsp\n     @added(Versions.vB)\n     model NewFeature {\n       id: int32;\n       name: string;\n     }\n     ```\n\n4. **Generate OpenAPI Specifications**:\n   - The TypeSpec compiler will automatically generate separate OpenAPI specifications for each version defined in the `Versions` enum. These specifications will be stored in the output directory, ensuring backward compatibility and clear documentation for all versions.\n\n5. **Generate Client Libraries**:\n   - Use the TypeSpec client generation tools to produce client libraries for each version. You can customize the client generation behavior using decorators like `@client`, `@clientNamespace`, and `@clientApiVersions`.\n\n6. **Override Default API Version Behavior**:\n   - If needed, you can override the default API version behavior using the `@isApiVersion` decorator to explicitly mark parameters as API version parameters.\n\nBy following these steps, you can maintain support for all prior versions while introducing and managing the new ApiVersion=B seamlessly.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#03client.mdx\n- document_title: Clients\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/03client\n- document_content: # howtos#generate-client-libraries#03client.mdx\n\n# Clients\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page explains client behavior and how to customize clients. For an overview of the setup, please refer to the previous page.\r\n\r\n> **NOTE:** JS RLC does not support customization. It will ignore `client.tsp`, and the following scenarios will not affect the JS RLC user experience. In this context, \"TypeScript part\" refers to the JS Modular Emitter.\n\n## Default Behavior\n\n### Basic Rules\n\nBy default, the namespace with the `@service` decorator is generated as a root client. The client name is the namespace name with `Client` appended as a suffix.\r\n\r\nSub-namespaces and interfaces under each root client are generated as operation groups with a hierarchical structure.\r\n\r\nThe sequence of operation groups is determined by the order of namespace declarations, followed by interface declarations.\r\n\r\nThe root client's SDK namespace corresponds to the namespace decorated with `@service`. If an operation group originates from a sub-namespace, its SDK namespace corresponds to that sub-namespace. If it originates from an interface, its SDK namespace corresponds to the namespace containing the interface.\r\n\r\nBy default, operation groups can only be initialized by the root client or their parent operation group.\r\n\r\nDifferent languages organize clients and operation groups differently. Refer to the examples below for details.\n\n### Single Client\n\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(): void;\r\n\r\n@route(\"/op2\")\r\nop pet(): void;\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with One-Layer Child Operation Groups\n\n`PetStore` has two operation groups. The `Dogs` operation group comes from a sub-namespace, while `Cats` comes from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/dogs\")\r\ninterface Dogs {\r\n  feed(): void;\r\n  pet(): void;\r\n}\r\n\r\n@route(\"/cats\")\r\nnamespace Cats {\r\n  op feed(): void;\r\n  op pet(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.dogs.feed()\r\nclient.dogs.pet()\r\nclient.cats.feed()\r\nclient.cats.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.GetDogsClient().Feed();\r\nclient.GetDogsClient().Pet();\r\nclient.GetCatsClient().Feed();\r\nclient.GetCatsClient().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.dogs.feed();\r\nclient.dogs.pet();\r\nclient.cats.feed();\r\nclient.cats.pet();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nDogsClient dogsClient = builder.buildDogsClient();\r\ndogsClient.feed();\r\ndogsClient.pet();\r\n\r\nCatsClient catsClient = builder.buildCatsClient();\r\ncatsClient.feed();\r\ncatsClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with Multi-Layer Child Operation Groups\n\n`PetStore` has three operation groups: `Billings` (from an interface), `Pets` (from a sub-namespace), and `Actions` (from an interface). `Pets` also contains a nested operation group, `Actions`, from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/info\")\r\nop info(): void;\r\n\r\n@route(\"/billings\")\r\ninterface Billings {\r\n  @route(\"history\")\r\n  history(): void;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @route(\"info\")\r\n  op info(): void;\r\n\r\n  @route(\"/actions\")\r\n  interface Actions {\r\n    feed(): void;\r\n    pet(): void;\r\n  }\r\n}\r\n\r\n@route(\"/actions\")\r\ninterface Actions {\r\n  open(): void;\r\n  close(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.info()\r\nclient.billings.history()\r\nclient.pets.info()\r\nclient.pets.actions.feed()\r\nclient.pets.actions.pet()\r\nclient.actions.open()\r\nclient.actions.close()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Info();\r\nclient.GetBillingsClient().History();\r\nclient.GetPetsClient().Info();\r\nclient.GetPetsClient().GetPetsActionsClient().Feed();\r\nclient.GetPetsClient().GetPetsActionsClient().Pet();\r\nclient.GetActionsClient().Open();\r\nclient.GetActionsClient().Close();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.info();\r\nclient.billings.history();\r\nclient.pets.info();\r\nclient.pets.actions.feed();\r\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\n\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\r\npetsActionsClient.feed();\r\npetsActionsClient.pet();\r\n\r\nActionsClient actionsClient = builder.buildActionsClient();\r\nactionsClient.open();\r\nactionsClient.close();\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\nCustomizations SHOULD always be made in a file named `client.tsp` alongside `main.tsp`.\r\n\r\nYou can use `@client` and `@operationGroup` to restructure the client hierarchy. However, if any customizations are made, the client hierarchy will only reflect those customizations. The default behavior logic will no longer apply.\r\n\r\nIf customizations are made, the client's SDK namespace will follow the namespace decorated with `@client` or the namespace containing the interface decorated with `@client`. Similarly, the operation group's SDK namespace follows the same logic for `@operationGroup`. You can override this using `@clientNamespace` if needed.\r\n\r\nThe sequence of clients and operation groups is determined by the order of the `@client` and `@operationGroup` decorators.\r\n\r\nFor this section, we assume you have a service called `PetStore` in the `PetStore` namespace, defining two operations: `feed` and `pet`.\n\n### Renaming the Client Name\n\nThis can be achieved with the augment decorator: `@clientName` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(PetStore, \"PetStoreGreatClient\");\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreGreatClient\r\n\r\nclient = PetStoreGreatClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreGreatClient client = new PetStoreGreatClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreGreatClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreGreatClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreGreatClient client = new PetStoreGreatClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming the Client Namespace\n\nThis can be achieved with the augment decorator: `@clientNamespace` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientNamespace(PetStore, \"PetStoreRenamed\");\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients\n\nTwo clients that separate the operations can be declared using the `@client` decorator from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient, PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetActionClient petActionClient = new PetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nimport { FoodClient, PetActionClient } from \"@azure/package-name\";\r\n\r\nconst client1 = new PetActionClient();\r\nconst client2 = new FoodClient();\r\nclient1.pet();\r\nclient2.feed();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed()\r\npetActionClient.pet()\r\n```\r\n\r\n</ClientTabs>\n\n### One Client and Two Operation Groups\n\nTwo clients that separate the operations can be declared using the `@client` decorator and the `@operationGroup` decorator from `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@client({\r\n  name: \"PetStoreClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@operationGroup\r\ninterface OpGrp1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@operationGroup\r\ninterface OpGrp2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\n\r\nclient.op_grp_1.feed()\r\nclient.op_grp_2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\n\r\nclient.GetOpGrp1Client().Feed();\r\nclient.GetOpGrp2Client().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.opGrp1.feed();\r\nclient.opGrp2.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nOpGrp1Client opGrp1Client = builder.buildOpGrp1Client();\r\nopGrp1Client.feed();\r\n\r\nOpGrp2Client opGrp2Client = builder.buildOpGrp2Client();\r\nopGrp2Client.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Sub-Namespaces\n\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace NewPetStore;\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\nnamespace Food {\r\n  op feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetAction {\r\n  op pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom new_pet_store.food import FoodClient\r\nfrom new_pet_store.pet_action import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport newpetstore.food.FoodClient;\r\nimport newpetstore.food.FoodClientBuilder;\r\nimport newpetstore.petaction.PetActionClient;\r\nimport newpetstore.petaction.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nfoodClient.feed();\r\n\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients and Having Clients in Different Namespaces\n\nTwo clients that separate the operations can be declared using the `client` decorator of `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\n@clientNamespace(\"PetStoreRenamed.SubNamespace\") // use @clientNamespace to specify the namespace of the client\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient\r\nfrom pet_store_renamed.sub_namespace import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\nusing PetStoreRenamed.SubNamespace;\r\n\r\nSubNamespacePetActionClient petActionClient = new SubNamespacePetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport petstorerenamed.FoodClient;\r\nimport petstorerenamed.FoodClientBuilder;\r\nimport petstorerenamed.subnamespace.PetActionClient;\r\nimport petstorerenamed.subnamespace.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Adding Client Initialization Parameters\n\nBy default, we only generate our clients with initialization parameters for `endpoint`, `credential`, and `apiVersion`, whenever any of these are applicable.\r\nThere are cases where spec authors would like their clients to have additional input parameters.\r\n\r\nWith `@clientInitialization`, you can pass in additional parameters you would like your client to have, by passing in `parameters` option of a model.\r\nAll properties of the model will be appended to the current default list of client initialization parameters.\r\nAdditionally, these client parameters will no longer appear on service methods that previously had them as part of the method signature.\r\nThe generated code will automatically pass in the inputted value from the client init to the service.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob_name=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\n\nStorage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\r\n\r\nIf you want to rename the parameter name that you elevate to the client level, you can use the `@paramAlias` decorator.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  @paramAlias(\"blobName\")\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blob(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\n\n### Change Operation Group Initialization Way\n\nBy default, all the nested operation group could only be initialized by parent client or operation group.\r\nThere are cases where spec authors would like their operation groups could both be initialized by parent as well as individually.\r\n\r\nWith `@clientInitialization`, you can change the initialization way, by passing in `initializedBy` option of `InitializedBy.individually | InitializedBy.parent` value.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    initializedBy: InitializedBy.individually | InitializedBy.parent,\r\n  }\r\n);\r\n```\r\n\r\n```python\n\n# TODO\n\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n", "latency": 23.127174854278564, "response_length": 2205}
{"query": "Should we introduce a completely isolated TSP project with its own main.tsp and spec.tsp file for ApiVersion=B?", "ground_truth": "Introducing a completely isolated TSP project with its own main.tsp and spec.tsp file for ApiVersion=B is not necessary. Instead, leveraging the TypeSpec versioning library to manage multiple API versions within the same project is a more efficient approach.", "response": "Introducing a completely isolated TypeSpec (TSP) project with its own `main.tsp` and `spec.tsp` files for `ApiVersion=B` can be a valid approach if the API version introduces significant changes that cannot be easily managed within the same project. This approach ensures clear separation of concerns, avoids potential conflicts, and simplifies maintenance for each version. However, if the changes are incremental or limited, you can use TypeSpec's built-in versioning capabilities, such as the `@versioned` and `@added` decorators, to manage multiple versions within the same project. This allows you to generate separate OpenAPI specifications for each version while keeping the project unified.", "context": "- document_dir: typespec_docs\n- document_filename: introduction#installation.mdx\n- document_title: Installation\n- document_link: https://typespec.io/docs/introduction/installation\n- document_content: # introduction#installation.mdx\n\n# Installation\n\nimport { Aside, Badge, Tabs, TabItem, FileTree, Steps } from \"@astrojs/starlight/components\";\n\n## Install TypeSpec\n\nTypeSpec can be used in two ways:\r\n\r\n- Npm package for use with [Node.js](https://nodejs.org/)\r\n- A standalone executable without any additional dependencies. <Badge text=\"Experimental\" variant=\"caution\" />\r\n\r\n<Tabs>\r\n  <TabItem label=\"Node.JS\">\r\n\r\n<Steps>\r\n\r\n1. Install [Node.js LTS](https://nodejs.org/en/download/)\r\n\r\n2. Install the TypeSpec CLI\r\n\r\n   ```bash\r\n   npm install -g @typespec/compiler\r\n   ```\r\n\r\n</Steps>\r\n\r\n[See package manager doc](../handbook/package-manager.md) for more information on package managers.\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Standalone (Experimental)\">\r\n\r\n<Aside type=\"caution\">The standalone CLI is currently experimental.</Aside>\r\n\r\nTo install, paste this into a terminal:\r\n\r\n<Tabs>\r\n  <TabItem label=\"macOS\">\r\n  \r\n```bash\r\ncurl -fsSL https://typespec.io/install.sh | bash\r\n```\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Windows\">\r\n\r\n```bash\r\npowershell -c \"irm typespec.io/install.ps1|iex\"\r\n```\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Linux\">\r\n  \r\n```bash\r\ncurl -fsSL https://typespec.io/install.sh | bash\r\n```\r\n\r\n  </TabItem>\r\n</Tabs>\r\n\r\n  </TabItem>\r\n</Tabs>\n\n## Install the VS and VS Code extensions\n\nTypeSpec provides extensions for the following editors:\r\n\r\n- [Visual Studio Code](./editor/vscode.md)\r\n- [Visual Studio](./editor/vs.md)\n\n## Create a new TypeSpec project\n\n<Tabs>\r\n  <TabItem label=\"CLI\">\r\n\r\n<Steps>\r\n\r\n1. Create a new TypeSpec project.\r\n\r\n   ```bash\r\n   tsp init\r\n   ```\r\n\r\n   This will prompt you with a few questions. Pick the `Generic REST API` template, your project name, and make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected.\r\n\r\n2. Run a build to generate the OpenAPI specification output file.\r\n\r\n   ```bash\r\n   tsp compile .\r\n   ```\r\n\r\n</Steps>\r\n  </TabItem>\r\n  <TabItem label=\"VS Code\">\r\n\r\n<Steps>\r\n\r\n1. Invoke the command `>TypeSpec: Create TypeSpec Project` to create TypeSpec project, or click `Create TypeSpec Project` button from the Primary Sidebar of Explorer.\r\n2. Follow Quick Picks to select root folder of your project, pick the `Generic REST API` template, input your project name, make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected, then return to launch project scaffolding.\r\n\r\n</Steps>\r\n\r\n![vscode_project_scaffolding.gif](https://raw.githubusercontent.com/microsoft/typespec/main/website/src/content/docs/docs/images/vscode_project_scaffolding.gif)\r\n\r\n  </TabItem>\r\n</Tabs>\r\n\r\nYou should now have a basic TypeSpec project setup with a structure looking like this:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: The entry point for your TypeSpec build. This file typically contains the main definitions for your models, services, and operations.\r\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\r\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\r\n- **node_modules/**: Directory where npm installs the project's dependencies.\r\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\n\ntypically contains the main definitions for your models, services, and operations.\r\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\r\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\r\n- **node_modules/**: Directory where npm installs the project's dependencies.\r\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\r\n- **openapi.yaml**: The generated OpenAPI specification file for your API, detailing the API's endpoints, models, and operations. The output can vary based on the target format specified in the `tspconfig.yaml` file.\r\n\r\nYou can also run `tsp compile . --watch` to automatically compile changes on save.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 13.600122213363647, "response_length": 698}
{"query": "Is it better to incorporate two versions of the resource provider within the same project using one main.tsp, versionA.tsp, and versionB.tsp?", "ground_truth": "It is better to incorporate two versions of the resource provider within the same project using one main.tsp, versionA.tsp, and versionB.tsp. This method is supported by the TypeSpec versioning library, which allows for efficient management of multiple API versions.", "response": "It is better to incorporate multiple versions of a resource provider within the same project using a single `main.tsp` file and leveraging TypeSpec's versioning capabilities. This approach allows you to manage all versions in a unified manner, ensuring consistency and simplifying maintenance. By using the `@versioned` decorator and defining versions with enums, you can specify version-specific models and operations within the same project. This avoids duplication and ensures that the TypeSpec compiler generates separate OpenAPI specifications for each version, maintaining backward compatibility and clear documentation.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step05.md\n- document_title: 6. Complete Example and Generate OpenApi 2.0 spec\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step05\n- document_content: # getstarted#azure-resource-manager#step05.md\n\n# 6. Complete Example and Generate OpenApi 2.0 spec\n\nTo generate an OpenAPI v2 (Swagger) specification from the service definition, run the following command inside of the project folder:\r\n\r\n```\r\ntsp compile . --emit @azure-tools/typespec-autorest\r\n```\r\n\r\nThis will create a file in the `tsp-output` subfolder called `openapi.json`.\r\n\r\nYou can learn more about the `typespec-autorest` emitter and its options by reading its [README.md](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-autorest/README.md).\n\n## A Complete Example\n\nHere's a complete example `main.tsp` file based on all of the snippets in this README:\r\n\r\n```typespec\r\nimport \"@typespec/rest\";\r\nimport \"@typespec/versioning\";\r\nimport \"@azure-tools/typespec-azure-core\";\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nusing Http;\r\nusing Rest;\r\nusing Versioning;\r\nusing Azure.Core;\r\nusing Azure.ResourceManager;\r\n\r\n/** Contoso Resource Provider management API */\r\n@armProviderNamespace\r\n@service(#{ title: \"ContosoProviderHubClient\", version: \"2021-01-01-preview\" })\r\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\r\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\r\nnamespace Microsoft.ContosoProviderHub;\r\n\r\ninterface Operations extends Azure.ResourceManager.Operations {}\r\n\r\n@lroStatus\r\nunion ProvisioningState {\r\n  ResourceProvisioningState,\r\n\r\n  /** The resource is being provisioned. */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is being updated. */\r\n  Updating: \"Updating\",\r\n\r\n  /** The resource is being deleted. */\r\n  Deleting: \"Deleting\",\r\n\r\n  /** The resource provisioning request has been accepted. */\r\n  Accepted: \"Accepted\",\r\n\r\n  string,\r\n}\r\n\r\n/** The properties of User Resource */\r\nmodel UserProperties {\r\n  /** The user's full name */\r\n  fullName: string;\r\n\r\n  /** The user's email address */\r\n  emailAddress: string;\r\n\r\n  /** The status of the last operation */\r\n  provisioningState?: ProvisioningState;\r\n}\r\n\r\n/** A User Resource */\r\nmodel User is TrackedResource<UserProperties> {\r\n  /** Address name */\r\n  @key(\"userName\")\r\n  @segment(\"users\")\r\n  @path\r\n  name: string;\r\n}\r\n\r\n/** The details of a user notification */\r\nmodel NotificationDetails {\r\n  /** The notification message */\r\n  message: string;\r\n\r\n  /** If true, the notification is urgent */\r\n  urgent: boolean;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmResourcePatchSync<User, UserProperties>;\n\n{\r\n  /** Address name */\r\n  @key(\"userName\")\r\n  @segment(\"users\")\r\n  @path\r\n  name: string;\r\n}\r\n\r\n/** The details of a user notification */\r\nmodel NotificationDetails {\r\n  /** The notification message */\r\n  message: string;\r\n\r\n  /** If true, the notification is urgent */\r\n  urgent: boolean;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmResourcePatchSync<User, UserProperties>;\r\n  delete is ArmResourceDeleteSync<User>;\r\n  listByResourceGroup is ArmResourceListByParent<User>;\r\n  listBySubscription is ArmListBySubscription<User>;\r\n  /** Send a notification to the user */\r\n  @segment(\"notify\")\r\n  NotifyUser is ArmResourceActionNoContentSync<User, NotificationDetails>;\r\n}\r\n\r\n/** An address resource belonging to a user resource */\r\n@parentResource(User)\r\nmodel AddressResource is ProxyResource<AddressResourceProperties> {\r\n  ...ResourceNameParameter<AddressResource, KeyName = \"addressName\", SegmentName = \"addresses\">;\r\n}\r\n\r\n/** The properties of AddressResource */\r\nmodel AddressResourceProperties {\r\n  /** The street address */\r\n  streetAddress: string;\r\n\r\n  /** The city of the address */\r\n  city: string;\r\n\r\n  /** The state of the address */\r\n  state: string;\r\n\r\n  /** The zip code of the address */\r\n  zip: int32;\r\n\r\n  /** The status of the last operation */\r\n  provisioningState?: ProvisioningState;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Addresses {\r\n  get is ArmResourceRead<AddressResource>;\r\n  create is ArmResourceCreateOrReplaceSync<AddressResource>;\r\n  update is ArmResourcePatchSync<AddressResource, AddressResourceProperties>;\r\n  delete is ArmResourceDeleteSync<AddressResource>;\r\n  listByParent is ArmResourceListByParent<AddressResource>;\r\n  checkGlobalName is checkGlobalNameAvailability;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#x-ms-examples.mdx\n- document_title: x-ms-examples example files\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\n- document_content: # migrate-swagger#faq#x-ms-examples.mdx\n\n# x-ms-examples example files\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe `x-ms-examples` is automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter.\r\nThe examples must be placed in the `examples-directory` (default to `{project-root}/examples`) and have the `operationdId` property.\r\n\r\n:::caution\r\nDo not use `@extension(\"x-ms-examples\", \"<value>\")`.\r\n:::\n\n## Example structure\n\nExample below assume `example-directory` is `{project-root}/examples`.\r\n\r\n- Single version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - example1.json\r\n  - example2.json\r\n</FileTree>\r\n\r\n- Multi version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - 2021-01-01/\r\n    - example1.json\r\n    - example2.json\r\n  - 2021-01-02/\r\n    - example1.json\r\n    - example2.json\r\n</FileTree>\n\n## Generate the examples\n\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\r\n\r\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\r\n\r\n```bash\r\noav generate-examples openapi.json\r\n```\r\n\r\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\r\n\r\n- include `title` field and make sure it is descriptive and unique for each operation.\r\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\r\n\r\n:::caution\r\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\r\n:::\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step00.md\n- document_title: 1. Installing Tools\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step00\n- document_content: # getstarted#azure-resource-manager#step00.md\n\n# 1. Installing Tools\n\n## Installing IDE Tools\n\nIf you use Visual Studio or Visual Studio code, the TypeSpec extensions are an important tool in providing a first class experience for writing, editing, and reviewing TypeSpec. See [Installing the VS and VS Code Extensions](https://typespec.io/docs#install-the-vs-and-vscode-extensions) for details.\n\n## Creating a Service\n\nThe Azure Resource Manager Service Project will create a very basic TypeSpec file in `main.tsp`:\r\n\r\n```typespec\r\nimport \"@typespec/rest\";\r\nimport \"@typespec/versioning\";\r\nimport \"@azure-tools/typespec-autorest\";\r\nimport \"@azure-tools/typespec-azure-core\";\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n```\r\n\r\nThese lines import the libraries you will need to build your first service.\r\n\r\n**Add the following lines** to bring the models, operations, and decorators you will need into the specification:\r\n\r\n```typespec\r\nusing Http;\r\nusing Rest;\r\nusing Versioning;\r\nusing Azure.Resource.Manager;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 8.6114981174469, "response_length": 626}
{"query": "What are the pros, cons, and potential issues of each approach for managing multiple API versions?", "ground_truth": "The approach of managing multiple API versions within the same project using the TypeSpec versioning library has several advantages, including the ability to generate separate Swagger files for each version and maintain a unified codebase. However, it requires careful management of versioned resources and understanding of the versioning library's capabilities. Potential issues include the complexity of handling API deltas and ensuring compatibility across versions.", "response": "Managing multiple API versions is a critical aspect of API design, and TypeSpec provides tools like the `@versioned` and `@added` decorators to streamline this process. Below are the pros, cons, and potential issues of different approaches for managing multiple API versions:\n\n### Approach 1: Using the `@versioned` Decorator\n#### Pros:\n1. **Unified Management**: The `@versioned` decorator allows you to define all API versions in a single TypeSpec project, simplifying maintenance.\n2. **Automatic OpenAPI Generation**: TypeSpec generates separate OpenAPI specifications for each version, ensuring backward compatibility and clear documentation.\n3. **Consistency**: Centralized version definitions ensure consistent versioning across the API.\n\n#### Cons:\n1. **Complexity for Large APIs**: Managing multiple versions in a single project can become complex as the number of versions grows.\n2. **Potential Redundancy**: If many operations are shared across versions, duplication may occur.\n\n#### Potential Issues:\n- **Version Conflicts**: Mismanagement of version-specific changes can lead to inconsistencies between versions.\n- **Dependency Updates**: Changes in dependencies might inadvertently affect older versions if precautions like locking dependencies are not taken.\n\n### Approach 2: Using the `@added` Decorator for Version-Specific Changes\n#### Pros:\n1. **Granular Control**: The `@added` decorator allows you to specify version-specific models and operations, making it easy to track changes over time.\n2. **Backward Compatibility**: Ensures that new features or changes do not break existing versions.\n3. **Clear Documentation**: Enhances API documentation by explicitly marking version-specific additions.\n\n#### Cons:\n1. **Scattered Version Information**: Version-specific changes are distributed across the codebase, which might make it harder to get a holistic view of version differences.\n2. **Maintenance Overhead**: Requires careful tracking of which features belong to which versions.\n\n#### Potential Issues:\n- **Overlapping Changes**: If multiple decorators are used for different versions, it can lead to confusion or errors in version-specific logic.\n- **Documentation Gaps**: If version-specific changes are not properly documented, it can lead to misunderstandings for API consumers.\n\n### General Considerations:\n1. **Dependency Management**: Use tools like `package-lock.json` to prevent dependency changes from affecting older versions (see Reproducibility guidelines).\n2. **Emitter Design**: Ensure emitters are configured to generate artifacts for specific versions without conflicts.\n3. **Testing**: Regularly test all versions to ensure compatibility and correctness.\n\nBy leveraging TypeSpec's versioning tools and adhering to best practices, you can effectively manage multiple API versions while minimizing risks and maintenance overhead.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#reproducibility.md\n- document_title: Reproducibility\n- document_link: https://typespec.io/docs/handbook/reproducibility\n- document_content: # handbook#reproducibility.md\n\n# Reproducibility\n\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\r\n\r\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\r\n- Updates to a new version of a service should not impact older versions.\r\n- Modifications are made to the TypeSpec specification.\r\n\r\nThese issues can be mitigated with a few precautionary measures:\n\n## 1. Defend against dependency changes\n\n_Note: This section applies if using `tsp install` or `npm install` to install dependencies. However other package managers (`yarn`, `pnpm`, etc.) have their own similar lock mechanisms._\r\n\r\nWhen using `tsp install` or `npm install` a `package-lock.json` will be installed. This file SHOULD be committed to source control. It will ensure that later calls to `tsp install` or `npm install` will use the exact versions resolved in the lock files unless the `package.json` was updated or a command like `npm update` was run.\r\n\r\nThe command `npm ci` can also be used in the CI to ensure that the `package.json` and `package-lock.json` are in sync.\n\n## 2. Work with multiple versions of a service\n\nTypeSpec provides a library `@typespec/versioning` that can be used to describe changes to a service or library over time. Using this will ensure that a service can evolve while keeping track of the changes and allowing emitters to see the service representation at different versions.\r\n\r\n[See versioning docs](../libraries/versioning/reference/index.mdx)\n\n## 3. Change to the TypeSpec spec\n\nIf you don't directly control the spec, you might still want to make sure you remember which exact definition was used.\r\nUsing version control and pinning to a specific commit SHA will ensure that the spec will remain exactly as it was.\n\n## Summary\n\n1. Use `package-lock.json`\r\n2. Use [versioning library](../libraries/versioning/reference/index.mdx)\r\n3. Keep track of commit IDs\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#04-common-parameters.md\n- document_title: Common Parameters\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/04-common-parameters\n- document_content: # getting-started#getting-started-rest#04-common-parameters.md\n\n# Common Parameters\n\n## Introduction\n\nIn this section, we'll focus on reusing common parameters in your REST API. Common parameters are parameters that are used across multiple operations. By defining these parameters once and reusing them, we can make our API more consistent, easier to read, and easier to maintain.\n\n## Creating a Common Parameters Model\n\nLet's start by defining a model for common parameters. This model will include parameters that will be used across all Pet Store operations.\n\n### Example: Defining Common Parameters\n\nFor the sake of demonstration, we're going to require each API call in our Pet Store service to include a request ID, a locale, and a client version. Let's define a model for these common parameters, which we'll label `requestID`, `locale`, and `clientVersion`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@header` decorator is used to indicate that `requestID` and `clientVersion` are header parameters.\r\n- The `@query` decorator is used to indicate that `locale` is a query parameter.\n\n## Reusing Common Parameters Across Multiple Operations\n\nNow that we have defined our common parameters model, let's reuse it across multiple operations in our API.\n\n### Example: Reusing Common Parameters in Operations\n\nPet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  // highlight-next-line\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `CommonParameters` model is reused across multiple operations using the [spread operator](../../../language-basics/models/#spread) `(...)`, which tells the TypeSpec compiler to expand the model definition inline.\r\n- This approach ensures that the common parameters are consistently applied to all relevant operations, making the API more maintainable and reducing redundancy.\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  // highlight-next-line\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  // highlight-next-line\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  // highlight-next-line\r\n  op createPet(@body pet: Pet, ...CommonParameters): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 202;\r\n    @body acceptedPet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 400;\r\n    @body error: ValidationError;\r\n  };\r\n\r\n  @put\r\n  // highlight-next-line\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  // highlight-next-line\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\n\n### Example: OpenAPI Specification for Common Parameters\n\nname: request-id\r\n      in: header\r\n      required: true\r\n      schema:\r\n        type: string\r\n    // highlight-end\r\n  schemas:\r\n    NotFoundError:\r\n      type: object\r\n      properties:\r\n        code:\r\n          type: string\r\n          example: \"NOT_FOUND\"\r\n        message:\r\n          type: string\r\n```\r\n\r\nIn this example:\r\n\r\n- **Parameters Section**: The `deletePet` operation includes the `petId` path parameter and the common parameters (`requestID`, `locale`, and `clientVersion`). The common parameters are referenced using `$ref` to ensure they are consistently defined and reused across multiple operations.\r\n- **Components Section**: The common parameters are defined under the `components` section, ensuring they are reusable and maintainable. Each parameter is specified with its name, location (`in` indicating header or query), whether it is required, and its schema.\n\nLet's take a closer look at how the common parameters model with the `spread` operator is represented in the generated OpenAPI specification by looking at the `deletePet` operation:\r\n\r\n```yaml\r\n#### Generated OpenAPI Specification:\r\n\r\npaths:\r\n  /pets/{petId}:\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n        // highlight-start\r\n        - $ref: \"#/components/parameters/CommonParameters.requestID\"\r\n        - $ref: \"#/components/parameters/CommonParameters.locale\"\r\n        - $ref: \"#/components/parameters/CommonParameters.clientVersion\"\r\n        // highlight-end\r\n      responses:\r\n        \"204\":\r\n          description: \"There is no content to send for this request, but the headers may be useful.\"\r\n        \"404\":\r\n          description: \"Not Found\"\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/NotFoundError\"\r\ncomponents:\r\n  parameters:\r\n    // highlight-start\r\n    CommonParameters.clientVersion:\r\n      name: client-version\r\n      in: header\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.locale:\r\n      name: locale\r\n      in: query\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.requestID:\r\n      name: request-id\r\n      in: header\r\n      required: true\r\n      schema:\r\n        type: string\r\n    // highlight-end\r\n  schemas:\r\n    NotFoundError:\r\n      type: object\r\n      properties:\r\n        code:\r\n          type: string\r\n          example: \"NOT_FOUND\"\r\n        message:\r\n          type: string\r\n```\r\n\r\nIn this example:\r\n\r\n- **Parameters Section**: The `deletePet` operation includes the `petId` path parameter and the common parameters (`requestID`, `locale`, and `clientVersion`).\n\n### Benefits\n\n1. **Consistency**: Ensures that common parameters are applied consistently across all relevant operations.\r\n2. **Maintainability**: Changes to common parameters need to be made only once in the `CommonParameters` model, reducing redundancy and potential errors.\r\n3. **Clarity**: The generated OpenAPI specification clearly shows which parameters are required for each operation, improving the documentation and usability of the API.\n\n## Conclusion\n\nIn this section, we focused on reusing common parameters in your REST API. By defining a common parameters model and reusing it across multiple operations, we can make our API more consistent, easier to read, and easier to maintain.\r\n\r\nNext, we'll learn how to add authentication to our REST API.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#03-handling-errors.md\n- document_title: Handling Errors\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/03-handling-errors\n- document_content: # getting-started#getting-started-rest#03-handling-errors.md\n\n# Handling Errors\n\n## Introduction\n\nIn this section, we'll focus on handling errors in your REST API. We'll define error models and demonstrate how to add them as possible responses to your CRUD operations.\n\n## Why Use Error Models?\n\nUsing error models instead of raw status codes offers several advantages:\r\n\r\n1. **Consistency**: Error models ensure that error responses are consistent across your API. This makes it easier for clients to handle errors predictably.\r\n2. **Clarity**: Error models provide clear, structured information about the error, including error codes, messages, and additional details. This helps developers understand what went wrong and how to fix it.\r\n3. **Extensibility**: Error models can be extended to include additional information, such as error details, validation issues, or links to documentation. This makes it easier to provide comprehensive error information.\r\n4. **Documentation**: Error models improve the generated API documentation by clearly defining the structure of error responses. This helps API consumers understand the possible error responses and how to handle them.\r\n5. **Type Safety**: In strongly-typed languages, using error models can provide type safety, ensuring that error responses conform to the expected structure.\n\n## Defining Error Models\n\nError models can be used to represent different types of errors that your API might return. Let's start by defining some common error models.\n\n### Example: Defining Common Error Models\n\nWe'll define models to represent validation errors, not-found errors, and internal server errors:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n\r\n    // highlight-next-line\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  op createPet(@body pet: Pet): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 202;\r\n    @body acceptedPet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 400;\r\n    @body error: ValidationError;\r\n  };\r\n  // highlight-end\r\n\r\n  @put\r\n  op updatePet(@path petId: int32, @body pet: Pet):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n        // highlight-start\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n        // highlight-end\r\n      };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n// highlight-start\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\n\n}\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n        // highlight-end\r\n      };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n// highlight-start\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `NotFoundError`, `ValidationError`, and `InternalServerError` models are defined to represent different types of errors.\r\n- The `@error` decorator is used to indicate that these models represent error responses.\r\n- The Pet Store operations are updated to return the appropriate error models when the service can't perform the requested operation.\n\n## Conclusion\n\nIn this section, we focused on defining error handling in your REST API. We introduced error models and demonstrated how to represent different operation response scenarios in TypeSpec.\r\n\r\nIn the next section, we'll dive into reusing common parameters in your REST API.\n", "latency": 17.645854234695435, "response_length": 2868}
{"query": "Why is the TypeSpec Validation failing for my PR?", "ground_truth": "The TypeSpec Validation might be failing due to the use of enums, which in the latest version should be converted to open unions. A codefix available in the VSCode or VS extension for TypeSpec can automatically convert enums into open unions. Additionally, ensuring that TypeSpec files are placed in the correct directory, as per the guidelines, can help resolve the issue.", "response": "The TypeSpec validation for your PR might be failing due to a variety of reasons, depending on the specific checks being performed. One common issue is related to the `ProvisioningStateMustBeReadOnly` lintdiff violation, which occurs when the `ProvisioningState` schema is not marked as `readOnly`. This can happen because the validation mechanism used by the LintDiff swagger scripts requires the type schema referenced by the properties to be explicitly marked as `readOnly`. To resolve this, you can configure the `@azure-tools/typespec-autorest` emitter in your `tspConfig.yaml` file to always output the `ProvisioningState` schema as `readOnly` by enabling the `use-read-only-status-schema` option. Here's how you can update your configuration:\n\n```yaml\ntitle=tspconfig.yaml\nemit:\n  - \"@azure-tools/typespec-autorest\"\noptions:\n  \"@azure-tools/typespec-autorest\":\n    use-read-only-status-schema: true\n```\n\nIf this issue is not related to `ProvisioningState`, ensure that your TypeSpec definitions conform to the required rules and guidelines, such as using the correct decorators, adhering to linter rules, and addressing all warnings during compilation. Running `tsp compile .` and reviewing the output can help identify specific issues.", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#status-read-only-error.md\n- document_title: `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\n- document_content: # troubleshoot#status-read-only-error.md\n\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\r\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Symptoms\n\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\r\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Cause\n\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\r\ntype schema referenced by the properties to be `readOnly` instead.\n\n## Workaround\n\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\r\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\r\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\r\nenabled automatically.\r\n\r\n```diff lang=yaml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n+    use-read-only-status-schema: true\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#linters.md\n- document_title: Linters\n- document_link: https://typespec.io/docs/extending-typespec/linters\n- document_content: # extending-typespec#linters.md\n\n# Linters\n\n## Linter versus `onValidate`\n\nA TypeSpec library can provide an `$onValidate` hook, which can be used to validate whether the TypeSpec program is valid according to your library's rules.\r\n\r\nOn the other hand, a linter might provide optional validation. The program could be correct, but there might be room for improvements. For instance, a linter might require documentation on every type. While this isn't necessary to represent the TypeSpec program, it could enhance the end user experience. Linters need to be explicitly enabled, whereas `$onValidate` will run automatically if that library is imported.\n\n## Creating a linter\n\nYou can find examples in `packages/best-practices`.\n\n### 1. Define rules\n\n```ts\r\nimport {  createLinterRule } from \"@typespec/compiler\";\r\nimport { reportDiagnostic } from \"../lib.js\";\r\n\r\nexport const requiredDocRule = createLinterRule({\r\n  name: \"no-model-doc\",\r\n  severity: \"warning\",\r\n  // Short description of what this linter rule does. To be used for generated summary of a linter.\r\n  description: \"Enforce documentation on models.\",\r\n  messages: {\r\n    default: `Must be documented.`,\r\n    // Different messages can be provided\r\n    models: `Models must be documented.`,\r\n\r\n    // Message can be parameterized\r\n    enums: paramMessage`Enum ${\"enumName\"} must be documented.`,\r\n  },\r\n  create(context) {\r\n    return {\r\n      operation: (op) => {\r\n        if (!getDoc(context.program, op)) {\r\n          context.reportDiagnostic({\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n      model: (model) => {\r\n        if (!getDoc(context.program, model)) {\r\n          context.reportDiagnostic({\r\n            messageId: \"models\",\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n      enums: (type) => {\r\n        if (!getDoc(context.program, type)) {\r\n          context.reportDiagnostic({\r\n            messageId: \"enums\",\r\n            format: {enumName: type.name}\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n    };\r\n  },\r\n});\r\n```\r\n\r\n#### Provide a codefix\r\n\r\n[See codefixes](./codefixes.md) for more details on how codefixes work in the TypeSpec ecosystem.\r\n\r\nIn the same way you can provide a codefix on any reported diagnostic, you can pass codefixes to the `reportDiagnostic` function.\r\n\r\n```ts\r\ncontext.reportDiagnostic({\r\n  messageId: \"models\",\r\n  target: model,\r\n  codefixes: [\r\n    defineCodeFix({\r\n      id: \"add-model-suffix\",\r\n      label: \"Add 'Model' suffix to model name\",\r\n      fix: (program) => {\r\n        program.update(model, {\r\n          name: `${model.name}Model`,\r\n        });\r\n      },\r\n    }),\r\n  ],\r\n});\r\n```\r\n\r\n#### Things to avoid\n\nIn the same way you can provide a codefix on any reported diagnostic, you can pass codefixes to the `reportDiagnostic` function.\r\n\r\n```ts\r\ncontext.reportDiagnostic({\r\n  messageId: \"models\",\r\n  target: model,\r\n  codefixes: [\r\n    defineCodeFix({\r\n      id: \"add-model-suffix\",\r\n      label: \"Add 'Model' suffix to model name\",\r\n      fix: (program) => {\r\n        program.update(model, {\r\n          name: `${model.name}Model`,\r\n        });\r\n      },\r\n    }),\r\n  ],\r\n});\r\n```\r\n\r\n#### Things to avoid\r\n\r\n- ❌ Do not call `program.reportDiagnostic` or your library `reportDiagnostic` helper directly in a linter rule\r\n\r\n```ts\r\n// ❌ Bad\r\nprogram.reportDiagnostic({\r\n  code: \"other-code\",\r\n  target,\r\n});\r\n// ❌ Bad\r\nreportDiagnostic(program, {\r\n  code: \"other-code\",\r\n  target,\r\n});\r\n\r\n// ✅ Good\r\ncontext.reportDiagnostic({\r\n  target,\r\n});\r\n```\n\n### Register the rules\n\n<!-- cspell:disable-next-line -->\r\n\r\nExport a `$linter` variable from your library entrypoint:\r\n\r\n```ts title=\"index.ts\"\r\nexport { $linter } from \"./linter.js\";\r\n```\r\n\r\n```ts title=\"linter.ts\"\r\nimport { defineLinter } from \"@typespec/compiler\";\r\n// Import the rule defined previously\r\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\r\n\r\nexport const $linter = defineLinter({\r\n  // Include all the rules your linter is defining here.\r\n  rules: [requiredDocRule],\r\n\r\n  // Optionally a linter can provide a set of rulesets\r\n  ruleSets: {\r\n    recommended: {\r\n      // (optional) A ruleset takes a map of rules to explicitly enable\r\n      enable: { [`@typespec/my-linter/${requiredDocRule.name}`]: true },\r\n\r\n      // (optional) A rule set can extend another rule set\r\n      extends: [\"@typespec/best-practices/recommended\"],\r\n\r\n      // (optional) A rule set can disable a rule enabled in a ruleset it extended.\r\n      disable: {\r\n        \"`@typespec/best-practices/no-a\": \"This doesn't apply in this ruleset.\",\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\nWhen referencing a rule or ruleset (in `enable`, `extends`, `disable`), you must use the rule or rule set id, which is in this format: `<libraryName>/<ruleName>`.\n\n## Testing a linter\n\nTo test a linter rule, a rule tester is provided, allowing you to test a specific rule without enabling the others.\r\n\r\nFirst, you'll want to create an instance of the rule tester using `createLinterRuleTester`, passing it the rule that is being tested. You can then provide different tests to check whether the rule passes or fails.\r\n\r\n```ts\r\nimport { RuleTester, createLinterRuleTester, createTestRunner } from \"@typespec/compiler/testing\";\r\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\r\n\r\ndescribe(\"required-doc rule\", () => {\r\n  let ruleTester: RuleTester;\r\n\r\n  beforeEach(() => {\r\n    const runner = createTestRunner();\r\n    ruleTester = createLinterRuleTester(runner, requiredDocRule, \"@typespec/my-linter\");\r\n  });\r\n\r\n  it(\"emit diagnostics when using model named foo\", async () => {\r\n    await ruleTester.expect(`model Foo {}`).toEmitDiagnostics({\r\n      code: \"@typespec/my-linter/no-foo-model\",\r\n      message: \"Cannot name a model with 'Foo'\",\r\n    });\r\n  });\r\n\r\n  it(\"should be valid to use other names\", async () => {\r\n    await ruleTester.expect(`model Bar {}`).toBeValid();\r\n  });\r\n});\r\n```\n\n### Testing linter with codefixes\n\nThe linter rule tester provides an API to easily test a codefix. This is a different approach from the standalone codefix tester, which is more targeted at testing codefixes in isolation.\r\n\r\nThis can be done by calling `applyCodeFix` with the fix id. It will expect a single diagnostic to be emitted with a codefix with the given id. Then, call `toEqual` with the expected code after the codefix is applied.\r\n\r\n:::note\r\nWhen using multi-line strings (with `\\``) in TypeScript, there is no de-indenting done, so you will need to make sure the input and expected result are aligned to the left.\r\n:::\r\n\r\n```ts\r\nawait tester\r\n  .expect(\r\n    `        \r\n    model Foo {}\r\n    `,\r\n  )\r\n  .applyCodeFix(\"add-model-suffix\").toEqual(`\r\n    model FooModel {}\r\n  `);\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n✅ **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n✅ **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 22.44434905052185, "response_length": 1243}
{"query": "How can I fix the error that limits TypeSpec folder depth to 3 levels or less?", "ground_truth": "To fix the error that limits TypeSpec folder depth to 3 levels or less, ensure that TypeSpec files are placed in the correct directory according to the folder structure guidelines, specifically in specifications/<YourRP>/Management.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_docs\n- document_filename: introduction#editor#vs.md\n- document_title: Visual Studio Extension\n- document_link: https://typespec.io/docs/introduction/editor/vs\n- document_content: # introduction#editor#vs.md\n\n# Visual Studio Extension\n\n## Installation\n\nInstall the extension via the Visual Studio extension manager from the [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=typespec.typespecvs).\n\n## Configure\n\n1. Create a file named `.vs/VSWorkspaceSettings.json` at the root of the project.\r\n2. Add the configuration as a key-value pair in this file. For example:\r\n\r\n```json\r\n{\r\n  \"typespec.tsp-server.path\": \"${workspaceFolder}/my-nested-project/node_modules/@typespec/compiler\"\r\n}\r\n```\r\n\r\nTypeSpec will interpolate a few variables using this pattern: `${<name>}`. For example: `${workspaceFolder}`.\r\n\r\nAvailable variables:\r\n\r\n- `workspaceFolder`: Corresponds to the root of your Visual Studio workspace.\n\n## Uninstall\n\nYou can uninstall the extension via the Visual Studio extension manager or through the command line:\r\n\r\n```bash\r\ntsp vs uninstall\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/extending-typespec/diagnostics\n- document_content: # extending-typespec#diagnostics.md\n\n# Diagnostics\n\nThe TypeSpec compiler uses the diagnostic API to report errors and warnings in the specification.\n\n## Best practices\n\n- ❌ Avoid using `throw` to report errors. Any exceptions thrown in this manner will be perceived as bugs in your library by the user.\r\n- ✅ Utilize the diagnostic API to report anticipated errors and warnings.\r\n  - ✅ Employ `reportDiagnostic` in a decorator, `$onValidate` or `$onEmit`\r\n  - ❌ Refrain from using `reportDiagnostic` in an accessor (a function intended to be used in another library or emitter). Refer to the [section on collecting diagnostics](#collect-diagnostics) for more information.\n\n## Diagnostic requirements\n\n- Each diagnostic MUST have a `code`. The complete code is the library name followed by the declared code. (`<lib-name>/<local-code>`)\r\n- Each diagnostic MUST have a `severity`. It can be `error` or `warning`. Errors cannot be suppressed.\r\n- Each diagnostic MUST have at least one message. Using `default` as the `messageId` will make it the default selection.\r\n- Each diagnostic message MAY have parameters to interpolate information into the message.\n\n## How to use\n\n### Declare the diagnostics you plan to report\n\n```ts\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\n// in lib.js\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"@typespec/my-lib\",\r\n  diagnostics: {\r\n    // Basic diagnostic with a fixed message\r\n    \"no-array\": {\r\n      severity: \"error\",\r\n      messages: {\r\n        default: `Array is not allowed in my-lib models.`,\r\n      },\r\n    },\r\n\r\n    // Parameterized message\r\n    \"duplicate-route\": {\r\n      severity: \"error\",\r\n      messages: {\r\n        default: paramMessage`Route '${\"path\"}' is being referenced in 2 different operations.`,\r\n      },\r\n    },\r\n\r\n    // Multiple messages\r\n    \"duplicate-name\": {\r\n      severity: \"warning\",\r\n      messages: {\r\n        default: paramMessage`Duplicate type name: '${\"value\"}'.`,\r\n        parameter: paramMessage`Duplicate parameter key: '${\"value\"}'.`,\r\n      },\r\n    },\r\n  },\r\n} as const);\r\n\r\n// Re-export the helper functions to be able to just call them directly.\r\nexport const { reportDiagnostic, createDiagnostic };\r\n```\r\n\r\nThis will represent three different diagnostics with the full names of:\r\n\r\n- `@typespec/my-lib/no-array`\r\n- `@typespec/my-lib/duplicate-route`\r\n- `@typespec/my-lib/duplicate-name`\n\n### Report diagnostics\n\n```ts\r\nimport { reportDiagnostic } from \"./lib.js\";\r\n\r\n// Basic diagnostic with a fixed message\r\nreportDiagnostic(program, {\r\n  code: \"no-array\",\r\n  target: diagnosticTarget,\r\n});\r\n\r\n// Parameterized message\r\nreportDiagnostic(program, {\r\n  code: \"duplicate-route\",\r\n  format: {path: \"/foo\"}\r\n  target: diagnosticTarget,\r\n});\r\n\r\n// Multiple messages\r\nreportDiagnostic(program, {\r\n  code: \"duplicate-name\",\r\n  messageId: \"parameter\",\r\n  format: {value: \"$select\"},\r\n  target: diagnosticTarget,\r\n});\r\n```\n\n### Collect diagnostics\n\nWhen attempting to report a diagnostic in an accessor, a good practice is not to report the diagnostic to the program directly, but return a tuple to let the user decide what to do.\r\nThis prevents duplicate diagnostics emitter if the accessor is called multiple times.\r\n\r\n```ts\r\nimport { createDiagnosticCollector, Diagnostic } from \"@typespec/compiler\";\r\n\r\nfunction getRoutes(): [Route, readonly Diagnostic] {\r\n  const diagnostics = createDiagnosticCollector();\r\n  diagnostics.add(\r\n    createDiagnostic(program, {\r\n      code: \"no-array\",\r\n      target: diagnosticTarget,\r\n    }),\r\n  );\r\n  const result = diagnostic.pipe(getParameters()); // to pipe diagnostics returned by `getParameters`\r\n  return diagnostics.wrap(routes);\r\n}\r\n```\r\n\r\nor manually\r\n\r\n```ts\r\nimport { Diagnostic } from \"@typespec/compiler\";\r\n\r\nfunction getRoutes(): [Route, readonly Diagnostic] {\r\n  const diagnostics = [];\r\n  diagnostics.push(\r\n    createDiagnostic(program, {\r\n      code: \"no-array\",\r\n      target: diagnosticTarget,\r\n    }),\r\n  );\r\n  return [routes, diagnostics];\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#codefixes.md\n- document_title: Code fixes\n- document_link: https://typespec.io/docs/extending-typespec/codefixes\n- document_content: # extending-typespec#codefixes.md\n\n# Code fixes\n\n## Define a code fix\n\nA code fix can be defined using the `defineCodeFix` function which is just here to help with typing. It doesn't need to be declared separately from being reported but doing so allows you to test it.\r\n\r\nA codefix takes 3 arguments:\r\n\r\n- `id`: A unique identifier for the code fix.\r\n- `label`: A human-readable label for the code fix.\r\n- `fix`: The implementation of the codefix. Takes in a context that allows patch operations on the source code. The fix function should return the list of changes to apply to the source code.\r\n\r\n```ts\r\nimport { defineCodeFix, getSourceLocation, type IdentifierNode } from \"@typespec/compiler\";\r\n\r\nexport function createChangeIdentifierCodeFix(node: IdentifierNode, newIdentifier: string) {\r\n  return defineCodeFix({\r\n    id: \"change-identifier\",\r\n    label: `Change ${node.sv} to ${newIdentifier}`,\r\n    fix: (context) => {\r\n      const location = getSourceLocation(node);\r\n      return context.replaceText(location, newIdentifier);\r\n    },\r\n  });\r\n}\r\n```\n\n## Connect a codefix to a diagnostic\n\nWhen reporting diagnostics, you can pass `codefixes` to the `reportDiagnostic`/`createDiagnostic` functions. It is an array of codefixes that can be used to fix the diagnostic.\r\n\r\n```ts\r\nreportDiagnostic({\r\n  code: \"invalid-identifier\",\r\n  target: node,\r\n  codefixes: [createChangeIdentifierCodeFix(node, \"string\")],\r\n});\r\n```\n\n## Test a diagnostic\n\n[See here for testing a codefix inside a linter rule](./linters.md#testing-linter-with-codefixes)\r\n\r\nTesting a codefix is done by using the `expectCodeFixOnAst` function from the `@typespec/compiler/testing` package. It takes in the source code and a function that returns the codefix to apply.\r\nIt takes the input source code with a cursor defined by `┆` which will be used to resolve the node where the codefix should be applied. The callback function will receive that resolved node and is expected to return the codefix to test.\r\n\r\n:::note\r\nWhen using multi-line strings (with `\\``) in typescript there is no de-indenting done so you will need to make sure the input and expected result are aligned to the left.\r\n:::\r\n\r\n```ts\r\nimport { strictEqual } from \"assert\";\r\nimport { createChangeIdentifierCodeFix } from \"./change-identifier.codefix.js\";\r\nimport { SyntaxKind } from \"@typespec/compiler\";\r\nimport { expectCodeFixOnAst } from \"@typespec/compiler/testing\";\r\n\r\ndescribe(\"CodeFix: change-identifier\", () => {\r\n  it(\"it change identifier\", async () => {\r\n    await expectCodeFixOnAst(\r\n      `\r\n      model Foo {\r\n        a: ┆number;\r\n      }\r\n    `,\r\n      (node) => {\r\n        strictEqual(node.kind, SyntaxKind.Identifier);\r\n        return createChangeIdentifierCodeFix(node, \"int32\");\r\n      },\r\n    ).toChangeTo(`\r\n      model Foo {\r\n        a: int32;\r\n      }\r\n    `);\r\n  });\r\n});\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n", "latency": 12.495893955230713, "response_length": 79}
{"query": "What am I missing in following the folder structure like other RPs in the repo?", "ground_truth": "Following the folder structure like other RPs in the repo requires placing TypeSpec files in the correct directory, specifically in specifications/<YourRP>/Management, as outlined in the folder structure guidelines.", "response": "To follow the folder structure like other Resource Providers (RPs) in the repository, you need to ensure that your output configuration in the `tspconfig.yaml` file matches the expected structure. Specifically, if you have changed the provider namespace using the `@armProviderNamespace` decorator, you must update the `output-file` path in the configuration to reflect the new namespace. For example, replace `{service-name}` with your custom provider namespace in the path. This ensures that the generated files are placed in the correct directory structure within the repository.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#change-provider-namespace.md\n- document_title: Change the provider namespace\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/change-provider-namespace\n- document_content: # howtos#arm#change-provider-namespace.md\n\n# Change the provider namespace\n\nIf you want to have a different provider namespace than the TypeSpec namespec you'll have to change the following\n\n## 1. Change the name in the spec\n\n```tsp\r\n@armProviderNamespace(\"MyDifferent.ProviderName\")\r\nnamespace Microsoft.Contoso {\r\n\r\n}\r\n```\n\n## 2. Change the output configuration\n\nIf you want to match the folder structure of the azure-specs repo you might have to replace the `{service-name}` interpolation with the name you changed.\r\n\r\n```diff lang=yaml\r\noptions:\r\n  '@azure-tools/typespec-autorest':\r\n     # ... other options\r\n-    output-file: \"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/xxx.json\"\r\n+    output-file: \"{azure-resource-provider-folder}/MyDifferent.ProviderName/{version-status}/{version}/xxx.json\"\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#createproject.md\n- document_title: Creating a project\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/createproject\n- document_content: # getstarted#createproject.md\n\n# Creating a project\n\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\r\n\r\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\r\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n3. To create a new Azure service specification, use the `tsp init` command:\r\n\r\n```bash\r\ntsp init https://aka.ms/typespec/azure-init\r\n```\r\n\r\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\n\n### Understanding Project Templates\n\nWhen initializing a new project, you'll encounter four templates:\r\n\r\n| Template Name                                                   | Description                                                                                                                                                                          |\r\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| **(rest-api-spec repo) Azure Data Plane Service Project**       | This template is configured for projects within the `azure-rest-api-specs` repository, with settings that comply with the repo's requirements, such as file paths and linting rules. |\r\n| **(rest-api-spec repo) Azure Resource Manager Service Project** | Similar to the above, but tailored for Azure Resource Manager services within the `azure-rest-api-specs` repository.                                                                 |\r\n| **(standalone) Azure Data Plane Service Project**               | This template is configured for local use or in a personal repo, allowing for API development without the specific directory structure of the `azure-rest-api-specs` repo.           |\r\n| **(standalone) Azure Resource Manager Service Project**         | Similar to the above but designed for Azure Resource Manager services, configured for local use or in a personal repo.                                                               |\n\n### Target Users\n\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\r\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\n\n### Install the dependencies\n\nNow that the new project has been created, you can install the dependencies by running the following command:\r\n\r\n- `npm ci` - If in the `azure-rest-api-specs` repo.\r\n- `tsp install` - If a standalone project\r\n\r\nAfter setting up your project, run `tsp install` to install dependencies. You can then open the file `main.tsp` to continue with the tutorial. Choose the tutorial that matches your chosen project template:\r\n\r\n| Azure Service Type       | Tutorial                                      | Produces                   |\r\n| ------------------------ | --------------------------------------------- | -------------------------- |\r\n| Azure Data-Plane Service | [Azure-Core tutorial](azure-core/step01)      | OpenApi 2.0 (Swagger) spec |\r\n| Azure Management Service | [ARM tutorial](azure-resource-manager/step00) | OpenApi 2.0 (Swagger) spec |\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#repo_setup.md\n- document_title: Repo setup\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/repo_setup\n- document_content: # howtos#generate-with-tsp-client#repo_setup.md\n\n# Repo setup\n\nEach repository that intends to support `tsp-client` for generating and updating client libraries will need to set up an `emitter-package.json` file under the `eng/` directory at the root of the repository. Client libraries generated with this tool will be outputted based on the information in the tspconfig.yaml file of the TypeSpec specification. The service directory is specified through the `parameters.service-dir.default` parameter in the tspconfig.yaml, additionally the `package-dir` option for the specific emitter is appended to the end of the path.\r\n\r\nSee the following example of a valid tspconfig.yaml file: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n\r\nUsing the tspconfig.yaml linked above, by default, the client libraries will be generated in the following directory for C#: `<repo>/sdk/contosowidgetmanager/Azure.Template.Contoso/`.\n\n### Required set up\n\nPlease note that these requirements apply on the repository where the client library is going to be generated. Repo owners should make sure to follow these requirements. Users working within a repository that already accepts this tool can refer to the [Usage](https://aka.ms/azsdk/tsp-client) doc.\r\n\r\n- Add an emitter-package.json to the repo following this [configuration](#emitter-packagejson-required).\r\n- Add the [TempTypeSpecFiles](#temptypespecfiles) directory to the .gitignore file for your repository.\n\n### TempTypeSpecFiles\n\nThis tool creates a `TempTypeSpecFiles` directory when syncing a TypeSpec project to your local repository. This temporary folder will contain a copy of the TypeSpec project specified by the parameters set in the tsp-location.yaml file. If you pass the `--save-inputs` flag to the commandline tool, this directory will not be deleted. You should add a new entry in the .gitignore of your repo so that none of these files are accidentally checked in if `--save-inputs` flag is passed in.\r\n\r\n```diff title=\".gitignore\" lang=\"sh\"\r\n+ TempTypeSpecFiles/\r\n```\n\n### emitter-package.json (Required)\n\n`emitter-package.json` will be used the same as a `package.json` file. If the is no `emitter-package-lock.json` file, the tool will run `npm install` on the contents of `emitter-package.json`. This file allows each repository to pin the version of their emitter and other dependencies to be used when generating client libraries.\r\nThe file should be checked into this location `<root of repo>/eng/emitter-package.json`\r\n\r\nExample:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-python\": \"0.21.0\"\r\n  }\r\n}\r\n```\r\n\r\n:::note\r\ntsp compile currently requires the \"main\" line to be there.\r\n:::\r\n\r\nThis file replaces the package.json checked into the `azure-rest-api-spec` repository.\n\n### emitter-package-lock.json (Optional)\n\n`emitter-package-lock.json` will be used the same as a `package-lock.json`. The tool will run a clean npm installation before generating client libraries. This file allows consistent dependency trees and allows each repository to control their dependency installation.\r\nThe file should be checked into this location: `<root of repo>/eng/emitter-package-lock.json`\r\n\r\n:::caution\r\nThe tool will run `npm ci` to install dependencies, so ensure that the `emitter-package-lock.json` and `emitter-package.json` files both exist and are in sync with each other.\r\n:::\n", "latency": 8.070555448532104, "response_length": 582}
{"query": "How can I auto-create a Swagger definition from TypeSpec?", "ground_truth": "To auto-create a Swagger definition from TypeSpec, configure the typespec-autorest emitter to emit Swagger in accordance with the azure-rest-api-specs repository requirements. Detailed instructions can be found in the azure-rest-api-specs documentation on GitHub.", "response": "To auto-create a Swagger definition (OpenAPI v2) from a TypeSpec project, you can use the `typespec-autorest` emitter. Follow these steps:\n\n1. Navigate to your TypeSpec project directory.\n2. Run the following command:\n   ```bash\n   tsp compile . --emit @azure-tools/typespec-autorest\n   ```\n3. This will generate an OpenAPI v2 (Swagger) specification file named `openapi.json` in the `tsp-output` subfolder.\n\nIf you need to include examples in the Swagger definition, place the example files in the `examples` directory of your project. Ensure the examples include the `operationId` property to match declared operations in TypeSpec. You can use tools like [oav](https://github.com/Azure/oav) to generate basic examples and then modify them manually for meaningful values.\n\nFor more details on the `typespec-autorest` emitter and its options, refer to its [README.md](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-autorest/README.md).", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step05.md\n- document_title: 6. Complete Example and Generate OpenApi 2.0 spec\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step05\n- document_content: # getstarted#azure-resource-manager#step05.md\n\n# 6. Complete Example and Generate OpenApi 2.0 spec\n\nTo generate an OpenAPI v2 (Swagger) specification from the service definition, run the following command inside of the project folder:\r\n\r\n```\r\ntsp compile . --emit @azure-tools/typespec-autorest\r\n```\r\n\r\nThis will create a file in the `tsp-output` subfolder called `openapi.json`.\r\n\r\nYou can learn more about the `typespec-autorest` emitter and its options by reading its [README.md](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-autorest/README.md).\n\n## A Complete Example\n\nHere's a complete example `main.tsp` file based on all of the snippets in this README:\r\n\r\n```typespec\r\nimport \"@typespec/rest\";\r\nimport \"@typespec/versioning\";\r\nimport \"@azure-tools/typespec-azure-core\";\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nusing Http;\r\nusing Rest;\r\nusing Versioning;\r\nusing Azure.Core;\r\nusing Azure.ResourceManager;\r\n\r\n/** Contoso Resource Provider management API */\r\n@armProviderNamespace\r\n@service(#{ title: \"ContosoProviderHubClient\", version: \"2021-01-01-preview\" })\r\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\r\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\r\nnamespace Microsoft.ContosoProviderHub;\r\n\r\ninterface Operations extends Azure.ResourceManager.Operations {}\r\n\r\n@lroStatus\r\nunion ProvisioningState {\r\n  ResourceProvisioningState,\r\n\r\n  /** The resource is being provisioned. */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is being updated. */\r\n  Updating: \"Updating\",\r\n\r\n  /** The resource is being deleted. */\r\n  Deleting: \"Deleting\",\r\n\r\n  /** The resource provisioning request has been accepted. */\r\n  Accepted: \"Accepted\",\r\n\r\n  string,\r\n}\r\n\r\n/** The properties of User Resource */\r\nmodel UserProperties {\r\n  /** The user's full name */\r\n  fullName: string;\r\n\r\n  /** The user's email address */\r\n  emailAddress: string;\r\n\r\n  /** The status of the last operation */\r\n  provisioningState?: ProvisioningState;\r\n}\r\n\r\n/** A User Resource */\r\nmodel User is TrackedResource<UserProperties> {\r\n  /** Address name */\r\n  @key(\"userName\")\r\n  @segment(\"users\")\r\n  @path\r\n  name: string;\r\n}\r\n\r\n/** The details of a user notification */\r\nmodel NotificationDetails {\r\n  /** The notification message */\r\n  message: string;\r\n\r\n  /** If true, the notification is urgent */\r\n  urgent: boolean;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmResourcePatchSync<User, UserProperties>;\n\n{\r\n  /** Address name */\r\n  @key(\"userName\")\r\n  @segment(\"users\")\r\n  @path\r\n  name: string;\r\n}\r\n\r\n/** The details of a user notification */\r\nmodel NotificationDetails {\r\n  /** The notification message */\r\n  message: string;\r\n\r\n  /** If true, the notification is urgent */\r\n  urgent: boolean;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmResourcePatchSync<User, UserProperties>;\r\n  delete is ArmResourceDeleteSync<User>;\r\n  listByResourceGroup is ArmResourceListByParent<User>;\r\n  listBySubscription is ArmListBySubscription<User>;\r\n  /** Send a notification to the user */\r\n  @segment(\"notify\")\r\n  NotifyUser is ArmResourceActionNoContentSync<User, NotificationDetails>;\r\n}\r\n\r\n/** An address resource belonging to a user resource */\r\n@parentResource(User)\r\nmodel AddressResource is ProxyResource<AddressResourceProperties> {\r\n  ...ResourceNameParameter<AddressResource, KeyName = \"addressName\", SegmentName = \"addresses\">;\r\n}\r\n\r\n/** The properties of AddressResource */\r\nmodel AddressResourceProperties {\r\n  /** The street address */\r\n  streetAddress: string;\r\n\r\n  /** The city of the address */\r\n  city: string;\r\n\r\n  /** The state of the address */\r\n  state: string;\r\n\r\n  /** The zip code of the address */\r\n  zip: int32;\r\n\r\n  /** The status of the last operation */\r\n  provisioningState?: ProvisioningState;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Addresses {\r\n  get is ArmResourceRead<AddressResource>;\r\n  create is ArmResourceCreateOrReplaceSync<AddressResource>;\r\n  update is ArmResourcePatchSync<AddressResource, AddressResourceProperties>;\r\n  delete is ArmResourceDeleteSync<AddressResource>;\r\n  listByParent is ArmResourceListByParent<AddressResource>;\r\n  checkGlobalName is checkGlobalNameAvailability;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#add-common-types.md\n- document_title: Adding Common Types to Azure Resource Manager (ARM)\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/add-common-types\n- document_content: # howtos#arm#add-common-types.md\n\n# Adding Common Types to Azure Resource Manager (ARM)\n\nThis guide provides detailed instructions on how to add and manage common types in Azure Resource Manager (ARM) using Common types are reusable components that can be shared across multiple ARM templates, ensuring consistency and reducing redundancy.\r\n\r\nThe TypeSpec common-types files are located in the [typespec-azure repository](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types). The generated Swagger files can be found in the [common-types/openapi directory](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/openapi).\r\n\r\nThere are two main approaches to editing common types:\r\n\r\n1. **Creating a New Version of an Existing Common Type**: This involves updating an existing common type with new versioning information and making necessary changes.\r\n2. **Creating a Completely New Common Type**: This involves defining a new common type from scratch and integrating it into the existing system.\r\n\r\nFollow the steps outlined in this guide to ensure that your common types are correctly added and documented.\n\n## Create a New Version of an Existing Common Type\n\n[Pull Request Example](https://github.com/Azure/typespec-azure/pull/1689/files)\r\n\r\nCreating a new version of an existing common type mostly involves editing what is already there and adding the new version of the common type.\r\n\r\n1. Make all the necessary versioning changes in the common-type file, mostly using `@added(Versions.vX)`, `@removed(Versions.vX)`, and `@typeChangedFrom(Versions.vX)` decorators.\r\n2. Update the common-type-ref file by adding the new version of the common type using the `@@armCommonDefinition` decorator .This needs to be done for all the definitions present in the new version, not only the newly added definitions.\r\n   ```typespec\r\n   @@armCommonDefinition(ExtensionResource,\r\n     \"ProxyResource\",\r\n     Azure.ResourceManager.CommonTypes.Versions.v6\r\n   );\r\n   ```\r\n3. If it is a completely new version, add the version to [versions.tsp](https://github.com/AlitzelMendez/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/versions.tsp))\r\n4. Generate the Swagger updates by running:\r\n   ```bash\r\n   cd typespec-azure\\packages\\samples\\common-types\r\n   pnpm regen-common-types\r\n   ```\r\n5. Generate the documentation\r\n   ```bash\r\n   pnpm gen-docs\r\n   ```\n\n## Create a new common type\n\n[Example of a pull request](https://github.com/Azure/typespec-azure/pull/1505/files)\r\n\r\n1. Create a new file in the [common-types folder](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types) with your common type name, e.g., `managed-identity-with-delegation.tsp`.\r\n1. Write the common type in the `managed-identity-with-delegation.tsp` file:\r\n   - Use the `@added(Versions.vX)` decorator in all models to specify in which version the model is added.\r\n1. Create a new reference file in the [common-types folder](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types) with the common type name and the `-ref` suffix, e.g., `managed-identity-with-delegation-ref.tsp`\r\n1. Edit the `-ref` file:\r\n\r\n   - Start by importing the common type TypeSpec file.\r\n     ```typespec\r\n     import \"./managed-identity-with-delegation.tsp\";\r\n     ```\r\n   - In the `-ref` file write the reference to all the definitions you just created using the `@@armCommonDefinition(` decorator. Expose every single version in which the definition is available.\r\n\r\n     ```typespec\r\n     @@armCommonDefinition(ManagedServiceIdentityWithDelegation,\r\n       \"ManagedServiceIdentityWithDelegation\",\r\n       Azure.ResourceManager.CommonTypes.Versions.v4\r\n     );\r\n     @@armCommonDefinition(ManagedServiceIdentityWithDelegation,\r\n       \"ManagedServiceIdentityWithDelegation\",\r\n       Azure.ResourceManager.CommonTypes.Versions.v5\r\n     );\r\n     ```\r\n\r\n1. Add the common-type file to [common-types.tsp](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/common-types.tsp)\r\n1. Create an equivalent file of the common type in [samples/common-types/src](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/src) (`managed-identity-with-delegation.tsp`)\r\n1. In that file, import the TypeSpec file you created before: `import \"../..\n\n);\r\n     ```\r\n\r\n1. Add the common-type file to [common-types.tsp](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/common-types.tsp)\r\n1. Create an equivalent file of the common type in [samples/common-types/src](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/src) (`managed-identity-with-delegation.tsp`)\r\n1. In that file, import the TypeSpec file you created before: `import \"../../node_modules/@azure-tools/typespec-azure-resource-manager/lib/common-types/managed-identity-with-delegation.tsp\";`\r\n1. Indicate that you want to emit the common types Swagger by updating [gen.ts](https://github.com/Azure/typespec-azure/blob/main/packages/samples/common-types/gen.ts)), adding a line like the following:\r\n   ```typespec\r\n   await emitCommonTypesSwagger(\"managed-identity-with-delegation\");\r\n   ```\r\n1. Generate the Swagger updates by running:\r\n   ```bash\r\n   cd typespec-azure\\packages\\samples\\common-types\r\n   pnpm regen-common-types\r\n   ```\r\n1. Finally, generate the documentation:\r\n   ```bash\r\n   pnpm gen-docs\r\n   ```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#x-ms-examples.mdx\n- document_title: x-ms-examples example files\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\n- document_content: # migrate-swagger#faq#x-ms-examples.mdx\n\n# x-ms-examples example files\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe `x-ms-examples` is automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter.\r\nThe examples must be placed in the `examples-directory` (default to `{project-root}/examples`) and have the `operationdId` property.\r\n\r\n:::caution\r\nDo not use `@extension(\"x-ms-examples\", \"<value>\")`.\r\n:::\n\n## Example structure\n\nExample below assume `example-directory` is `{project-root}/examples`.\r\n\r\n- Single version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - example1.json\r\n  - example2.json\r\n</FileTree>\r\n\r\n- Multi version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - 2021-01-01/\r\n    - example1.json\r\n    - example2.json\r\n  - 2021-01-02/\r\n    - example1.json\r\n    - example2.json\r\n</FileTree>\n\n## Generate the examples\n\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\r\n\r\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\r\n\r\n```bash\r\noav generate-examples openapi.json\r\n```\r\n\r\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\r\n\r\n- include `title` field and make sure it is descriptive and unique for each operation.\r\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\r\n\r\n:::caution\r\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\r\n:::\n", "latency": 46.34738063812256, "response_length": 956}
{"query": "Why does running npx tsv in the private repo fail with an error about using the enum keyword?", "ground_truth": "Running npx tsv in the private repo fails with an error about using the enum keyword because the current tooling does not handle enums well as union variants. The recommended approach is to convert enums to unions to ensure compatibility.", "response": "The error about using the `enum` keyword occurs because Azure services now favor extensible enums to avoid breaking changes when new values are added. TypeSpec enums are closed by default, meaning they cannot be extended. To resolve this issue, you need to replace the `enum` with a `union` that includes a base scalar type (e.g., `string`) as one of its variants. This makes the enum extensible. For example, if you have:\n\n```tsp\nenum PetKind {\n  Cat,\n  Dog,\n}\n```\n\nYou should convert it to:\n\n```tsp\nunion PetKind {\n  Cat: \"Cat\",\n  Dog: \"Dog\",\n  string,\n}\n```\n\nAdditionally, if you are using the TypeSpec Azure library, you might encounter the linter warning `@azure-tools/typespec-azure-core/no-enum`. This warning indicates that enums are not recommended and provides an automatic code fix in supported editors like VS Code.", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the (ℹ) bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#enums.md\n- document_title: Enums\n- document_link: https://typespec.io/docs/language-basics/enums\n- document_content: # language-basics#enums.md\n\n# Enums\n\nEnums, short for enumerations, provide a way for developers to define a collection of named constants. They are useful for documenting the purpose of the code or for establishing a set of distinct scenarios. Enums can be either numeric or string-based. For other data types, consider using [unions](./unions.md).\n\n## The basics\n\nYou can declare enums using the `enum` keyword. The members of an enum are separated by commas `,` and can be either [`identifier`](./identifiers.md) TypeSpecs or `string literal`s.\r\n\r\n```typespec\r\nenum Direction {\r\n  North,\r\n  East,\r\n  South,\r\n  West,\r\n}\r\n```\r\n\r\nIn the above example, we haven't defined the representation of the constants. Depending on the context, enums might be handled differently.\n\n## Assigning values to enums\n\nYou can assign custom values to enum members using the `:` operator.\r\n\r\n```typespec\r\nenum Direction {\r\n  North: \"north\",\r\n  East: \"east\",\r\n  South: \"south\",\r\n  West: \"west\",\r\n}\r\n```\r\n\r\nThese values can also be integers.\r\n\r\n```typespec\r\nenum Foo {\r\n  One: 1,\r\n  Ten: 10,\r\n  Hundred: 100,\r\n  Thousand: 1000,\r\n}\r\n```\r\n\r\nOr even floating-point numbers.\r\n\r\n```typespec\r\nenum Hour {\r\n  Zero: 0,\r\n  Quarter: 0.25,\r\n  Half: 0.5,\r\n  ThreeQuarter: 0.75,\r\n}\r\n```\n\n## Combining enums\n\nYou can combine enums using the spread `...` pattern. This copies all the members from the source enum to the target enum, but it doesn't establish any reference between the source and target enums.\r\n\r\n```typespec\r\nenum DirectionExt {\r\n  ...Direction,\r\n  `North East`,\r\n  `North West`,\r\n  `South East`,\r\n  `South West`,\r\n}\r\n```\n\n## How to reference enum members\n\nYou can reference enum members using the `.` operator for identifiers.\r\n\r\n```typespec\r\nalias North = Direction.North;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-private-usage.md\n- document_title: no-private-usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-private-usage\n- document_content: # libraries#azure-core#rules#no-private-usage.md\n\n# no-private-usage\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-private-usage\r\n```\r\n\r\nVerify that a spec is not referencing items from another library using a private namespace.\r\n\r\n#### ❌ Incorrect\r\n\r\n```ts\r\n@Azure.Core.Foundations.Private.embeddingVector(string)\r\nmodel Foo {}\r\n```\r\n\r\n#### ✅ Ok\r\n\r\nUsing items from a private namespace within the same library is allowed.\r\n\r\n```ts\r\nnamespace MyService;\r\n\r\n@MyService.Private.myPrivateDecorator\r\nmodel Foo {}\r\n\r\n\r\nnamespace Private {\r\n  extern dec myPrivateDecorator(target);\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#identifiers.md\n- document_title: Identifiers\n- document_link: https://typespec.io/docs/language-basics/identifiers\n- document_content: # language-basics#identifiers.md\n\n# Identifiers\n\nIdentifiers are used to name models, enums, properties, and other entities in TypeSpec. An identifier is a sequence of one or more characters that must start with a letter, emoji, underscore, or dollar sign, and be followed by letters, numbers, emoji, underscores, or dollar signs. TypeSpec implements [UAX31-R1b stable identifiers](http://www.unicode.org/reports/tr31/#R1b) with the [emoji profile](http://www.unicode.org/reports/tr31/#Emoji_Profile).\r\n\r\nExamples:\r\n\r\n- ✅ `cat`\r\n- ✅ `Dog`\r\n- ✅ `_Item2`\r\n- ✅ `$money$`\r\n- ✅ `🎉`\r\n- ✅ `🚀`\r\n- ❌ `1cat`\r\n- ❌ `*dog`\n\n## Reserved identifiers\n\nAll keywords are reserved identifiers in TypeSpec. However they can still be used when escaping with wrapping with `\\`` characters.\r\n\r\n```tsp\r\nmodel `enum` {}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-enum.md\n- document_title: no-enum\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n- document_content: # libraries#azure-core#rules#no-enum.md\n\n# no-enum\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-enum\r\n```\r\n\r\nAzure services favor extensible enums to avoid breaking changes as new enum values are added. TypeSpec enums are closed.\r\nUsing a union with the base scalar(`string`, `int32`, `int64`, etc.) as a variant instead of an enum makes it extensible.\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\r\n\r\nOk. Enum is allowed for versioning purposes.\r\n\r\n```tsp\r\nenum Version {\r\n  2021_01_01: \"2021-01-01\",\r\n  2022_01_01: \"2022-01-01\",\r\n}\r\n```\n", "latency": 11.005881071090698, "response_length": 827}
{"query": "Does the general documentation for Azure's TypeSpec mention anything against using enums?", "ground_truth": "The general documentation for Azure's TypeSpec does not explicitly mention anything against using enums. However, there is an ongoing migration to support enums as unions to accommodate both Azure and non-Azure customers, suggesting a preference for using unions over enums.", "response": "Yes, the general documentation for Azure's TypeSpec explicitly advises against using enums. The rule `@azure-tools/typespec-azure-core/no-enum` states that Azure services should not use enums because TypeSpec enums are closed and do not support extensibility. Instead, it recommends using unions with a base scalar type (e.g., `string`, `int32`) to define extensible enums. This approach avoids breaking changes when new values are added. However, enums are allowed for versioning purposes.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#reference#linter.md\n- document_title: Linter usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/linter\n- document_content: # libraries#azure-core#reference#linter.md\n\n# Linter usage\n\n## Usage\n\nAdd the following in `tspconfig.yaml`:\r\n\r\n```yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-core/all\"\r\n```\n\n## RuleSets\n\nAvailable ruleSets:\r\n\r\n- `@azure-tools/typespec-azure-core/all`\r\n- `@azure-tools/typespec-azure-core/canonical-versioning`\n\n## Rules\n\n| Unions of literals should include the base scalar type to mark them as open enum.                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-enum`](/libraries/azure-core/rules/no-enum.md)                                             | Azure services should not use enums.                                                                                                                 |\r\n| `@azure-tools/typespec-azure-core/no-error-status-codes`                                                                         | Recommend using the error response defined by Azure REST API guidelines.                                                                             |\r\n| `@azure-tools/typespec-azure-core/no-explicit-routes-resource-ops`                                                               | The @route decorator should not be used on standard resource operation signatures.                                                                   |\r\n| [`@azure-tools/typespec-azure-core/non-breaking-versioning`](/libraries/azure-core/rules/non-breaking-versioning.md)             | Check that only backward compatible versioning change are done to a service.                                                                         |\r\n| [`@azure-tools/typespec-azure-core/no-generic-numeric`](/libraries/azure-core/rules/no-generic-numeric.md)                       | Don't use generic types. Use more specific types instead.                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/no-nullable`](/libraries/azure-core/rules/no-nullable.md)                                     | Use `?` for optional properties.                                                                                                                     |\r\n|\n\n| Azure specs should not be using decorators from @typespec/openapi or @azure-tools/typespec-autorest                                                  |\r\n| [`@azure-tools/typespec-azure-core/no-header-explode`](/libraries/azure-core/rules/no-header-explode.md)                         | It is recommended to serialize header parameter without explode: true                                                                                |\r\n| [`@azure-tools/typespec-azure-core/no-format`](/libraries/azure-core/rules/prevent-format.md)                                    | Azure services should not use the `@format` decorator.                                                                                               |\r\n| `@azure-tools/typespec-azure-core/no-multiple-discriminator`                                                                     | Classes should have at most one discriminator.                                                                                                       |\r\n| `@azure-tools/typespec-azure-core/no-rest-library-interfaces`                                                                    | Resource interfaces from the TypeSpec.Rest.Resource library are incompatible with Azure.Core.                                                        |\r\n| `@azure-tools/typespec-azure-core/no-unknown`                                                                                    | Azure services must not have properties of type `unknown`.                                                                                           |\r\n| [`@azure-tools/typespec-azure-core/bad-record-type`](/libraries/azure-core/rules/bad-record-type.md)                             | Identify bad record definitions.                                                                                                                     |\r\n|\n\n| Don't use generic types. Use more specific types instead.                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/no-nullable`](/libraries/azure-core/rules/no-nullable.md)                                     | Use `?` for optional properties.                                                                                                                     |\r\n| `@azure-tools/typespec-azure-core/no-offsetdatetime`                                                                             | Prefer using `utcDateTime` when representing a datetime unless an offset is necessary.                                                               |\r\n| `@azure-tools/typespec-azure-core/no-response-body`                                                                              | Ensure that the body is set correctly for the response type.                                                                                         |\r\n| `@azure-tools/typespec-azure-core/no-rpc-path-params`                                                                            | Operations defined using RpcOperation should not have path parameters.                                                                               |\r\n| `@azure-tools/typespec-azure-core/no-openapi`                                                                                    | Azure specs should not be using decorators from @typespec/openapi or @azure-tools/typespec-autorest                                                  |\r\n| [`@azure-tools/typespec-azure-core/no-header-explode`](/libraries/azure-core/rules/no-header-explode.md)                         | It is recommended to serialize header parameter without explode: true                                                                                |\r\n| [`@azure-tools/typespec-azure-core/no-format`]\n\n| Azure services should use the versioning library.                                                                                                    |\r\n| `@azure-tools/typespec-azure-core/friendly-name`                                                                                 | Ensures that @friendlyName is used as intended.                                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-private-usage`](/libraries/azure-core/rules/no-private-usage.md)                           | Verify that elements inside Private namespace are not referenced.                                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-legacy-usage`](/libraries/azure-core/rules/no-legacy-usage.md)                             | Linter warning against using elements from the Legacy namespace                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-query-explode`](/libraries/azure-core/rules/no-query-explode.md)                           | It is recommended to serialize query parameter without explode: true                                                                                 |\n\n| Name                                                                                                                             | Description                                                                                                                                          |\r\n| -------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [`@azure-tools/typespec-azure-core/operation-missing-api-version`](/libraries/azure-core/rules/operation-missing-api-version.md) | Operations need an api version parameter.                                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/auth-required`](/libraries/azure-core/rules/auth-required.md)                                 | Enforce service authentication.                                                                                                                      |\r\n| `@azure-tools/typespec-azure-core/request-body-problem`                                                                          | Request body should not be of raw array type.                                                                                                        |\r\n| `@azure-tools/typespec-azure-core/byos`                                                                                          | Use the BYOS pattern recommended for Azure Services.                                                                                                 |\r\n| [`@azure-tools/typespec-azure-core/casing-style`](/libraries/azure-core/rules/casing-style.md)                                   | Ensure proper casing style.                                                                                                                          |\r\n|\n\n| Azure services must not have properties of type `unknown`.                                                                                           |\r\n| [`@azure-tools/typespec-azure-core/bad-record-type`](/libraries/azure-core/rules/bad-record-type.md)                             | Identify bad record definitions.                                                                                                                     |\r\n| `@azure-tools/typespec-azure-core/documentation-required`                                                                        | Require documentation over enums, models, and operations.                                                                                            |\r\n| `@azure-tools/typespec-azure-core/key-visibility-required`                                                                       | Key properties need to have a Lifecycle visibility setting.                                                                                          |\r\n| `@azure-tools/typespec-azure-core/response-schema-problem`                                                                       | Warn about operations having multiple non-error response schemas.                                                                                    |\r\n| `@azure-tools/typespec-azure-core/rpc-operation-request-body`                                                                    | Warning for RPC body problems.                                                                                                                       |\r\n| [`@azure-tools/typespec-azure-core/spread-discriminated-model`](/libraries/azure-core/rules/spread-discriminated-model.md)       | Check a model with a discriminator has not been used in composition.                                                                                 |\r\n|\n\n| Use the BYOS pattern recommended for Azure Services.                                                                                                 |\r\n| [`@azure-tools/typespec-azure-core/casing-style`](/libraries/azure-core/rules/casing-style.md)                                   | Ensure proper casing style.                                                                                                                          |\r\n| `@azure-tools/typespec-azure-core/composition-over-inheritance`                                                                  | Check that if a model is used in an operation and has derived models that it has a discriminator or recommend to use composition via spread or `is`. |\r\n| `@azure-tools/typespec-azure-core/known-encoding`                                                                                | Check for supported encodings.                                                                                                                       |\r\n| `@azure-tools/typespec-azure-core/long-running-polling-operation-required`                                                       | Long-running operations should have a linked polling operation.                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-closed-literal-union`](/libraries/azure-core/rules/no-closed-literal-union.md)             | Unions of literals should include the base scalar type to mark them as open enum.                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-enum`](/libraries/azure-core/rules/no-enum.md)                                             | Azure services should not use enums.                                                                                                                 |\r\n|\n\n| Warning for RPC body problems.                                                                                                                       |\r\n| [`@azure-tools/typespec-azure-core/spread-discriminated-model`](/libraries/azure-core/rules/spread-discriminated-model.md)       | Check a model with a discriminator has not been used in composition.                                                                                 |\r\n| `@azure-tools/typespec-azure-core/use-standard-names`                                                                            | Use recommended names for operations.                                                                                                                |\r\n| [`@azure-tools/typespec-azure-core/use-standard-operations`](/libraries/azure-core/rules/use-standard-operations.md)             | Operations should be defined using a signature from the Azure.Core namespace.                                                                        |\r\n| [`@azure-tools/typespec-azure-core/no-string-discriminator`](/libraries/azure-core/rules/no-string-discriminator.md)             | Azure services discriminated models should define the discriminated property as an extensible union.                                                 |\r\n| [`@azure-tools/typespec-azure-core/require-versioned`](/libraries/azure-core/rules/require-versioned.md)                         | Azure services should use the versioning library.                                                                                                    |\r\n| `@azure-tools/typespec-azure-core/friendly-name`                                                                                 | Ensures that @friendlyName is used as intended.                                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-private-usage`]\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-enum.md\n- document_title: no-enum\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n- document_content: # libraries#azure-core#rules#no-enum.md\n\n# no-enum\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-enum\r\n```\r\n\r\nAzure services favor extensible enums to avoid breaking changes as new enum values are added. TypeSpec enums are closed.\r\nUsing a union with the base scalar(`string`, `int32`, `int64`, etc.) as a variant instead of an enum makes it extensible.\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\r\n\r\nOk. Enum is allowed for versioning purposes.\r\n\r\n```tsp\r\nenum Version {\r\n  2021_01_01: \"2021-01-01\",\r\n  2022_01_01: \"2022-01-01\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#enums.md\n- document_title: Enums\n- document_link: https://typespec.io/docs/language-basics/enums\n- document_content: # language-basics#enums.md\n\n# Enums\n\nEnums, short for enumerations, provide a way for developers to define a collection of named constants. They are useful for documenting the purpose of the code or for establishing a set of distinct scenarios. Enums can be either numeric or string-based. For other data types, consider using [unions](./unions.md).\n\n## The basics\n\nYou can declare enums using the `enum` keyword. The members of an enum are separated by commas `,` and can be either [`identifier`](./identifiers.md) TypeSpecs or `string literal`s.\r\n\r\n```typespec\r\nenum Direction {\r\n  North,\r\n  East,\r\n  South,\r\n  West,\r\n}\r\n```\r\n\r\nIn the above example, we haven't defined the representation of the constants. Depending on the context, enums might be handled differently.\n\n## Assigning values to enums\n\nYou can assign custom values to enum members using the `:` operator.\r\n\r\n```typespec\r\nenum Direction {\r\n  North: \"north\",\r\n  East: \"east\",\r\n  South: \"south\",\r\n  West: \"west\",\r\n}\r\n```\r\n\r\nThese values can also be integers.\r\n\r\n```typespec\r\nenum Foo {\r\n  One: 1,\r\n  Ten: 10,\r\n  Hundred: 100,\r\n  Thousand: 1000,\r\n}\r\n```\r\n\r\nOr even floating-point numbers.\r\n\r\n```typespec\r\nenum Hour {\r\n  Zero: 0,\r\n  Quarter: 0.25,\r\n  Half: 0.5,\r\n  ThreeQuarter: 0.75,\r\n}\r\n```\n\n## Combining enums\n\nYou can combine enums using the spread `...` pattern. This copies all the members from the source enum to the target enum, but it doesn't establish any reference between the source and target enums.\r\n\r\n```typespec\r\nenum DirectionExt {\r\n  ...Direction,\r\n  `North East`,\r\n  `North West`,\r\n  `South East`,\r\n  `South West`,\r\n}\r\n```\n\n## How to reference enum members\n\nYou can reference enum members using the `.` operator for identifiers.\r\n\r\n```typespec\r\nalias North = Direction.North;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the (ℹ) bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n", "latency": 10.550630807876587, "response_length": 490}
{"query": "Can the API version be placed inside the @server section of TypeSpec to remain in x-ms-parameterized-host?", "ground_truth": "No, the API version cannot be placed inside the @server section of TypeSpec to remain in x-ms-parameterized-host without causing issues. Moving the API version from x-ms-parameterized-host to paths is necessary when migrating from Swagger to TypeSpec, as this change is recognized by the breaking changes tool. However, this migration may lead to breaking change issues for every path, which ideally should be verified by tools rather than manual checking.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step09.md\n- document_title: 9. Customizing operations with traits\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step09\n- document_content: # getstarted#azure-core#step09.md\n\n# 9. Customizing operations with traits\n\nFor all standard lifecycle operations you can customize the operation parameters and response body by passing a special model type to the `Traits` parameter of the operation template, typically the second parameter of the operation template. You can also customize the whole set of resource operations by passing traits to the `ResourceOperations` interface.\r\n\r\nYou can combine multiple traits using the model intersection operator `&`. Here's an example of defining the `ServiceTraits` with `SupportsRepeatableRequests`, `SupportsConditionalRequests` and `SupportsClientRequestId`. These are then passed into the `Azure.Core.ResourceOperations` template:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nTraits can be applied simultaneously at both the interface and operation level, they will be composed together when your operation is defined.\r\n\r\nFor example, if you wanted to add standard list operation query parameters to the `listWidgets` operation, you could use the `ListQueryParametersTrait`:\r\n\r\n```typespec\r\n/** List Widget resources */\r\nop listWidgets is Operations.ResourceList<\r\n  Widget,\r\n  ListQueryParametersTrait<StandardListQueryParameters & SelectQueryParameter>\r\n>;\r\n```\n\n## Useful trait types\n\nThe following trait types can be used for typical operation customization patterns:\n\n### `QueryParametersTrait<TParams, Contexts>`\n\nThis trait adds query parameters to operation signatures. It accepts a model type containing the query parameters that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is Operations.ResourceRead<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@query` or an error will be raised.\r\n\r\nThe `Contexts` parameter is configured to apply the query parameters to all operations by default.\r\n\r\nTo constrain the types of operations that these query parameters will apply to, pass one ore more of the following values:\r\n\r\n- **TraitContext.Read**: Applies to read operations\r\n- **TraitContext.Create**: Applies to create operations\r\n- **TraitContext.Update**: Applies to update operations\r\n- **TraitContext.Delete**: Applies to delete operations\r\n- **TraitContext.List**: Applies to list operations\r\n- **TraitContext.Action**: Applies to custom action operations\r\n\r\nHere is an example of applying query parameters to `Read` and `List` operations:\r\n\r\n```typespec\r\nalias MyQueryParams = QueryParametersTrait<\r\n  {\r\n    @query foo: string;\r\n  },\r\n  TraitContext.Read | TraitContext.List\r\n>;\r\n\r\n// This will have a `foo` parameter added\r\nop getWidget is Operations.ResourceRead<Widget, MyQueryParams>;\r\n\r\n// This will not get the `foo` parameter because it doesn't match the contexts\r\nop deleteWidget is Operations.ResourceDelete<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\n\n### `ListQueryParametersTrait<TParams>`\n\nThis is a helper trait that specialized `QueryParametersTrait` to the `TraitContext.List` context. For example:\r\n\r\n```typespec\r\nalias MyListQueryParams = ListQueryParametersTrait<{\r\n  @query foo: string;\r\n}>;\r\n\r\n// Will get the `foo` parameter\r\nop listWidgets is Operations.ResourceList<Widget, MyListQueryParams>;\r\n\r\n// Will not get the `foo` parameter\r\nop deleteWidget is Operations.ResourceDelete<Widget, MyListQueryParams>;\r\n```\n\n### `RequestHeadersTrait<TParams, Contexts>`\n\nThis trait adds request headers to operation signatures. It accepts a model type containing the request headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n### `ResponseHeadersTrait<TParams, Contexts>`\n\nThis trait adds response headers to operation signatures. It accepts a model type containing the response headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  ResponseHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n## Applying traits to all resource operations\n\nIf you would like to apply the same traits to all resource operations, you can do so by adding them to the traits object for your instance of the `ResourceOperations` interface. Here's an example of adding a request header called `foo` to all resource operations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n\r\nop deleteWidget is Operations.ResourceDelete<Widget>;\r\n```\r\n\r\nThis defines `deleteWidget` by using the `ResourceDelete` template defined inside of your customized `Operations` interface.\r\n\r\n**IMPORTANT NOTE:** The `ResourceOperations` interface requires that an explicit set of traits be included to describe whether certain Azure service features are supported.\r\n\r\nHere is the list of the required traits with the names of the trait models to enable and disable those features:\r\n\r\n- **RepeatableRequests**: `SupportsRepeatableRequests` and `NoRepeatableRequests`\r\n- **ConditionalRequests**: `SupportsConditionalRequests` and `NoConditionalRequests`\r\n- **ClientRequestId**: `SupportsClientRequestId` and `NoClientRequestId`\n\n## Customizing the API version parameter\n\nYou can use the `VersionParameterTrait` to customize the API version parameter for resource operations, either at the level of interface or individual operation. To do this, use the `TraitOverride` type to override the existing `api-version` query parameter:\r\n\r\n```typespec\r\n/** The ApiVersion path parameter. */\r\nmodel ApiVersionPathParameter {\r\n  /** The API version to use for this operation. */\r\n  @segment(\"api\")\r\n  @path(\"api-version\")\r\n  apiVersion: string;\r\n}\r\n\r\nop deleteWidget is ResourceDelete<\r\n  Widget,\r\n  TraitOverride<VersionParameterTrait<ApiVersionPathParameter>>\r\n>;\r\n```\r\n\r\nUsing the `TraitOverride` modifier with the `VersionParameterTrait<ApiVersionPathParameter>` causes any existing `VersionParameterTrait` instances in the operation signature to be overridden by the one you have supplied.\r\n\r\nThis will result in an operation that has the route path `/api/{apiVersion}/widgets/{widgetName}` while also removing the old `api-version` query parameter from the operation signature.\n\n## Versioning the use of traits\n\nIt is possible that a service will begin to support a particular feature or trait in a later version. There are two ways to express that a trait is being added in a later service version:\n\n### Using the `TVersionAdded` parameter of some trait types\n\n> **NOTE:** Versioning of Azure Core service specifications is covered in more detail on [this page](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10).\r\n\r\nSome standard trait types accept an optional `TVersionAdded` parameter which enables you to specify the service version enum representing the version where support for this trait is added:\r\n\r\n- `SupportsClientRequestId`\r\n- `SupportsRepeatableRequests`\r\n- `SupportsConditionalRequests`\r\n\r\nHere is an example of adding support for repeatable requests in a later service version:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n\n### Define a custom trait and add the `@traitAdded` decorator\n\nBuilding on the previous example, we can add a custom header trait at a later service version using the `@traitAdded` decorator:\r\n\r\n```typespec\r\n/** A custom trait added at a later service version. */\r\n@traitAdded(Versions.v2022_11_30)\r\nmodel CustomRequestHeadersTrait\r\n  is RequestHeadersTrait<{\r\n    @TypeSpec.Http.header foo: string;\r\n  }>;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  CustomRequestHeadersTrait;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n", "latency": 5.152552127838135, "response_length": 79}
{"query": "Is there a way to exclude the API version in parameters of operations?", "ground_truth": "Excluding the API version in parameters of operations directly is not straightforward. While there is a method to override the API version parameter using traits in TypeSpec, this approach might not be fully suitable for all services, especially brownfield services. Additionally, placing the API version in the @server section could result in the API version appearing twice, which is not desirable. Therefore, a clear method to exclude the API version from operation parameters without causing duplication or visibility issues has not been identified.", "response": "Yes, there are ways to exclude the API version parameter in operations. By default, TypeSpec requires an `apiVersion` parameter for operations, as indicated by the `@azure-tools/typespec-azure-core/operation-missing-api-version` rule. However, you can override this behavior using the `@isApiVersion` decorator to explicitly mark or unmark a parameter as an API version parameter. Additionally, you can use the `VersionParameterTrait` to customize or remove the default `api-version` query parameter.\n\nFor example, if you want to exclude the `api-version` parameter, you can define a custom trait or override the default behavior:\n\n```typespec\n/** The ApiVersion path parameter. */\nmodel ApiVersionPathParameter {\n  /** The API version to use for this operation. */\n  @segment(\"api\")\n  @path(\"api-version\")\n  apiVersion: string;\n}\n\nop deleteWidget is ResourceDelete<\n  Widget,\n  TraitOverride<VersionParameterTrait<ApiVersionPathParameter>>\n>;\n```\n\nThis approach removes the default `api-version` query parameter and replaces it with a custom path parameter. Alternatively, you can use the `@apiVersion` decorator to explicitly exclude a parameter from being treated as an API version parameter:\n\n```typespec\nnamespace Contoso;\n\nop test(\n  @apiVersion(false)\n  @header(\"x-ms-version\")\n  version: string,\n): void;\n```\n\nIn this example, the `version` parameter is explicitly marked as not being an API version parameter.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#operation-missing-api-version.md\n- document_title: operation-missing-api-version\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/operation-missing-api-version\n- document_content: # libraries#azure-core#rules#operation-missing-api-version.md\n\n# operation-missing-api-version\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/operation-missing-api-version\r\n```\r\n\r\nEnsure all operations have an `apiVersion` parameter.\r\n\r\n:::caution\r\nSeeing this error is also a sign that you are not using the Azure Standard templates. First double check why you cannot use them.\r\n:::\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nop createPet(pet: Pet): void;\r\n```\n\n### ✅ Correct\n\n```tsp\r\nop createPet(pet: Pet, ...Azure.Core.Foundations.ApiVersionParameter): void;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step09.md\n- document_title: 9. Customizing operations with traits\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step09\n- document_content: # getstarted#azure-core#step09.md\n\n# 9. Customizing operations with traits\n\nFor all standard lifecycle operations you can customize the operation parameters and response body by passing a special model type to the `Traits` parameter of the operation template, typically the second parameter of the operation template. You can also customize the whole set of resource operations by passing traits to the `ResourceOperations` interface.\r\n\r\nYou can combine multiple traits using the model intersection operator `&`. Here's an example of defining the `ServiceTraits` with `SupportsRepeatableRequests`, `SupportsConditionalRequests` and `SupportsClientRequestId`. These are then passed into the `Azure.Core.ResourceOperations` template:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nTraits can be applied simultaneously at both the interface and operation level, they will be composed together when your operation is defined.\r\n\r\nFor example, if you wanted to add standard list operation query parameters to the `listWidgets` operation, you could use the `ListQueryParametersTrait`:\r\n\r\n```typespec\r\n/** List Widget resources */\r\nop listWidgets is Operations.ResourceList<\r\n  Widget,\r\n  ListQueryParametersTrait<StandardListQueryParameters & SelectQueryParameter>\r\n>;\r\n```\n\n## Useful trait types\n\nThe following trait types can be used for typical operation customization patterns:\n\n### `QueryParametersTrait<TParams, Contexts>`\n\nThis trait adds query parameters to operation signatures. It accepts a model type containing the query parameters that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is Operations.ResourceRead<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@query` or an error will be raised.\r\n\r\nThe `Contexts` parameter is configured to apply the query parameters to all operations by default.\r\n\r\nTo constrain the types of operations that these query parameters will apply to, pass one ore more of the following values:\r\n\r\n- **TraitContext.Read**: Applies to read operations\r\n- **TraitContext.Create**: Applies to create operations\r\n- **TraitContext.Update**: Applies to update operations\r\n- **TraitContext.Delete**: Applies to delete operations\r\n- **TraitContext.List**: Applies to list operations\r\n- **TraitContext.Action**: Applies to custom action operations\r\n\r\nHere is an example of applying query parameters to `Read` and `List` operations:\r\n\r\n```typespec\r\nalias MyQueryParams = QueryParametersTrait<\r\n  {\r\n    @query foo: string;\r\n  },\r\n  TraitContext.Read | TraitContext.List\r\n>;\r\n\r\n// This will have a `foo` parameter added\r\nop getWidget is Operations.ResourceRead<Widget, MyQueryParams>;\r\n\r\n// This will not get the `foo` parameter because it doesn't match the contexts\r\nop deleteWidget is Operations.ResourceDelete<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\n\n### `ListQueryParametersTrait<TParams>`\n\nThis is a helper trait that specialized `QueryParametersTrait` to the `TraitContext.List` context. For example:\r\n\r\n```typespec\r\nalias MyListQueryParams = ListQueryParametersTrait<{\r\n  @query foo: string;\r\n}>;\r\n\r\n// Will get the `foo` parameter\r\nop listWidgets is Operations.ResourceList<Widget, MyListQueryParams>;\r\n\r\n// Will not get the `foo` parameter\r\nop deleteWidget is Operations.ResourceDelete<Widget, MyListQueryParams>;\r\n```\n\n### `RequestHeadersTrait<TParams, Contexts>`\n\nThis trait adds request headers to operation signatures. It accepts a model type containing the request headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n### `ResponseHeadersTrait<TParams, Contexts>`\n\nThis trait adds response headers to operation signatures. It accepts a model type containing the response headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  ResponseHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n## Applying traits to all resource operations\n\nIf you would like to apply the same traits to all resource operations, you can do so by adding them to the traits object for your instance of the `ResourceOperations` interface. Here's an example of adding a request header called `foo` to all resource operations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n\r\nop deleteWidget is Operations.ResourceDelete<Widget>;\r\n```\r\n\r\nThis defines `deleteWidget` by using the `ResourceDelete` template defined inside of your customized `Operations` interface.\r\n\r\n**IMPORTANT NOTE:** The `ResourceOperations` interface requires that an explicit set of traits be included to describe whether certain Azure service features are supported.\r\n\r\nHere is the list of the required traits with the names of the trait models to enable and disable those features:\r\n\r\n- **RepeatableRequests**: `SupportsRepeatableRequests` and `NoRepeatableRequests`\r\n- **ConditionalRequests**: `SupportsConditionalRequests` and `NoConditionalRequests`\r\n- **ClientRequestId**: `SupportsClientRequestId` and `NoClientRequestId`\n\n## Customizing the API version parameter\n\nYou can use the `VersionParameterTrait` to customize the API version parameter for resource operations, either at the level of interface or individual operation. To do this, use the `TraitOverride` type to override the existing `api-version` query parameter:\r\n\r\n```typespec\r\n/** The ApiVersion path parameter. */\r\nmodel ApiVersionPathParameter {\r\n  /** The API version to use for this operation. */\r\n  @segment(\"api\")\r\n  @path(\"api-version\")\r\n  apiVersion: string;\r\n}\r\n\r\nop deleteWidget is ResourceDelete<\r\n  Widget,\r\n  TraitOverride<VersionParameterTrait<ApiVersionPathParameter>>\r\n>;\r\n```\r\n\r\nUsing the `TraitOverride` modifier with the `VersionParameterTrait<ApiVersionPathParameter>` causes any existing `VersionParameterTrait` instances in the operation signature to be overridden by the one you have supplied.\r\n\r\nThis will result in an operation that has the route path `/api/{apiVersion}/widgets/{widgetName}` while also removing the old `api-version` query parameter from the operation signature.\n\n## Versioning the use of traits\n\nIt is possible that a service will begin to support a particular feature or trait in a later version. There are two ways to express that a trait is being added in a later service version:\n\n### Using the `TVersionAdded` parameter of some trait types\n\n> **NOTE:** Versioning of Azure Core service specifications is covered in more detail on [this page](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10).\r\n\r\nSome standard trait types accept an optional `TVersionAdded` parameter which enables you to specify the service version enum representing the version where support for this trait is added:\r\n\r\n- `SupportsClientRequestId`\r\n- `SupportsRepeatableRequests`\r\n- `SupportsConditionalRequests`\r\n\r\nHere is an example of adding support for repeatable requests in a later service version:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n\n### Define a custom trait and add the `@traitAdded` decorator\n\nBuilding on the previous example, we can add a custom header trait at a later service version using the `@traitAdded` decorator:\r\n\r\n```typespec\r\n/** A custom trait added at a later service version. */\r\n@traitAdded(Versions.v2022_11_30)\r\nmodel CustomRequestHeadersTrait\r\n  is RequestHeadersTrait<{\r\n    @TypeSpec.Http.header foo: string;\r\n  }>;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  CustomRequestHeadersTrait;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmResourcePatchSync<Resource, ResourceProperties>;`  |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                         |\r\n| -------------------- | ----------- | -------- | --------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                             |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`   |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmResourcePatchSync<Resource, ResourceProperties>;` |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                    |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`            |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason fro choosing another PATCH operation.\r\n\r\n| Operation Description             | TypeSpec                                                            |\r\n| --------------------------------- | ------------------------------------------------------------------- |\r\n| Sync Updateable Properties PATCH  | `update is ArmResourcePatchSync<ResourceType, ResourceProperties>`  |\r\n| Async Updateable Properties PATCH | `update is ArmResourcePatchAsync<ResourceType, ResourceProperties>` |\r\n| Sync TagsOnly PATCH               | `update is ArmTagsPatchSync<ResourceType>`                          |\r\n| Async TagsOnly PATCH              | `update is ArmTagsPatchAsync<ResourceType>`                         |\r\n| Sync Custom PATCH                 | `update is ArmCustomPatchSync<ResourceType, PatchRequest>`          |\r\n| Async Custom PATCH                | `update is ArmCustomPatchAsync<ResourceType, PatchRequest>`         |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n", "latency": 17.790688276290894, "response_length": 1418}
{"query": "How can I exclude some TypeSpec part from the validation?", "ground_truth": "To exclude some TypeSpec parts from validation, you cannot directly suppress the 'TypeSpec Validation' itself. However, you can address specific TypeSpec Linter errors by either fixing them or using suppression mechanisms for the sub-checks like 'TypeSpec Linter'. Documentation on how to suppress violations in source is available, and for certain cases, it might be possible to exclude specific versions from validation. It's crucial to ensure that public-facing APIs and internal APIs are kept consistent without exposing internal APIs unnecessarily. Tools and mechanisms are available for deriving internal API specifications from public-facing APIs, ensuring a single source of truth.", "response": "To exclude certain parts of a TypeSpec model from validation, you can use the `@visibility` decorator to control the visibility of specific properties. By setting the visibility to `none`, you can effectively exclude those properties from being validated in certain contexts. Additionally, you can use the `MetadataInfo` API to programmatically determine which properties are included in the payload or validation process based on visibility settings.\n\nFor example:\n\n```typespec\nmodel Example {\n  @visibility(\"none\")\n  excludedProperty: string;\n\n  includedProperty: int32;\n}\n```\n\nIn this case, `excludedProperty` will not be included in validation or payloads for operations unless explicitly handled. If you are working with emitters or custom validation logic, you can use the `MetadataInfo.isPayloadProperty` API to check if a property should be included in the payload or validation for a given visibility context.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#prevent-format.md\n- document_title: prevent-format\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/prevent-format\n- document_content: # libraries#azure-core#rules#prevent-format.md\n\n# prevent-format\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/prevent-format\r\n```\r\n\r\nUsing the `@format` decorator is disallowed. While in OpenAPI `format:` was used to both represent a known string format and a more precise type, in TypeSpec `@format` is only meant to represent a known pattern for a string. This means that using `@format` would result in a `string` type with some validation.\n\n## Mapping of format to types\n\n| Format   | Type                               |\r\n| -------- | ---------------------------------- |\r\n| `int32`  | `int32`                            |\r\n| `uri`    | `url`                              |\r\n| `url`    | `url`                              |\r\n| `uuid`   | `Azure.Core.uuid`                  |\r\n| `eTag`   | `Azure.Core.eTag`                  |\r\n| `arm-id` | `Azure.Core.armResourceIdentifier` |\r\n| `ipv4`   | `Azure.Core.ipV4Address`           |\r\n| `ipv6`   | `Azure.Core.ipV6Address`           |\r\n| `ipv6`   | `Azure.Core.azureLocation`         |\n\n## Examples\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @format(\"uuid\")\r\n  id: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  id: Azure.Core.uuid;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#linters.md\n- document_title: Linters\n- document_link: https://typespec.io/docs/extending-typespec/linters\n- document_content: # extending-typespec#linters.md\n\n# Linters\n\n## Linter versus `onValidate`\n\nA TypeSpec library can provide an `$onValidate` hook, which can be used to validate whether the TypeSpec program is valid according to your library's rules.\r\n\r\nOn the other hand, a linter might provide optional validation. The program could be correct, but there might be room for improvements. For instance, a linter might require documentation on every type. While this isn't necessary to represent the TypeSpec program, it could enhance the end user experience. Linters need to be explicitly enabled, whereas `$onValidate` will run automatically if that library is imported.\n\n## Creating a linter\n\nYou can find examples in `packages/best-practices`.\n\n### 1. Define rules\n\n```ts\r\nimport {  createLinterRule } from \"@typespec/compiler\";\r\nimport { reportDiagnostic } from \"../lib.js\";\r\n\r\nexport const requiredDocRule = createLinterRule({\r\n  name: \"no-model-doc\",\r\n  severity: \"warning\",\r\n  // Short description of what this linter rule does. To be used for generated summary of a linter.\r\n  description: \"Enforce documentation on models.\",\r\n  messages: {\r\n    default: `Must be documented.`,\r\n    // Different messages can be provided\r\n    models: `Models must be documented.`,\r\n\r\n    // Message can be parameterized\r\n    enums: paramMessage`Enum ${\"enumName\"} must be documented.`,\r\n  },\r\n  create(context) {\r\n    return {\r\n      operation: (op) => {\r\n        if (!getDoc(context.program, op)) {\r\n          context.reportDiagnostic({\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n      model: (model) => {\r\n        if (!getDoc(context.program, model)) {\r\n          context.reportDiagnostic({\r\n            messageId: \"models\",\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n      enums: (type) => {\r\n        if (!getDoc(context.program, type)) {\r\n          context.reportDiagnostic({\r\n            messageId: \"enums\",\r\n            format: {enumName: type.name}\r\n            target: model,\r\n          });\r\n        }\r\n      },\r\n    };\r\n  },\r\n});\r\n```\r\n\r\n#### Provide a codefix\r\n\r\n[See codefixes](./codefixes.md) for more details on how codefixes work in the TypeSpec ecosystem.\r\n\r\nIn the same way you can provide a codefix on any reported diagnostic, you can pass codefixes to the `reportDiagnostic` function.\r\n\r\n```ts\r\ncontext.reportDiagnostic({\r\n  messageId: \"models\",\r\n  target: model,\r\n  codefixes: [\r\n    defineCodeFix({\r\n      id: \"add-model-suffix\",\r\n      label: \"Add 'Model' suffix to model name\",\r\n      fix: (program) => {\r\n        program.update(model, {\r\n          name: `${model.name}Model`,\r\n        });\r\n      },\r\n    }),\r\n  ],\r\n});\r\n```\r\n\r\n#### Things to avoid\n\nIn the same way you can provide a codefix on any reported diagnostic, you can pass codefixes to the `reportDiagnostic` function.\r\n\r\n```ts\r\ncontext.reportDiagnostic({\r\n  messageId: \"models\",\r\n  target: model,\r\n  codefixes: [\r\n    defineCodeFix({\r\n      id: \"add-model-suffix\",\r\n      label: \"Add 'Model' suffix to model name\",\r\n      fix: (program) => {\r\n        program.update(model, {\r\n          name: `${model.name}Model`,\r\n        });\r\n      },\r\n    }),\r\n  ],\r\n});\r\n```\r\n\r\n#### Things to avoid\r\n\r\n- ❌ Do not call `program.reportDiagnostic` or your library `reportDiagnostic` helper directly in a linter rule\r\n\r\n```ts\r\n// ❌ Bad\r\nprogram.reportDiagnostic({\r\n  code: \"other-code\",\r\n  target,\r\n});\r\n// ❌ Bad\r\nreportDiagnostic(program, {\r\n  code: \"other-code\",\r\n  target,\r\n});\r\n\r\n// ✅ Good\r\ncontext.reportDiagnostic({\r\n  target,\r\n});\r\n```\n\n### Register the rules\n\n<!-- cspell:disable-next-line -->\r\n\r\nExport a `$linter` variable from your library entrypoint:\r\n\r\n```ts title=\"index.ts\"\r\nexport { $linter } from \"./linter.js\";\r\n```\r\n\r\n```ts title=\"linter.ts\"\r\nimport { defineLinter } from \"@typespec/compiler\";\r\n// Import the rule defined previously\r\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\r\n\r\nexport const $linter = defineLinter({\r\n  // Include all the rules your linter is defining here.\r\n  rules: [requiredDocRule],\r\n\r\n  // Optionally a linter can provide a set of rulesets\r\n  ruleSets: {\r\n    recommended: {\r\n      // (optional) A ruleset takes a map of rules to explicitly enable\r\n      enable: { [`@typespec/my-linter/${requiredDocRule.name}`]: true },\r\n\r\n      // (optional) A rule set can extend another rule set\r\n      extends: [\"@typespec/best-practices/recommended\"],\r\n\r\n      // (optional) A rule set can disable a rule enabled in a ruleset it extended.\r\n      disable: {\r\n        \"`@typespec/best-practices/no-a\": \"This doesn't apply in this ruleset.\",\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\nWhen referencing a rule or ruleset (in `enable`, `extends`, `disable`), you must use the rule or rule set id, which is in this format: `<libraryName>/<ruleName>`.\n\n## Testing a linter\n\nTo test a linter rule, a rule tester is provided, allowing you to test a specific rule without enabling the others.\r\n\r\nFirst, you'll want to create an instance of the rule tester using `createLinterRuleTester`, passing it the rule that is being tested. You can then provide different tests to check whether the rule passes or fails.\r\n\r\n```ts\r\nimport { RuleTester, createLinterRuleTester, createTestRunner } from \"@typespec/compiler/testing\";\r\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\r\n\r\ndescribe(\"required-doc rule\", () => {\r\n  let ruleTester: RuleTester;\r\n\r\n  beforeEach(() => {\r\n    const runner = createTestRunner();\r\n    ruleTester = createLinterRuleTester(runner, requiredDocRule, \"@typespec/my-linter\");\r\n  });\r\n\r\n  it(\"emit diagnostics when using model named foo\", async () => {\r\n    await ruleTester.expect(`model Foo {}`).toEmitDiagnostics({\r\n      code: \"@typespec/my-linter/no-foo-model\",\r\n      message: \"Cannot name a model with 'Foo'\",\r\n    });\r\n  });\r\n\r\n  it(\"should be valid to use other names\", async () => {\r\n    await ruleTester.expect(`model Bar {}`).toBeValid();\r\n  });\r\n});\r\n```\n\n### Testing linter with codefixes\n\nThe linter rule tester provides an API to easily test a codefix. This is a different approach from the standalone codefix tester, which is more targeted at testing codefixes in isolation.\r\n\r\nThis can be done by calling `applyCodeFix` with the fix id. It will expect a single diagnostic to be emitted with a codefix with the given id. Then, call `toEqual` with the expected code after the codefix is applied.\r\n\r\n:::note\r\nWhen using multi-line strings (with `\\``) in TypeScript, there is no de-indenting done, so you will need to make sure the input and expected result are aligned to the left.\r\n:::\r\n\r\n```ts\r\nawait tester\r\n  .expect(\r\n    `        \r\n    model Foo {}\r\n    `,\r\n  )\r\n  .applyCodeFix(\"add-model-suffix\").toEqual(`\r\n    model FooModel {}\r\n  `);\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#values.md\n- document_title: Values\n- document_link: https://typespec.io/docs/language-basics/values\n- document_content: # language-basics#values.md\n\n# Values\n\nTypeSpec can define values in addition to types. Values are useful in an API description to define default values for types or provide example values. They are also useful when passing data to decorators, and for template parameters that are ultimately passed to decorators or used as default values.\r\n\r\nValues cannot be used as types, and types cannot be used as values, they are completely separate. However, string, number, boolean, and null literals can be either a type or a value depending on context (see also [scalar literals](#scalar-literals)). Additionally, union and enum member references may produce a type or a value depending on context (see also [enum member &amp; union variant references](#enum-member--union-variant-references)).\n\n## Value kinds\n\nThere are four kinds of values: objects, arrays, scalars, and null. These values can be created with object values, array values, scalar values and initializers, and the null literal respectively. Additionally, values can result from referencing enum members and union variants.\n\n### Object values\n\nObject values use the syntax `#{}` and can define any number of properties. For example:\r\n\r\n```typespec\r\nconst point = #{ x: 0, y: 0 };\r\n```\r\n\r\nThe object value's properties must refer to other values. It is an error to reference a type.\r\n\r\n```typespec\r\nconst example = #{\r\n  prop1: #{ nested: true }, // ok\r\n  prop2: {\r\n    nested: true,\r\n  }, // error: values can't reference a type\r\n  prop3: string, // error: values can't reference a type\r\n};\r\n```\n\n### Array values\n\nArray values use the syntax `#[]` and can define any number of items. For example:\r\n\r\n```typespec\r\nconst points = #[#{ x: 0, y: 0 }, #{ x: 1, y: 1 }];\r\n```\r\n\r\nAs with object values, array values cannot contain types.\r\n\r\nIf an array type defines a minimum and maximum size using the `@minValue` and `@maxValue` decorators, the compiler will validate that the array value has the appropriate number of items. For example:\r\n\r\n```typespec\r\n/** Can have at most 2 tags */\r\n@maxItems(2)\r\nmodel Tags is Array<string>;\r\n\r\nconst exampleTags1: Tags = #[\"TypeSpec\", \"JSON\"]; // ok\r\nconst exampleTags2: Tags = #[\"TypeSpec\", \"JSON\", \"OpenAPI\"]; // error\r\n```\n\n### Scalar values\n\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string. Named scalars can be declared like so:\r\n\r\n```typespec\r\nscalar ipv4 extends string {\r\n  init fromInt(value: uint32);\r\n}\r\n\r\nconst ip = ipv4.fromInt(2341230);\r\n```\r\n\r\n#### Null values\r\n\r\nNull values are created with the `null` literal.\r\n\r\n```typespec\r\nconst value: string | null = null;\r\n```\r\n\r\nThe `null` value, like the `null` type, doesn't have any special behavior in the TypeSpec language. It is just the value `null` like that in JSON.\n\nThere are two ways to create scalar values: with a literal syntax like `\"string value\"`, and with a scalar initializer like `utcDateTime.fromISO(\"2020-12-01T12:00:00Z\")`.\r\n\r\n#### Scalar literals\r\n\r\nThe literal syntax for strings, numerics, booleans and null can evaluate to either a type or a value depending on the surrounding context of the literal. When the literal is in _type context_ (a model property type, operation return type, alias definition, etc.) the literal becomes a literal type. When the literal is in _value context_ (a default value, property of an object value, const definition, etc.), the literal becomes a value. When the literal is in an _ambiguous context_ (e.g. an argument to a template or decorator that can accept either a type or a value) the literal becomes a value. The `typeof` operator can be used to convert the literal to a type in such ambiguous contexts.\r\n\r\n```typespec\r\n// Sample decorator signatures. They have no backing implementation and shown here for demonstration purposes.\r\nextern dec setNumberValue(target: unknown, color: valueof numeric);\r\nextern dec setNumberType(target: unknown, color: numeric);\r\nextern dec setNumberTypeOrValue(target: unknown, color: numeric | (valueof numeric));\r\n\r\n@setNumberValue(123) // Passes the scalar value `numeric(123)`.\r\n@setNumberType(123) // Passes the numeric literal type 123.\r\n@setNumberTypeOrValue(123) // passes the scalar value `numeric(123)`.\r\nmodel A {}\r\n```\r\n\r\n#### Scalar initializers\r\n\r\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string.\n\n## Const declarations\n\nConst declarations allow storing values in a variable for later reference. Const declarations have an optional type annotation. When the type annotation is absent, the type is inferred from the value by constructing an exact type from the initializer.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n//      ^-- type: string\r\n\r\nconst oneValue = 1;\r\n//      ^-- type: 1\r\n\r\nconst objectValue = #{ x: 0, y: 0 };\r\n//      ^-- type: { x: 0, y: 0 }\r\n```\n\n## The `typeof` operator\n\nThe `typeof` operator returns the declared or inferred type of a value reference. Note that the actual value being stored by the referenced variable may be more specific than the declared type of the value. For example, if a const is declared with a union type, the value will only ever store one specific variant at a time, but typeof will give you the declared union type.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n// typeof stringValue returns `string`.\r\n\r\nconst oneValue = 1;\r\n// typeof oneValue returns `1`\r\n\r\nconst stringOrOneValue: string | 1 = 1;\r\n// typeof stringOrOneValue returns `string | 1`\r\n```\n\n## Validation\n\nTypeSpec will validate values against built-in validation decorators like `@minLength` and `@maxValue`.\r\n\r\n```typespec\r\n@maxLength(3)\r\nscalar shortString extends string;\r\n\r\nconst s1: shortString = \"abc\"; // ok\r\nconst s2: shortString = \"abcd\"; // error:\r\n\r\nmodel Entity {\r\n  a: shortString;\r\n}\r\n\r\nconst e1: Entity = #{ a: \"abcd\" }; // error\r\n```\n\n## Enum member &amp; union variant references\n\nReferences to enum members and union variants can be either types or values and follow the same rules as scalar literals. When an enum member reference is in _type context_, the reference becomes an enum member type. When in _value context_ or _ambiguous context_ the reference becomes the enum member's value.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorMember(target: unknown, color: Reflection.EnumMember);\r\n\r\nenum Color {\r\n  red,\r\n  green,\r\n  blue,\r\n}\r\n\r\n@setColorValue(Color.red) // same as passing the literal \"red\"\r\n@setColorMember(Color.red) // passes the enum member Color.red\r\nmodel A {}\r\n```\r\n\r\nWhen a union variant reference is in _type context_, the reference becomes the type of the union variant. When in _value context_ or _ambiguous context_ the reference becomes the value of the union variant. It is an error to refer to a union variant whose type is not a literal type.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorType(target: unknown, color: string);\r\n\r\nunion Color {\r\n  red: \"red\",\r\n  green: \"green\",\r\n  blue: \"blue\",\r\n  other: string,\r\n}\r\n\r\n@setColorValue(Color.red) // passes the scalar value `string(\"red\")`\r\n@setColorValue(Color.other) // error, trying to pass a type as a value.\r\n@setColorType(Color.red) // passes the string literal type `\"red\"`\r\nmodel A {}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitter-metadata-handling.md\n- document_title: Managing metadata and visibility in REST API emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitter-metadata-handling\n- document_content: # extending-typespec#emitter-metadata-handling.md\n\n# Managing metadata and visibility in REST API emitters\n\nEnsuring consistent handling of [automatic visibility](../libraries/http/operations.md#automatic-visibility) and [metadata](../libraries/http/operations.md#metadata) by all REST API emitters is crucial. To understand how these features work, please refer to the TypeSpec-author documentation. This guide will help you integrate these features into your own emitter correctly.\r\n\r\nThe standard `/rest` library offers a JavaScript API for emitters to interpret APIs written using its decorators. We will focus on the APIs that are specifically relevant to these features.\r\n\r\nWhen we say that emitters should handle things consistently, we mean they should agree on how data is transmitted and received. A TypeSpec _specification_ should serve as a reliable reference for these details. However, emitters can still _abstract_ things above this level and make different choices. For instance, the OpenAPI emitter may split a single TypeSpec model into multiple suffixed schemas like `UserCreate` and `UserUpdate`, while a client SDK emitter might emit a single `User` class that can be serialized to a request or deserialized from a response with different fields present in different situations. These features were specifically designed to allow a TypeSpec specification to be written in terms of logical entities that emitters could then maintain.\n\n## Getting started\n\nIf you're new to writing emitters, begin with the [emitter basics](./emitters-basics.md).\r\n\r\nNext, examine the [REST metadata emitter sample](https://github.com/microsoft/typespec/tree/main/packages/samples/specs/rest-metadata-emitter). This sample uses all of the APIs discussed below to create a simple textual representation. It intentionally avoids splitting types like the OpenAPI emitter to highlight that this is not mandatory. Instead, it includes contextual comments to indicate how data depends on context.\r\n\r\nHowever, if you want your emitter to split types like OpenAPI, you can still use the same API. Cross-referencing with the official [OpenAPI emitter](../emitters/openapi3/openapi.md) where these APIs are called can also be helpful.\n\n## Key API\n\n- Use this to check if a type undergoes any shape changes due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- [`MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#ispayloadproperty) - Use this to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\r\n\r\n- [`MetadataInfo.isOptional(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#isoptional) - Use this to determine if a property is optional for the given visibility. This will differ from `ModelProperty.isOptional` when the Visibility is Update, in which case the property is always considered optional.\r\n\r\n- [`Visibility.Item`](../libraries/http/reference/js-api/enumerations/Visibility.md) - Add this flag when recursing into an array. This moves all metadata into the payload, which can be useful in scenarios like batching API calls.\n\nHere are the main APIs involved in managing these features. For more details, refer to the linked API reference documentation.\r\n\r\n- [`resolveRequestVisibility(Program, Operation, HttpVerb): Visibility`](../libraries/http/reference/js-api/functions/resolveRequestVisibility.md) - Use this to determine the visibility implied for data in the request parameters or body. Note that [`Visibility.Read`](../libraries/http/reference/js-api/enumerations/Visibility.md) is always applied for response data, so there is no corresponding API for the response.\r\n\r\n- [`MetadataInfo`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md) - Create this once for each program using [`createMetadataInfo(Program, MetadataInfoOptions)`](../libraries/http/reference/js-api/functions/createMetadataInfo.md). Then use it to understand metadata and visibility implications with the APIs below.\r\n\r\n- [`MetadataInfo.getEffectivePayloadType(Type, Visibility): Type`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#geteffectivepayloadtype) - Use this recursively on every referenced type. When given an anonymous model sourced entirely from a single named model after metadata is moved elsewhere or invisible properties are removed, it will recover the named model. This handles the commonly discussed case of seeing that `op something(...Thing)` receives a `Thing` in its request body, among other cases.\r\n\r\n- [`MetadataInfo.isTransformed(Model, Visibility)`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#istransformed) - Use this to check if a type undergoes any shape changes due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- [`MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#ispayloadproperty) - Use this to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\n\n## Working with metadata and visibility\n\nmodel after metadata is moved elsewhere or invisible properties are removed.\r\n\r\n- The `MetadataInfo.isTransformed(Model, Visibility)` API is used to check if a type undergoes any changes in shape due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- The `MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean` API is used to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\r\n\r\n- The `MetadataInfo.isOptional(ModelProperty, Visibility): boolean` API is used to determine if a property is optional for the given visibility. This will differ from `ModelProperty.isOptional` when the Visibility is Update, in which case the property is always considered optional.\r\n\r\n- The `Visibility.Item` flag is added when recursing into an array. This moves all metadata into the payload, which can be useful in scenarios like batching API calls.\r\n\r\nBy understanding and correctly using these APIs and concepts, you can ensure that your emitter handles metadata and visibility consistently and effectively.\n\nWhen working with metadata and visibility, it's important to understand how they interact with each other and with the data being transmitted. Here are some key points to consider:\r\n\r\n- Metadata is data about the data being transmitted. It can include information like the data's origin, when it was created or last updated, who created or updated it, and so on. Metadata is not usually visible to the end user, but it can be crucial for the system processing the data.\r\n\r\n- Visibility determines what data is visible to the end user or the system at any given time. For example, some data might be visible only to the system, some only to the end user, and some to both. Visibility can change depending on the context, such as whether the data is being created, read, updated, or deleted.\r\n\r\n- The `getRequestVisibility(HttpVerb): Visibility` API is used to determine the visibility implied for data in the request parameters or body. Note that `Visibility.Read` is always applied for response data, so there is no corresponding API for the response.\r\n\r\n- The `MetadataInfo` API is used to create a metadata object for each program, which can then be used to reason about metadata and visibility implications.\r\n\r\n- The `MetadataInfo.getEffectivePayloadType(Type, Visibility): Type` API is used recursively on every type that is referenced. It recovers the named model when given an anonymous model sourced entirely from a single named model after metadata is moved elsewhere or invisible properties are removed.\r\n\r\n- The `MetadataInfo.isTransformed(Model, Visibility)` API is used to check if a type undergoes any changes in shape due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- The `MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean` API is used to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\n", "latency": 11.301761150360107, "response_length": 918}
{"query": "What is causing the discrepancy between the local and pipeline TypeSpec Validation results?", "ground_truth": "The discrepancy between the local and pipeline TypeSpec Validation results may be caused by outdated dependencies. Running `npm ci` to update dependencies and ensuring you are up to date with the main branch can fix the issue.", "response": "The discrepancy between local and pipeline TypeSpec validation results can arise due to several factors. Common causes include differences in the environment setup, such as mismatched TypeSpec versions, missing dependencies, or configuration mismatches in `tspconfig.yaml`. Additionally, discrepancies may occur if the pipeline uses stricter linting rules or additional validation steps that are not present in the local setup. To resolve this, ensure that:\n\n1. Both local and pipeline environments use the same TypeSpec version and dependencies. Run `npm ci` to ensure a clean install of dependencies.\n2. The `tspconfig.yaml` file is correctly configured and consistent across environments. For ARM specs, ensure it extends the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set.\n3. All warnings and errors from `tsp compile` are addressed locally before running in the pipeline.\n4. The pipeline is not introducing additional validation steps or rules that are not accounted for locally.\n\nIf the issue persists, compare the outputs of `tsp compile` and any linting or validation logs from both environments to identify specific differences.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n", "latency": 16.73931050300598, "response_length": 1162}
{"query": "Why does the final operation name to SDK emitter remain 'reclassify' instead of changing to 'reclassifyJob'?", "ground_truth": "The final operation name remains 'reclassify' instead of changing to 'reclassifyJob' possibly due to the ResourceAction taking the operation name as the action part in the URL when there is no override. Autorest respects @clientName for ARM transition, and it's intended for autorest to render it as a client. However, moving @clientName from routes.tsp to client.tsp showed differences in the tsp verification step, indicating that 'operationId' actually takes the @clientName in TCGC, suggesting that decorators in TCGC might affect Swagger.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/decorators\n- document_content: # libraries#azure-core#reference#decorators.md\n\n# Decorators\n\n## Azure.Core\n\n### `@finalLocation` {#@Azure.Core.finalLocation}\n\nIdentifies a ModelProperty as containing the final location for the operation result.\r\n\r\n```typespec\r\n@Azure.Core.finalLocation(finalResult?: Model | void)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type            | Description                                                                                                                                                        |\r\n| ----------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| finalResult | `Model \\| void` | Sets the expected return value for the final result. Overrides<br />any value provided in the decorated property, if the property uses ResourceLocation<Resource>. |\n\n### `@finalOperation` {#@Azure.Core.finalOperation}\n\nIdentifies that an operation is the final operation for an LRO.\r\n\r\n```typespec\r\n@Azure.Core.finalOperation(linkedOperation: Operation, parameters?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name            | Type        | Description                                                                                                               |\r\n| --------------- | ----------- | ------------------------------------------------------------------------------------------------------------------------- |\r\n| linkedOperation | `Operation` | The linked Operation                                                                                                      |\r\n| parameters      | `{}`        | Map of `RequestParameter<Name>` and/or `ResponseProperty<Name>` that will<br />be passed to the linked operation request. |\n\n### `@fixed` {#@Azure.Core.fixed}\n\nMarks an Enum as being fixed since enums in Azure are\r\nassumed to be extensible.\r\n\r\n```typespec\r\n@Azure.Core.fixed\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@items` {#@Azure.Core.items}\n\nIdentifies the ModelProperty that contains the paged items. Can only be used on a Model marked with `@pagedResult`.\r\n\r\n```typespec\r\n@Azure.Core.items\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroCanceled` {#@Azure.Core.lroCanceled}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies an EnumMember as a long-running \"Canceled\" terminal state.\r\n\r\n```typespec\r\n@Azure.Core.lroCanceled\r\n```\r\n\r\n#### Target\r\n\r\n`EnumMember | UnionVariant`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroErrorResult` {#@Azure.Core.lroErrorResult}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies a model property of a StatusMonitor as containing the result\r\nof a long-running operation that terminates unsuccessfully (Failed).\r\n\r\n```typespec\r\n@Azure.Core.lroErrorResult\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroFailed` {#@Azure.Core.lroFailed}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies an enum member as a long-running \"Failed\" terminal state.\r\n\r\n```typespec\r\n@Azure.Core.lroFailed\r\n```\r\n\r\n#### Target\r\n\r\n`EnumMember | UnionVariant`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroResult` {#@Azure.Core.lroResult}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies a model property of a StatusMonitor as containing the result\r\nof a long-running operation that terminates successfully (Succeeded).\r\n\r\n```typespec\r\n@Azure.Core.lroResult\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroStatus` {#@Azure.Core.lroStatus}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies an Enum or ModelProperty as containing long-running operation\r\nstatus.\r\n\r\n```typespec\r\n@Azure.Core.lroStatus\r\n```\r\n\r\n#### Target\r\n\r\n`Enum | Union | ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@lroSucceeded` {#@Azure.Core.lroSucceeded}\n\nUsed for custom StatusMonitor implementation.\r\nIdentifies an EnumMember as a long-running \"Succeeded\" terminal state.\r\n\r\n```typespec\r\n@Azure.Core.lroSucceeded\r\n```\r\n\r\n#### Target\r\n\r\n`EnumMember | UnionVariant`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@nextPageOperation` {#@Azure.Core.nextPageOperation}\n\nIdentifies that an operation is used to retrieve the next page for paged operations.\r\n\r\n```typespec\r\n@Azure.Core.nextPageOperation(linkedOperation: Operation, parameters?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name            | Type        | Description                                                                                                               |\r\n| --------------- | ----------- | ------------------------------------------------------------------------------------------------------------------------- |\r\n| linkedOperation | `Operation` | The linked Operation                                                                                                      |\r\n| parameters      | `{}`        | Map of `RequestParameter<Name>` and/or `ResponseProperty<Name>` that will<br />be passed to the linked operation request. |\n\n### `@operationLink` {#@Azure.Core.operationLink}\n\nIdentifies an operation that is linked to the target operation.\r\n\r\n```typespec\r\n@Azure.Core.operationLink(linkedOperation: Operation, linkType: valueof string, parameters?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name            | Type             | Description                                                                                                               |\r\n| --------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------- |\r\n| linkedOperation | `Operation`      | The linked Operation                                                                                                      |\r\n| linkType        | `valueof string` | A string indicating the role of the linked operation                                                                      |\r\n| parameters      | `{}`             | Map of `RequestParameter<Name>` and/or `ResponseProperty<Name>` that will<br />be passed to the linked operation request. |\n\n### `@pagedResult` {#@Azure.Core.pagedResult}\n\nMarks a Model as a paged collection.\r\n\r\n```typespec\r\n@Azure.Core.pagedResult\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@pollingLocation` {#@Azure.Core.pollingLocation}\n\nIdentifies a model property as containing the location to poll for operation state.\r\n\r\n```typespec\r\n@Azure.Core.pollingLocation(options?: Azure.Core.PollingOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                          | Description                                                                                                                                                                                  |\r\n| ------- | ------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| options | [`PollingOptions`](./data-types.md#Azure.Core.PollingOptions) | PollingOptions for the poller pointed to by this link. Overrides<br />settings derived from property value it is decorating, if the value of the<br />property is ResourceLocation<Resource> |\n\n### `@pollingOperation` {#@Azure.Core.pollingOperation}\n\nIdentifies that an operation is a polling operation for an LRO.\r\n\r\n```typespec\r\n@Azure.Core.pollingOperation(linkedOperation: Operation, parameters?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name            | Type        | Description                                                                                                               |\r\n| --------------- | ----------- | ------------------------------------------------------------------------------------------------------------------------- |\r\n| linkedOperation | `Operation` | The linked Operation                                                                                                      |\r\n| parameters      | `{}`        | Map of `RequestParameter<Name>` and/or `ResponseProperty<Name>` that will<br />be passed to the linked operation request. |\n\n### `@pollingOperationParameter` {#@Azure.Core.pollingOperationParameter}\n\nUsed to define how to call custom polling operations for long-running operations.\r\n\r\n```typespec\r\n@Azure.Core.pollingOperationParameter(targetParameter?: ModelProperty | string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name            | Type                      | Description                                                                                                                                                                                        |\r\n| --------------- | ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| targetParameter | `ModelProperty \\| string` | A reference to the polling operation parameter this parameter<br />provides a value for, or the name of that parameter. The default value is the name of<br />the decorated parameter or property. |\n\n### `@useFinalStateVia` {#@Azure.Core.useFinalStateVia}\n\nOverrides the final state value for an operation\r\n\r\n```typespec\r\n@Azure.Core.useFinalStateVia(finalState: valueof \"original-uri\" | \"operation-location\" | \"location\" | \"azure-async-operation\")\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type                                                                                      | Description                   |\r\n| ---------- | ----------------------------------------------------------------------------------------- | ----------------------------- |\r\n| finalState | `valueof \"original-uri\" \\| \"operation-location\" \\| \"location\" \\| \"azure-async-operation\"` | The desired final state value |\n\n## Azure.Core.Foundations\n\n### `@omitKeyProperties` {#@Azure.Core.Foundations.omitKeyProperties}\n\nDeletes any key properties from the model.\r\n\r\n```typespec\r\n@Azure.Core.Foundations.omitKeyProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@requestParameter` {#@Azure.Core.Foundations.requestParameter}\n\nIdentifies a property on a request model that serves as a linked operation parameter.\r\n\r\n```typespec\r\n@Azure.Core.Foundations.requestParameter(name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description                 |\r\n| ---- | ---------------- | --------------------------- |\r\n| name | `valueof string` | Property name on the target |\n\n### `@responseProperty` {#@Azure.Core.Foundations.responseProperty}\n\nIdentifies a property on _all_ non-error response models that serve as a linked operation parameter.\r\n\r\n```typespec\r\n@Azure.Core.Foundations.responseProperty(name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description                 |\r\n| ---- | ---------------- | --------------------------- |\r\n| name | `valueof string` | Property name on the target |\n\n## Azure.Core.Traits\n\n### `@trait` {#@Azure.Core.Traits.trait}\n\n`@trait` marks a model type as representing a 'trait' and performs basic validation\r\nchecks.\r\n\r\n```typespec\r\n@Azure.Core.Traits.trait(traitName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe model type to mark as a trait.\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                        |\r\n| --------- | ---------------- | -------------------------------------------------------------------------------------------------- |\r\n| traitName | `valueof string` | An optional name to uniquely identify the trait. If unspecified,<br />the model type name is used. |\n\n### `@traitAdded` {#@Azure.Core.Traits.traitAdded}\n\nSets the version for when the trait was added to the specification. Can be applied\r\nto either a trait model type or its envelope property.\r\n\r\n```typespec\r\n@Azure.Core.Traits.traitAdded(addedVersion: EnumMember | null)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name         | Type                 | Description                                       |\r\n| ------------ | -------------------- | ------------------------------------------------- |\r\n| addedVersion | `EnumMember \\| null` | The enum member representing the service version. |\n\n### `@traitContext` {#@Azure.Core.Traits.traitContext}\n\n`@traitContext` sets the applicable context for a trait on its envelope property.\r\n\r\n```typespec\r\n@Azure.Core.Traits.traitContext(contexts: EnumMember | Union | unknown)\r\n```\r\n\r\n#### Target\r\n\r\nThe trait envelope property where the context will be applied.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type                             | Description                                                                                |\r\n| -------- | -------------------------------- | ------------------------------------------------------------------------------------------ |\r\n| contexts | `EnumMember \\| Union \\| unknown` | An enum member or union of enum members representing the trait's<br />applicable contexts. |\n\n### `@traitLocation` {#@Azure.Core.Traits.traitLocation}\n\n`@traitLocation` sets the applicable location for a trait on its envelope property.\r\n\r\n```typespec\r\n@Azure.Core.Traits.traitLocation(contexts: EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\nThe trait envelope property where the context will be applied.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type         | Description                                                                                |\r\n| -------- | ------------ | ------------------------------------------------------------------------------------------ |\r\n| contexts | `EnumMember` | An enum member or union of enum members representing the trait's<br />applicable contexts. |\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitter-metadata-handling.md\n- document_title: Managing metadata and visibility in REST API emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitter-metadata-handling\n- document_content: # extending-typespec#emitter-metadata-handling.md\n\n# Managing metadata and visibility in REST API emitters\n\nEnsuring consistent handling of [automatic visibility](../libraries/http/operations.md#automatic-visibility) and [metadata](../libraries/http/operations.md#metadata) by all REST API emitters is crucial. To understand how these features work, please refer to the TypeSpec-author documentation. This guide will help you integrate these features into your own emitter correctly.\r\n\r\nThe standard `/rest` library offers a JavaScript API for emitters to interpret APIs written using its decorators. We will focus on the APIs that are specifically relevant to these features.\r\n\r\nWhen we say that emitters should handle things consistently, we mean they should agree on how data is transmitted and received. A TypeSpec _specification_ should serve as a reliable reference for these details. However, emitters can still _abstract_ things above this level and make different choices. For instance, the OpenAPI emitter may split a single TypeSpec model into multiple suffixed schemas like `UserCreate` and `UserUpdate`, while a client SDK emitter might emit a single `User` class that can be serialized to a request or deserialized from a response with different fields present in different situations. These features were specifically designed to allow a TypeSpec specification to be written in terms of logical entities that emitters could then maintain.\n\n## Getting started\n\nIf you're new to writing emitters, begin with the [emitter basics](./emitters-basics.md).\r\n\r\nNext, examine the [REST metadata emitter sample](https://github.com/microsoft/typespec/tree/main/packages/samples/specs/rest-metadata-emitter). This sample uses all of the APIs discussed below to create a simple textual representation. It intentionally avoids splitting types like the OpenAPI emitter to highlight that this is not mandatory. Instead, it includes contextual comments to indicate how data depends on context.\r\n\r\nHowever, if you want your emitter to split types like OpenAPI, you can still use the same API. Cross-referencing with the official [OpenAPI emitter](../emitters/openapi3/openapi.md) where these APIs are called can also be helpful.\n\n## Key API\n\n- Use this to check if a type undergoes any shape changes due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- [`MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#ispayloadproperty) - Use this to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\r\n\r\n- [`MetadataInfo.isOptional(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#isoptional) - Use this to determine if a property is optional for the given visibility. This will differ from `ModelProperty.isOptional` when the Visibility is Update, in which case the property is always considered optional.\r\n\r\n- [`Visibility.Item`](../libraries/http/reference/js-api/enumerations/Visibility.md) - Add this flag when recursing into an array. This moves all metadata into the payload, which can be useful in scenarios like batching API calls.\n\nHere are the main APIs involved in managing these features. For more details, refer to the linked API reference documentation.\r\n\r\n- [`resolveRequestVisibility(Program, Operation, HttpVerb): Visibility`](../libraries/http/reference/js-api/functions/resolveRequestVisibility.md) - Use this to determine the visibility implied for data in the request parameters or body. Note that [`Visibility.Read`](../libraries/http/reference/js-api/enumerations/Visibility.md) is always applied for response data, so there is no corresponding API for the response.\r\n\r\n- [`MetadataInfo`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md) - Create this once for each program using [`createMetadataInfo(Program, MetadataInfoOptions)`](../libraries/http/reference/js-api/functions/createMetadataInfo.md). Then use it to understand metadata and visibility implications with the APIs below.\r\n\r\n- [`MetadataInfo.getEffectivePayloadType(Type, Visibility): Type`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#geteffectivepayloadtype) - Use this recursively on every referenced type. When given an anonymous model sourced entirely from a single named model after metadata is moved elsewhere or invisible properties are removed, it will recover the named model. This handles the commonly discussed case of seeing that `op something(...Thing)` receives a `Thing` in its request body, among other cases.\r\n\r\n- [`MetadataInfo.isTransformed(Model, Visibility)`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#istransformed) - Use this to check if a type undergoes any shape changes due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- [`MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean`](../libraries/http/reference/js-api/interfaces/MetadataInfo.md#ispayloadproperty) - Use this to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\n\n## Working with metadata and visibility\n\nmodel after metadata is moved elsewhere or invisible properties are removed.\r\n\r\n- The `MetadataInfo.isTransformed(Model, Visibility)` API is used to check if a type undergoes any changes in shape due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- The `MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean` API is used to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\r\n\r\n- The `MetadataInfo.isOptional(ModelProperty, Visibility): boolean` API is used to determine if a property is optional for the given visibility. This will differ from `ModelProperty.isOptional` when the Visibility is Update, in which case the property is always considered optional.\r\n\r\n- The `Visibility.Item` flag is added when recursing into an array. This moves all metadata into the payload, which can be useful in scenarios like batching API calls.\r\n\r\nBy understanding and correctly using these APIs and concepts, you can ensure that your emitter handles metadata and visibility consistently and effectively.\n\nWhen working with metadata and visibility, it's important to understand how they interact with each other and with the data being transmitted. Here are some key points to consider:\r\n\r\n- Metadata is data about the data being transmitted. It can include information like the data's origin, when it was created or last updated, who created or updated it, and so on. Metadata is not usually visible to the end user, but it can be crucial for the system processing the data.\r\n\r\n- Visibility determines what data is visible to the end user or the system at any given time. For example, some data might be visible only to the system, some only to the end user, and some to both. Visibility can change depending on the context, such as whether the data is being created, read, updated, or deleted.\r\n\r\n- The `getRequestVisibility(HttpVerb): Visibility` API is used to determine the visibility implied for data in the request parameters or body. Note that `Visibility.Read` is always applied for response data, so there is no corresponding API for the response.\r\n\r\n- The `MetadataInfo` API is used to create a metadata object for each program, which can then be used to reason about metadata and visibility implications.\r\n\r\n- The `MetadataInfo.getEffectivePayloadType(Type, Visibility): Type` API is used recursively on every type that is referenced. It recovers the named model when given an anonymous model sourced entirely from a single named model after metadata is moved elsewhere or invisible properties are removed.\r\n\r\n- The `MetadataInfo.isTransformed(Model, Visibility)` API is used to check if a type undergoes any changes in shape due to visibility or metadata. If not, this can allow for simplifications in emit.\r\n\r\n- The `MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean` API is used to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#azure-core#long-running-operations.md\n- document_title: Deep Dive: Long-running (Asynchronous) Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/azure-core/long-running-operations\n- document_content: # howtos#azure-core#long-running-operations.md\n\n# Deep Dive: Long-running (Asynchronous) Operations\n\nLong-running, or asynchronous operations (LROs for short) are Http Operations that are not complete in a single request/response sequence. Such operations require multiple requests and responses, usually to different endpoints before the operation is complete. Some common patterns that services use for LROs include:\r\n\r\n- Polling the resource 'GET' endpoint - Using a 'status' field in the resource to specify the resource state, and polling the resource Get endpoint until the status field reached a terminal status. A 'Location' header is often provided on the initial operation response, with a Url for the resource 'Get' endpoint.\r\n- Using a Status Monitor endpoint - Defining a separate endpoint where operation status can be obtained. An 'Operation-Location' or similar header with a Url for the StatusMonitor endpoint is most often provided in the initial operation response.\r\n- Providing a Push Notification System - Allowing the client to specify an endpoint for the service to call once the operation is complete\r\n\r\nNote that, for many APIs, the Url of the StatusMonitor (or resource GET) endpoint can easily be determined from the values in the initial request and response. This pattern is often followed when linking operations in OpenAPI3 specifications.\n\n## Modeling Long-running Operations in TypeSpec\n\nThe `@azure-tools/typespec-azure-core` library contains specific operation templates for long-running operation patterns recommended by the api review board. Using these templates will ensure that a service has the widest range of compatibility with Azure SDKs and Azure tooling for long-running operations. Service teams **should** use these templates to define their long-running operations. Existing services that have LROs that do not comply with API guidelines should discuss their operations with the Api review board, or the TypeSpec team.\n\n## Long-running Operation Helpers for Emitters and Libraries\n\n| contains values corresponding to the same field in the `x-ms-long-running-operation-options` extension in OpenAPI specifications.                                                                                                                                                       |\r\n| `statusMonitor`   | contains information about the status monitor, including the status monitor type                                                                                                                                                                                                        |\r\n| `polling`         | contains information about polling the status monitor, including the status field and terminal status values                                                                                                                                                                            |\r\n| `final`           | contains information about how to get the result when polling completes. In the standard case. this will contain a reference to the status monitor property that contains result information. If another operation needs to be called to get the status, that information will be here. |\r\n\r\nAs indicated above, operations often contain multiple mechanisms that clients can use to resolve a long-running operation, this means that an operation will frequently contain both operation links and resource links that describe the LRO. The helper prefers the use of resource links to the use of operation links, where possible.\n\nThe Azure.Core library provides a helper that emitters can use to determine if an operation being processed is an LRO, and to provide details about how the LRO should be processed by clients, or about how operations are linked.\r\n\r\n```typespec\r\ngetLroMetadata( program: Program, operation: Operation) : LroMetadata | undefined;\r\n```\r\n\r\nThe `LroMetadata` returned from this function contains information about the linked operations and their behavior, as well as additional that clients used to processing OpenAPI2 will be able to use to process TypeSpec operations similarly:\r\n\r\n| Property          | Description                                                                                                                                                                                                                                                                             |\r\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `logicalResponse` | contains the type of the operation response, for the long-running operation (i.e. the result after polling completes).                                                                                                                                                                  |\r\n| `final-state-via` | contains values corresponding to the same field in the `x-ms-long-running-operation-options` extension in OpenAPI specifications.                                                                                                                                                       |\r\n| `statusMonitor`   | contains information about the status monitor, including the status monitor type\n\n## Describing Custom LRO Patterns using Azure.Core\n\nThe `@azure-tools/typespec-azure-core` library also contains general structures for defining custom long-running operations using specialized model templates and decorators. The following sections describe . The primary mechanisms for linking operations are `Operation Links` and `Resource Links`.\n\n### Custom LROs - Operation Links\n\nOperation links are used when the input parameters to a linked operation can be determined from parameters in the initial operation request and response. For example, if a polling operation uses the identity parameters of the initial request, and an `operationId` parameter which is returned in a header or field in the response, the link between the operations should be modeled as an Operation Link. In order to use an Operation link, each parameter of the linked operation must correspond with a parameter of the initial operation, a property of the initial request (header or body), or property of the initial response (header or body). Operation links encode a reference to the linked operation, and a mapping between the initial request and response and the parameters of the linked operation:\r\n\r\n```typespec\r\nop getWidgetOperationStatus is getResourceOperationStatus<Widget>;\r\n\r\n@pollingOperation(getWidgetOperationStatus, parameterMap)\r\nop createWidgetAsync is longRunningCreateOrReplace<Widget>;\r\n```\r\n\r\nNote that, in the example above, the `@pollingOperation`decorator is used to specify an operation link to a StatusMonitor endpoint. This is just syntactic sugar for `@operationLink(getWidgetOperationStatus, \"polling\", parameterMap)`. To represent the logical stages of an LRO, `@pollingOperation` represents a link to a statusMonitor, and is the only decoration required for operations that comply with the recommended LRO pattern. Another decorator `@finalOperation` represents a link to an operation where the final result must be obtained my making a final request after polling has terminated.\r\n\r\n#### Decorators for Operation Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for operation links\r\n\r\n`@pollingOperation` - links a long-running operation to its status monitor endpoint.\n\na link to a statusMonitor, and is the only decoration required for operations that comply with the recommended LRO pattern. Another decorator `@finalOperation` represents a link to an operation where the final result must be obtained my making a final request after polling has terminated.\r\n\r\n#### Decorators for Operation Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for operation links\r\n\r\n`@pollingOperation` - links a long-running operation to its status monitor endpoint.\r\n`@finalOperation` - links a long-running operation to an additional endpoint, in the case that an additional endpoint must be called to obtain the final result after polling the status monitor is complete.\r\n\r\nEach of these decorators require a reference to the linked operation. They may also provide a mapping between the parameters and response properties of the initial request to the parameters of the linked operation. This mapping can be provided as a `Model` type parameter passed to the decorator, or by decorating the parameters and response properties of the original operation using `@lroParameter`\n\n### Custom LROs - Resource Links\n\nResource links are used when the entire url of the linked operation is provided as part of the response to the initial operation. A resource link encodes the type of the expected response when the link is followed:\r\n\r\n```typespec\r\nmodel WidgetStatusMonitorResponse {\r\n  @pollingLocation\r\n  @header(\"Operation-Location\")\r\n  operationLocation: ResourceLocation<ResourceOperationStatus<Widget>>;\r\n  // following the url in this header will provide a response of type ResourceOperationStatus<Widget>\r\n}\r\n```\r\n\r\n#### Decorators for Resource Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for resource links used in long-running operations:\r\n\r\n`@pollingLocation` - indicates that the decorated property contains a url to the StatusMonitor. The type of the decorated property **should** be a `ResourceLocation`.\r\n`@finalLocation` - indicates that the decorated property contains a url to the final result, in cases where an additional request must be made after polling to obtain the final result of the operation. The type of the decorated property must be a `ResourceLocation`.\r\n\r\n```typespec\r\nalias ResultHeaders = {\r\n  @pollingLocation\r\n  @header(\"Operation-Location\")\r\n  operationLocation: ResourceLocation<ResourceOperationStatus<Widget>>;\r\n\r\n  @finalLocation\r\n  @header(\"location\")\r\n  location: ResourceLocation<Widget>;\r\n};\r\n```\r\n\r\nNote that the LRO templates provided in Azure.Core automatically provide the appropriate headers and resource location decoration for LROs.\r\nNote that operations often provide multiple mechanisms that clients may use to determine how to logically complete an operation. This is often done to allow clients with different capabilities to determine how to resolve a long-running operation. It is recommended that clients prefer using Operation links in preference to Resource links whenever possible, because OperationLinks provide more information about the next operation.\n\n### Status Monitor Types in Azure.Core\n\nFor Azure services, there is clear API guidance that requires usage of the Status Monitor pattern. In Azure, the Status Monitor has a specific structure, including:\r\n\r\n- A 'status' property containing the current status of the operation\r\n  - The status property is a string property that contains known values for terminal states, by default these are 'Succeeded' for successful operation termination, 'Failed' for operation termination with failure, and 'Canceled' to indicate the operation was canceled.\r\n- A 'result' property, containing the result of the operation once the operation has succeeded (and is null if it has not succeeded)\r\n- An 'error' property, containing any errors that occurred during the operation.\r\n\r\nIn Azure.Core, this structure is represented using the `ResourceOperationStatus<TResource, TSuccess, TError>` model. The initial response to a long-running operation in Azure must contain an `Operation-Location` header that contains a url to the StatusMonitor endpoint. The StatusMonitor endpoint Url can also be calculated using the key properties of the resource and an additional `operationId` key property. To allow repeatability of requests and automatic calculation of the statusMonitor Uri, each LRO should allow an `OperationId` header that sets the operationId for the operation id execution. The `OperationId` must also be included in a header in the initial lro response. These patterns are encoded in the `LongRunning` operation templates provided in Azure.Core. If your service description uses these templates, it will automatically be following the recommended pattern.\n\n### Decorators and Types for Custom StatusMonitors in Azure.Core\n\nA StatusMonitor provides information that drives client polling until an operation completes. This includes a `status` field containing the current state of the operation, with known values for terminal states, headers that suggest polling retry intervals, and fields that will contain result and error information when the operation reaches a terminal status. Azure.Core provides a `ResourceOperationStatus` template that defines the standard Azure status monitor for an Azure operation. However, some services may need to implement custom status monitors. Azure.Core provides additional decorators to help clients use custom status monitors.\r\n\r\n| Decorator                    | Value                                                                                                                                                                                                                                                                     |\r\n| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@lroStatus`                 | A decorator marking the field of the StatusMonitor that contains status information. This field should use a `union` type to specify terminal status values.                                                                                                              |\r\n| `@lroResult`                 | A decorator marking the property of the Status monitor that contains the result of the operation, when the operation completes successfully. By default, any field named 'result' in a StatusMonitor is assumed to contain the result of a successful operation.          |\r\n| `@lroErrorResult`            |\n\na `union` type to specify terminal status values.                                                                                                              |\r\n| `@lroResult`                 | A decorator marking the property of the Status monitor that contains the result of the operation, when the operation completes successfully. By default, any field named 'result' in a StatusMonitor is assumed to contain the result of a successful operation.          |\r\n| `@lroErrorResult`            | A decorator marking the property of the Status monitor that contains errors when the operation is unsuccessful. By default, any field named 'error' in a StatusMonitor is assumed to contain the result of a successful operation.                                        |\r\n| `@lroSucceeded`              | If a status monitor uses a value other than `Succeeded` to indicate operation termination with success, then the variant corresponding to successful completion should be decorated with this decorator.                                                                  |\r\n| `@lroCanceled`               | If a status monitor uses a value other than `Canceled` to indicate that the operation was cancelled, then the variant corresponding to cancellation should be decorated with this decorator.                                                                              |\r\n| `@lroFailed`                 | If a status monitor uses a value other than `Failed` to indicate operation termination with failure, then the variant corresponding to operation failure should be decorated with this decorator.                                                                         |\r\n| `@pollingOperationParameter` | Indicates which request parameters or response properties of an operation can be used to call the operation that retrieves lro status (Status Monitor). Each application of the decorator may reference or name the corresponding parameter in the `getStatus` operation. |\n\n### Examples of common (non-standard) Lro Patterns\n\nStatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Completed\"],\r\n      canceledState [\"Aborted\"],\r\n      failedState: [\"Faulted\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 2 - Status Monitor with custom result fields\r\n\r\nIn this example, the status monitor returns the result of a successful operation in a field with a name other than 'result'\r\n\r\n```tsp\r\n@lroStatus\r\nnum OperationStatus {\r\n  Running,\r\n  Succeeded,\r\n  Canceled,\r\n  Failed\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  @lroResult\r\n  success?: Widget;\r\n  @lroErrorResult\r\n  failure?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\n@pollingOperation(getStatus) // sets the status monitor for the operation\r\nop repairWidget is StandardResourceOperations.LongRUnningResourceAction<Widget, WidgetRepairRequest>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"success\",\r\n  finalStateVia: \"operation-location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: operationLocation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.success,\r\n    errorProperty: StatusMonitor.failure,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 3 - Link to StatusMonitor in the `location` header\r\n\r\nIn this example, the operation returns a `location` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\n\nterminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 3 - Link to StatusMonitor in the `location` header\r\n\r\nIn this example, the operation returns a `location` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header\r\n  location?: ResourceLocation;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 4 - Link to StatusMonitor in the `Azure-AsyncOperation` header\n\nazureAsyncOperation?: string;\r\n\r\n  @finalLocation // this marks the response property or header that will contain a link to the final result\r\n  @header\r\n  location?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@finalOperation(getWidget)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n\r\nop getWidget is StandardResourceOperations.ResourceRead<Widget>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"\",\r\n  finalStateVia: \"location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  finalStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 6 - Calling GetStatusMonitor operation with non-standard parameters\r\n\r\nIn this example, the operation does not return a link, instead, the request parameters and response properties can be used to call the `getStatus` operation that returns the Status Monitor.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path widgetId: string): StatusMonitor | ErrorResult;\n\nreturn a link, instead, the request parameters and response properties can be used to call the `getStatus` operation that returns the Status Monitor.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path widgetId: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget(\r\n  @pollingOperationParameter(getStatus::parameters.widgetId) @path id: string,\r\n  body: WidgetRepairRequest,\r\n): RepairAccepted | ErrorResult;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"custom-operation-reference\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"reference\",\r\n      operation: getStatus,\r\n      parameters: {\r\n        widgetId: {\r\n          sourceKind: \"RequestParameter\",\r\n          source: repairWidget::parameters.id,\r\n          target: getStatus::parameters.widgetId\r\n        }\r\n      }\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\n\ndata for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"azure-async-operation\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 5 - Link to StatusMonitor in the `Azure-AsyncOperation` header and final link\r\n\r\nIn this example, the operation returns a link to the Status Monitor (in `Azure-AsyncOperation`) **and** a link to the final result (in `location`).\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header(\"Azure-AsyncOperation\")\r\n  azureAsyncOperation?: string;\r\n\r\n  @finalLocation // this marks the response property or header that will contain a link to the final result\r\n  @header\r\n  location?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@finalOperation(getWidget)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n\r\nop getWidget is StandardResourceOperations.ResourceRead<Widget>;\r\n```\n\n- Status Monitor with custom terminal status fields\r\n- Status Monitor with custom result field\r\n- Link to StatusMonitor in the `location` header\r\n- Link to StatusMonitor in the `Azure-AsyncOperation` header\r\n- Link to operation with final status\r\n- Calling GetStatusMonitor operation with non-standard parameters\r\n\r\n#### Example 1 - Status Monitor with custom terminal status fields\r\n\r\nIn this example, the Status Monitor terminal properties for \"Succeeded\", \"Failed\", and \"Canceled\" use non-standard names.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n\r\n  @lroSucceeded\r\n  Completed: \"Completed\",\r\n\r\n  @lroCanceled\r\n  Aborted: \"Aborted\",\r\n\r\n  @lroFailed\r\n  Faulted: \"Faulted\",\r\n\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\n@pollingOperation(getStatus)\r\nop repairWidget is StandardResourceOperations.LongRUnningResourceAction<Widget>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"operation-location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: operationLocation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Completed\"],\r\n      canceledState [\"Aborted\"],\r\n      failedState: [\"Faulted\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 2 - Status Monitor with custom result fields\r\n\r\nIn this example, the status monitor returns the result of a successful operation in a field with a name other than 'result'\r\n\r\n```tsp\r\n@lroStatus\r\nnum OperationStatus {\n\n{\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 4 - Link to StatusMonitor in the `Azure-AsyncOperation` header\r\n\r\nIn this example, the operation returns a `Azure-AsyncOperation` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header(\"Azure-AsyncOperation\")\r\n  azureAsyncOperation?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"azure-async-operation\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n", "latency": 5.0768115520477295, "response_length": 79}
{"query": "Does this issue of operation names not changing affect all SDKs?", "ground_truth": "Yes, this issue of operation names not changing can affect all SDKs, especially considering that Autorest respects @clientName for the ARM transition, and it's a general behavior intended for Autorest to render it as a client.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#visibility.md\n- document_title: Visibility\n- document_link: https://typespec.io/docs/language-basics/visibility\n- document_content: # language-basics#visibility.md\n\n# Visibility\n\n**Visibility** is a language feature that allows you to share a model between multiple operations and define in which contexts\r\nproperties of the model are \"visible.\" Visibility is a very powerful feature that allows you to define different \"views\"\r\nof a model within different operations or contexts.\r\n\r\n**Note** ⚠️: Enum-based visibility as described in this document _replaces_ visibility strings that you may have used\r\nin the past. The system is backwards-compatible with visibility strings, but you should use enum-based visibility for\r\nnew specifications. String-based visibility (e.g. `@visibility(\"create\")`) may be deprecated and removed in future\r\nversions of TypeSpec.\n\n## Basic concepts\n\n- Visibility applies to _model properties_ only. It is used to determine when an emitter should include or exclude a\r\n  property in a certain context.\r\n- Visibility is defined using a _visibility class_. A visibility class is an `enum` that defines the visibility modifiers\r\n  (or flags) that can be applied to a property. Any `enum` can serve as a visibility class.\r\n- Visibility classes have a _default_ visibility, which is the set of visibility modifiers that are applied _by default_\r\n  to a property if the visibility is not explicitly set.\n\n## Lifecycle visibility\n\nschema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/ExampleUpdate\"\r\ncomponents:\r\n  schemas:\r\n    Example:\r\n      type: object\r\n      required:\r\n        - id\r\n        - name\r\n        - description\r\n      properties:\r\n        id:\r\n          type: string\r\n          readOnly: true\r\n        name:\r\n          type: string\r\n        description:\r\n          type: string\r\n    ExampleUpdate:\r\n      type: object\r\n      properties:\r\n        description:\r\n          type: string\r\n```\r\n\r\nNotice:\r\n\r\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\r\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\r\n  when updating the resource.\r\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\r\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\r\n  visibility of the properties in the model.\n\nTypeSpec provides a built-in visibility called \"resource lifecycle visibility.\" This visibility allows you to declare\r\nwhether properties are visible when passing a resource to or reading a resource from an API endpoint. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  /**\r\n   * The unique identifier of this resource.\r\n   *\r\n   * The ID is automatically generated by the service, so it cannot be set when the resource is created or updated,\r\n   * but the server will return it when the resource is read.\r\n   */\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  /**\r\n   * The name of this resource.\r\n   *\r\n   * The name can be set when the resource is created, but may not be changed.\r\n   */\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  /**\r\n   * The description of this resource.\r\n   *\r\n   * By default, properties are visible in all lifecycle phases, so this property\r\n   * is present in all lifecycle phases.\r\n   */\r\n  description: string;\r\n}\r\n```\r\n\r\nIn the above example, each property of the `Example` model has a lifecycle visibility that instructs emitters to include\r\nor exclude the property when creating, updating, or reading the `Example` resource.\r\n\r\nTypeSpec's HTTP library, OpenAPI emitter, and other standard functionality use the `Lifecycle` visibility to create\r\ndifferent views of the `Example` model based on which lifecycle phase is used in a particular operation.\r\n\r\nIn the following example, the type of the input and output of each operation is affected by the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\n\nby the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @get read(@path id: string): Ok<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the PATCH verb, it uses the `Update` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @patch update(@path id: string, @body example: Example): Ok<Example> | Error;\r\n}\r\n```\r\n\r\nThe above interface generates the following OpenAPIv3 schemas:\r\n\r\n```yml\r\npaths:\r\n  /example:\r\n    post:\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Example\"\r\n  /example/{id}:\r\n    get:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\n### Lifecycle modifiers\n\nThe following visibility modifiers are available in the `Lifecycle` visibility class:\r\n\r\n- `Create`: The property is visible when the resource is created. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `POST` operation.\r\n- `Read`: The property is visible when the resource is read. This visibility is checked, for example, when a property is\r\n  returned in an HTTP `GET` operation.\r\n- `Update`: The property is visible when the resource is updated. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `PATCH` or `PUT` operation.\r\n- `Delete`: The property is visible when a resource is deleted. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `DELETE` operation.\r\n- `Query`: The property is visible when a resource is passed as a parameter in a query. This visibility is checked, for\r\n  example, when a property is a parameter in an HTTP `GET` operation (**this should not be confused with an HTTP query\r\n  parameter defined using `@query`**).\n\n### Lifecycle visibility transforms\n\nYou can explicitly compute the shape of a model within a _specific_ lifecycle phase by using the four built-in\r\ntemplates for lifecycle transforms:\r\n\r\n- `Create<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Create` lifecycle\r\n  phase, recursively.\r\n- `Read<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Read` lifecycle phase,\r\n  recursively.\r\n- `Update<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Update` lifecycle\r\n  phase, with the types of the properties set to `CreateOrUpdate<T>`, recursively.\r\n- `CreateOrUpdate<T>`: creates a copy of `T` with only the properties that have _either_ the `Create` or `Update`\r\n  visibility modifiers enabled, recursively.\r\n- `Delete<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Delete` modifier enabled,\r\n  recursively.\r\n- `Query<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Query` modifier enabled,\r\n  recursively.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\nmodel ReadExample is Read<Example>;\r\n\r\nmodel CreateExample is Create<Example>;\r\n\r\nmodel UpdateExample is Update<Example>;\r\n\r\nmodel CreateOrUpdateExample is CreateOrUpdate<Example>;\r\n```\r\n\r\nWhen you use these templates, the resulting models have no `Lifecycle` visibility modifiers applied, so that any\r\nemitters or libraries that use lifecycle visibility will not alter them further.\n\n## Visibility modifiers\n\nEach property has its own set of _active visibility modifiers_ for each visibility class. The active modifiers can be\r\nchanged using the decorators described in this section.\r\n\r\n**Note**: Changing the visibility for one visibility class _does not_ affect other visibility classes. If you change the\r\nvisibility for the `Lifecycle` visibility class, it will not affect the modifiers that are active for _any_ other\r\nvisibility classes.\n\n### `@visibility`\n\nThe `@visibility` decorator _enables_ visibility modifiers. It takes a list of visibility modifiers as arguments and\r\nsets them on the property. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create, Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has the `Create` and `Read` visibility modifiers enabled.\r\n\r\nIf visibility has _already_ been set explicitly on a property, the `@visibility` decorator _ADDS_ its own visibility\r\nmodifiers to the currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create)\r\n@visibility(Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has both the `Create` and `Read` visibility modifiers enabled, but _not_ the `Update`\r\nvisibility modifier. The `@visibility` decorator starts from an _empty_ set of modifiers and adds the `Create` modifier,\r\nthen adds the `Read` modifier.\n\n### `@removeVisibility`\n\nThe `@removeVisibility` decorator _disables_ visibility modifiers. It takes a list of visibility modifiers as arguments\r\nand removes them from the property. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\nname: string;\r\n```\r\n\r\nThis use of `@removeVisibility` is equivalent to the above examples with the `@visibility` decorator, but it uses the `@removeVisibility`\r\ndecorator to remove the `Update` visibility modifier from the `name` property rather than adding the `Create` and `Read`\r\nvisibility modifiers. The `@removeVisibility` decorator starts from the _default_ set of visibility modifiers and removes\r\nthe `Update` modifier.\r\n\r\nIf the visibility has _already_ been set on a property, the `@removeVisibility` decorator _removes_ its visibility from\r\nthe currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\n@removeVisibility(Lifecycle.Create)\r\nid: string;\r\n```\r\n\r\nIn this example, the `id` property has the `Update` and `Create` visibility modifiers removed, but it retains the `Read`\r\nvisibility modifier.\n\n### `@invisible`\n\nThe `@invisible` decorator _disables all visibility modifiers_ on a property within a given visibility class. For example:\r\n\r\n```typespec\r\n@invisible(Lifecycle)\r\ninvisible: string;\r\n```\r\n\r\nIn this example, the `invisible` property has _no_ visibility modifiers enabled in the `Lifecycle` visibility class.\n\n## Visibility filters\n\nThe `@withVisibilityFilter` decorator allows you to transform a model by applying a visibility filter to it. A\r\nvisibility filter is an object that defines constraints on which visibility modifiers must be enabled/disabled for a\r\nproperty to be visible. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\n@withVisibilityFilter(#{ all: [Lifecycle.Create, Lifecycle.Read] })\r\nmodel CreateAndReadExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ any: [Lifecycle.Create, Lifecycle.Update] })\r\nmodel CreateOrUpdateExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ none: [Lifecycle.Update] })\r\nmodel NonUpdateExample {\r\n  ...Example;\r\n}\r\n```\r\n\r\nIn the above example, the `CreateAndReadExample` model is a copy of the `Example` model with only the the properties\r\nthat have _BOTH_ the `Create` and `Read` visibility modifiers enabled (i.e. only the `name` property). The\r\n`CreateOrUpdateExample` model is a copy of the `Example` model with only the properties that have _EITHER_ the `Create`\r\nor `Update` visibility modifiers enabled (i.e. the `id` and `name` properties). The `NonUpdateExample` model is a copy\r\nof the `Example` model with only the properties that _do not_ have the `Update` visibility modifier enabled (i.e. the\r\n`id` and `name` properties).\r\n\r\n**Note**: For `Lifecycle` visibility, you should ordinarily use the `Create`, `Read`, `Update`, and `CreateOrUpdate`\r\ntemplates instead of `@withVisibilityFilter` directly, but you can use `@withVisibilityFilter` to create custom \"views\"\r\nof a model that use visibility classes other than `Lifecycle` or custom filter logic.\n\n## Visibility classes\n\nAny TypeSpec `enum` can serve as a visibility class. The members of the `enum` define the visibility modifiers in the\r\nclass. For example, the following is the definition of the `Lifecycle` visibility class defined in the TypeSpec standard\r\nlibrary:\r\n\r\n```typespec\r\nenum Lifecycle {\r\n  Create,\r\n  Read,\r\n  Update,\r\n}\r\n```\r\n\r\nThis visibility class defines three visibility modifiers: `Create`, `Read`, and `Update`. By default, all properties\r\nhave _ALL_ three visibilities in the `Lifecycle` enum enabled.\n\n### Setting default visibility\n\nYou can set the default visibility for a visibility class by declaring it on the enum using the `@defaultVisibility`\r\ndecorator:\r\n\r\n```typespec\r\n@defaultVisibility(Example.A)\r\nenum Example {\r\n  A,\r\n  B,\r\n}\r\n```\r\n\r\nIn this example, any property that does not declare an `Example` visibility modifier will have the `A` visibility by\r\ndefault.\r\n\r\n**Note**: While you can define your own visibility classes, emitters _will not recognize them_ unless they have been\r\nprogrammed to do so. You can leverage custom visibility classes in your own emitters, but they will have no effect on\r\nthe standard emitters unless those emitters choose to adopt and recognize those visibility classes as meaningful. The\r\n`Lifecycle` visibility class is a standard visibility class that is recognized by several emitters. You can, however,\r\nuse your own visibility classes with the built in `@withVisibilityFilter` decorator to transform your models in whatever\r\nways you see fit.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#encoded-names.md\n- document_title: Encoded names\n- document_link: https://typespec.io/docs/standard-library/encoded-names\n- document_content: # standard-library#encoded-names.md\n\n# Encoded names\n\nThere is some cases where the name you have in TypeSpec might differ from the name over the wire or for a certain language.\n\n## Update name for a given target\n\nTo update the name of a TypeSpec entity you can use the `@encodedName` decorator. This decorator takes 2 parameters:\r\n\r\n| Parameter     | Type     | Description                                                                                                                                                                                                            |\r\n| ------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `mimeType`    | `string` | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| `encodedName` | `string` | The name should be when serialized to the given mime type.                                                                                                                                                             |\r\n\r\nExample:\r\n\r\n```typespec\r\nmodel Foo {\r\n  // Specify that when serializing to JSON `expireAt` property should be named `exp`\r\n  @encodedName(\"json\", \"exp\")\r\n  expireAt: string;\r\n}\r\n```\n\n## Example\n\n```typespec\r\nmodel CertificateAttributes {\r\n  @encodedName(\"application/json\", \"nbf\")\r\n  notBefore: int32;\r\n\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"ExpireAt\")\r\n  expires: int32;\r\n\r\n  created: int32;\r\n  updated: int32;\r\n}\r\n```\r\n\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>Json</th>\r\n<th>Xml</th>\r\n<th>Yaml</th>\r\n</tr>\r\n</thead>\r\n<tr>\r\n<td>When serialized to `application/json` properties will use the encodedName for `application/json` if available or default to the property name.</td>\r\n<td>When serialized to `application/xml` properties will use the encodedName for `application/xml` if available or default to the property name.</td>\r\n<td>Yaml didn't provide any different names so it will serialize using the property names.</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n\r\n```json\r\n{\r\n  \"nbf\": 1430344421,\r\n  \"exp\": 2208988799,\r\n  \"created\": 1493938289,\r\n  \"updated\": 1493938291\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<CertificateAttributes>\r\n  <notBefore>1430344421</notBefore>\r\n  <ExpireAt>2208988799</ExpireAt>\r\n  <created>1493938289</created>\r\n  <updated>1493938291</updated>\r\n</CertificateAttributes>\r\n```\r\n\r\n</td>\r\n\r\n<td>\r\n\r\n```yaml\r\nnotBefore: 1430344421\r\nexpires: 2208988799\r\ncreated: 1493938289\r\nupdated: 1493938291\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## Use in library/emitter\n\nTo consume the value of `@encodedName` in your library or emitter you can use `resolveEncodedName(target: Type, mimeType: string): string` from the compiler.\r\n\r\n```ts\r\nimport { resolveEncodedName } from \"@typespec/compiler\";\r\n\r\n// Resolve the encoded name for the given property and mime type. If the property doesn't have a encoded name for the given mime type it will return the property name.\r\nconst encodedName = resolveEncodedName(property, \"application/json\");\r\n\r\n// You can also pass a full http mime type and `resolveEncodedName` will automatically resolve it to the base mime type.\r\nconst encodedName = resolveEncodedName(property, \"application/merge-patch+json\");\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#03client.mdx\n- document_title: Clients\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/03client\n- document_content: # howtos#generate-client-libraries#03client.mdx\n\n# Clients\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page explains client behavior and how to customize clients. For an overview of the setup, please refer to the previous page.\r\n\r\n> **NOTE:** JS RLC does not support customization. It will ignore `client.tsp`, and the following scenarios will not affect the JS RLC user experience. In this context, \"TypeScript part\" refers to the JS Modular Emitter.\n\n## Default Behavior\n\n### Basic Rules\n\nBy default, the namespace with the `@service` decorator is generated as a root client. The client name is the namespace name with `Client` appended as a suffix.\r\n\r\nSub-namespaces and interfaces under each root client are generated as operation groups with a hierarchical structure.\r\n\r\nThe sequence of operation groups is determined by the order of namespace declarations, followed by interface declarations.\r\n\r\nThe root client's SDK namespace corresponds to the namespace decorated with `@service`. If an operation group originates from a sub-namespace, its SDK namespace corresponds to that sub-namespace. If it originates from an interface, its SDK namespace corresponds to the namespace containing the interface.\r\n\r\nBy default, operation groups can only be initialized by the root client or their parent operation group.\r\n\r\nDifferent languages organize clients and operation groups differently. Refer to the examples below for details.\n\n### Single Client\n\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(): void;\r\n\r\n@route(\"/op2\")\r\nop pet(): void;\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with One-Layer Child Operation Groups\n\n`PetStore` has two operation groups. The `Dogs` operation group comes from a sub-namespace, while `Cats` comes from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/dogs\")\r\ninterface Dogs {\r\n  feed(): void;\r\n  pet(): void;\r\n}\r\n\r\n@route(\"/cats\")\r\nnamespace Cats {\r\n  op feed(): void;\r\n  op pet(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.dogs.feed()\r\nclient.dogs.pet()\r\nclient.cats.feed()\r\nclient.cats.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.GetDogsClient().Feed();\r\nclient.GetDogsClient().Pet();\r\nclient.GetCatsClient().Feed();\r\nclient.GetCatsClient().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.dogs.feed();\r\nclient.dogs.pet();\r\nclient.cats.feed();\r\nclient.cats.pet();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nDogsClient dogsClient = builder.buildDogsClient();\r\ndogsClient.feed();\r\ndogsClient.pet();\r\n\r\nCatsClient catsClient = builder.buildCatsClient();\r\ncatsClient.feed();\r\ncatsClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with Multi-Layer Child Operation Groups\n\n`PetStore` has three operation groups: `Billings` (from an interface), `Pets` (from a sub-namespace), and `Actions` (from an interface). `Pets` also contains a nested operation group, `Actions`, from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/info\")\r\nop info(): void;\r\n\r\n@route(\"/billings\")\r\ninterface Billings {\r\n  @route(\"history\")\r\n  history(): void;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @route(\"info\")\r\n  op info(): void;\r\n\r\n  @route(\"/actions\")\r\n  interface Actions {\r\n    feed(): void;\r\n    pet(): void;\r\n  }\r\n}\r\n\r\n@route(\"/actions\")\r\ninterface Actions {\r\n  open(): void;\r\n  close(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.info()\r\nclient.billings.history()\r\nclient.pets.info()\r\nclient.pets.actions.feed()\r\nclient.pets.actions.pet()\r\nclient.actions.open()\r\nclient.actions.close()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Info();\r\nclient.GetBillingsClient().History();\r\nclient.GetPetsClient().Info();\r\nclient.GetPetsClient().GetPetsActionsClient().Feed();\r\nclient.GetPetsClient().GetPetsActionsClient().Pet();\r\nclient.GetActionsClient().Open();\r\nclient.GetActionsClient().Close();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.info();\r\nclient.billings.history();\r\nclient.pets.info();\r\nclient.pets.actions.feed();\r\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\n\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\r\npetsActionsClient.feed();\r\npetsActionsClient.pet();\r\n\r\nActionsClient actionsClient = builder.buildActionsClient();\r\nactionsClient.open();\r\nactionsClient.close();\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\nCustomizations SHOULD always be made in a file named `client.tsp` alongside `main.tsp`.\r\n\r\nYou can use `@client` and `@operationGroup` to restructure the client hierarchy. However, if any customizations are made, the client hierarchy will only reflect those customizations. The default behavior logic will no longer apply.\r\n\r\nIf customizations are made, the client's SDK namespace will follow the namespace decorated with `@client` or the namespace containing the interface decorated with `@client`. Similarly, the operation group's SDK namespace follows the same logic for `@operationGroup`. You can override this using `@clientNamespace` if needed.\r\n\r\nThe sequence of clients and operation groups is determined by the order of the `@client` and `@operationGroup` decorators.\r\n\r\nFor this section, we assume you have a service called `PetStore` in the `PetStore` namespace, defining two operations: `feed` and `pet`.\n\n### Renaming the Client Name\n\nThis can be achieved with the augment decorator: `@clientName` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(PetStore, \"PetStoreGreatClient\");\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreGreatClient\r\n\r\nclient = PetStoreGreatClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreGreatClient client = new PetStoreGreatClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreGreatClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreGreatClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreGreatClient client = new PetStoreGreatClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming the Client Namespace\n\nThis can be achieved with the augment decorator: `@clientNamespace` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientNamespace(PetStore, \"PetStoreRenamed\");\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients\n\nTwo clients that separate the operations can be declared using the `@client` decorator from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient, PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetActionClient petActionClient = new PetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nimport { FoodClient, PetActionClient } from \"@azure/package-name\";\r\n\r\nconst client1 = new PetActionClient();\r\nconst client2 = new FoodClient();\r\nclient1.pet();\r\nclient2.feed();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed()\r\npetActionClient.pet()\r\n```\r\n\r\n</ClientTabs>\n\n### One Client and Two Operation Groups\n\nTwo clients that separate the operations can be declared using the `@client` decorator and the `@operationGroup` decorator from `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@client({\r\n  name: \"PetStoreClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@operationGroup\r\ninterface OpGrp1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@operationGroup\r\ninterface OpGrp2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\n\r\nclient.op_grp_1.feed()\r\nclient.op_grp_2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\n\r\nclient.GetOpGrp1Client().Feed();\r\nclient.GetOpGrp2Client().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.opGrp1.feed();\r\nclient.opGrp2.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nOpGrp1Client opGrp1Client = builder.buildOpGrp1Client();\r\nopGrp1Client.feed();\r\n\r\nOpGrp2Client opGrp2Client = builder.buildOpGrp2Client();\r\nopGrp2Client.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Sub-Namespaces\n\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace NewPetStore;\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\nnamespace Food {\r\n  op feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetAction {\r\n  op pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom new_pet_store.food import FoodClient\r\nfrom new_pet_store.pet_action import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport newpetstore.food.FoodClient;\r\nimport newpetstore.food.FoodClientBuilder;\r\nimport newpetstore.petaction.PetActionClient;\r\nimport newpetstore.petaction.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nfoodClient.feed();\r\n\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients and Having Clients in Different Namespaces\n\nTwo clients that separate the operations can be declared using the `client` decorator of `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\n@clientNamespace(\"PetStoreRenamed.SubNamespace\") // use @clientNamespace to specify the namespace of the client\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient\r\nfrom pet_store_renamed.sub_namespace import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\nusing PetStoreRenamed.SubNamespace;\r\n\r\nSubNamespacePetActionClient petActionClient = new SubNamespacePetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport petstorerenamed.FoodClient;\r\nimport petstorerenamed.FoodClientBuilder;\r\nimport petstorerenamed.subnamespace.PetActionClient;\r\nimport petstorerenamed.subnamespace.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Adding Client Initialization Parameters\n\nBy default, we only generate our clients with initialization parameters for `endpoint`, `credential`, and `apiVersion`, whenever any of these are applicable.\r\nThere are cases where spec authors would like their clients to have additional input parameters.\r\n\r\nWith `@clientInitialization`, you can pass in additional parameters you would like your client to have, by passing in `parameters` option of a model.\r\nAll properties of the model will be appended to the current default list of client initialization parameters.\r\nAdditionally, these client parameters will no longer appear on service methods that previously had them as part of the method signature.\r\nThe generated code will automatically pass in the inputted value from the client init to the service.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob_name=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\n\nStorage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\r\n\r\nIf you want to rename the parameter name that you elevate to the client level, you can use the `@paramAlias` decorator.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  @paramAlias(\"blobName\")\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blob(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\n\n### Change Operation Group Initialization Way\n\nBy default, all the nested operation group could only be initialized by parent client or operation group.\r\nThere are cases where spec authors would like their operation groups could both be initialized by parent as well as individually.\r\n\r\nWith `@clientInitialization`, you can change the initialization way, by passing in `initializedBy` option of `InitializedBy.individually | InitializedBy.parent` value.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    initializedBy: InitializedBy.individually | InitializedBy.parent,\r\n  }\r\n);\r\n```\r\n\r\n```python\n\n# TODO\n\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#use-standard-names.md\n- document_title: use-standard-names\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/use-standard-names\n- document_content: # libraries#azure-core#rules#use-standard-names.md\n\n# use-standard-names\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/use-standard-names\r\n```\r\n\r\nEnsure Azure Service operations follow the naming recommendations.\r\n\r\n| Operation type                       | Naming convention                                 |\r\n| ------------------------------------ | ------------------------------------------------- |\r\n| `GET` returning single object        | Start with `get`                                  |\r\n| `GET` returning list of object       | Start with `list`                                 |\r\n| `PUT` returning both `200` and `201` | Start with `createOrReplace`                      |\r\n| `PUT` returning only `201`           | Start with `create` or `createOrReplace`          |\r\n| `PUT` returning only `200`           | Start with `replace` or `createOrReplace`         |\r\n| `PATCH` returning `201`              | Start with `create`, `update` or `createOrUpdate` |\r\n| `DELETE`                             | Start with `delete`                               |\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nop addPet is ResourceCreate<Pet>;\r\n```\r\n\r\n```tsp\r\nop getPets is ResourceList<Pet>;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nop createPet is ResourceCreate<Pet>;\r\n```\r\n\r\n```tsp\r\nop listPets is ResourceList<Pet>;\r\n```\n", "latency": 5.752907752990723, "response_length": 79}
{"query": "Is the proposed solution to open a PR to change the operation name in client.tsp to 'reclassifyJob'?", "ground_truth": "The proposed solution to open a PR to change the operation name in client.tsp to 'reclassifyJob' is correct, but it was decided not to move the @clientName to avoid Swagger changes. This indicates that while changing the operation name in client.tsp to 'reclassifyJob' is a proposed solution, it may not be pursued to prevent affecting Swagger.", "response": "Yes, the proposed solution to open a PR to change the operation name in `client.tsp` to 'reclassifyJob' is valid. You can use the `@clientName` decorator from the `typespec-client-generator-core` library to rename the operation in the client SDK. For example:\n\n```typespec\nimport \"./main.tsp\";\nimport \"@azure-tools/typespec-client-generator-core\";\n\nusing Azure.ClientGenerator.Core;\n\n@@clientName(YourNamespace.YourOperation, \"reclassifyJob\");\n```\n\nThis will ensure that the operation is renamed to 'reclassifyJob' in the generated client libraries.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#03client.mdx\n- document_title: Clients\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/03client\n- document_content: # howtos#generate-client-libraries#03client.mdx\n\n# Clients\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page explains client behavior and how to customize clients. For an overview of the setup, please refer to the previous page.\r\n\r\n> **NOTE:** JS RLC does not support customization. It will ignore `client.tsp`, and the following scenarios will not affect the JS RLC user experience. In this context, \"TypeScript part\" refers to the JS Modular Emitter.\n\n## Default Behavior\n\n### Basic Rules\n\nBy default, the namespace with the `@service` decorator is generated as a root client. The client name is the namespace name with `Client` appended as a suffix.\r\n\r\nSub-namespaces and interfaces under each root client are generated as operation groups with a hierarchical structure.\r\n\r\nThe sequence of operation groups is determined by the order of namespace declarations, followed by interface declarations.\r\n\r\nThe root client's SDK namespace corresponds to the namespace decorated with `@service`. If an operation group originates from a sub-namespace, its SDK namespace corresponds to that sub-namespace. If it originates from an interface, its SDK namespace corresponds to the namespace containing the interface.\r\n\r\nBy default, operation groups can only be initialized by the root client or their parent operation group.\r\n\r\nDifferent languages organize clients and operation groups differently. Refer to the examples below for details.\n\n### Single Client\n\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(): void;\r\n\r\n@route(\"/op2\")\r\nop pet(): void;\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with One-Layer Child Operation Groups\n\n`PetStore` has two operation groups. The `Dogs` operation group comes from a sub-namespace, while `Cats` comes from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/dogs\")\r\ninterface Dogs {\r\n  feed(): void;\r\n  pet(): void;\r\n}\r\n\r\n@route(\"/cats\")\r\nnamespace Cats {\r\n  op feed(): void;\r\n  op pet(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.dogs.feed()\r\nclient.dogs.pet()\r\nclient.cats.feed()\r\nclient.cats.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.GetDogsClient().Feed();\r\nclient.GetDogsClient().Pet();\r\nclient.GetCatsClient().Feed();\r\nclient.GetCatsClient().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.dogs.feed();\r\nclient.dogs.pet();\r\nclient.cats.feed();\r\nclient.cats.pet();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nDogsClient dogsClient = builder.buildDogsClient();\r\ndogsClient.feed();\r\ndogsClient.pet();\r\n\r\nCatsClient catsClient = builder.buildCatsClient();\r\ncatsClient.feed();\r\ncatsClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with Multi-Layer Child Operation Groups\n\n`PetStore` has three operation groups: `Billings` (from an interface), `Pets` (from a sub-namespace), and `Actions` (from an interface). `Pets` also contains a nested operation group, `Actions`, from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/info\")\r\nop info(): void;\r\n\r\n@route(\"/billings\")\r\ninterface Billings {\r\n  @route(\"history\")\r\n  history(): void;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @route(\"info\")\r\n  op info(): void;\r\n\r\n  @route(\"/actions\")\r\n  interface Actions {\r\n    feed(): void;\r\n    pet(): void;\r\n  }\r\n}\r\n\r\n@route(\"/actions\")\r\ninterface Actions {\r\n  open(): void;\r\n  close(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.info()\r\nclient.billings.history()\r\nclient.pets.info()\r\nclient.pets.actions.feed()\r\nclient.pets.actions.pet()\r\nclient.actions.open()\r\nclient.actions.close()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Info();\r\nclient.GetBillingsClient().History();\r\nclient.GetPetsClient().Info();\r\nclient.GetPetsClient().GetPetsActionsClient().Feed();\r\nclient.GetPetsClient().GetPetsActionsClient().Pet();\r\nclient.GetActionsClient().Open();\r\nclient.GetActionsClient().Close();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.info();\r\nclient.billings.history();\r\nclient.pets.info();\r\nclient.pets.actions.feed();\r\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\n\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\r\npetsActionsClient.feed();\r\npetsActionsClient.pet();\r\n\r\nActionsClient actionsClient = builder.buildActionsClient();\r\nactionsClient.open();\r\nactionsClient.close();\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\nCustomizations SHOULD always be made in a file named `client.tsp` alongside `main.tsp`.\r\n\r\nYou can use `@client` and `@operationGroup` to restructure the client hierarchy. However, if any customizations are made, the client hierarchy will only reflect those customizations. The default behavior logic will no longer apply.\r\n\r\nIf customizations are made, the client's SDK namespace will follow the namespace decorated with `@client` or the namespace containing the interface decorated with `@client`. Similarly, the operation group's SDK namespace follows the same logic for `@operationGroup`. You can override this using `@clientNamespace` if needed.\r\n\r\nThe sequence of clients and operation groups is determined by the order of the `@client` and `@operationGroup` decorators.\r\n\r\nFor this section, we assume you have a service called `PetStore` in the `PetStore` namespace, defining two operations: `feed` and `pet`.\n\n### Renaming the Client Name\n\nThis can be achieved with the augment decorator: `@clientName` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(PetStore, \"PetStoreGreatClient\");\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreGreatClient\r\n\r\nclient = PetStoreGreatClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreGreatClient client = new PetStoreGreatClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreGreatClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreGreatClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreGreatClient client = new PetStoreGreatClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming the Client Namespace\n\nThis can be achieved with the augment decorator: `@clientNamespace` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientNamespace(PetStore, \"PetStoreRenamed\");\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients\n\nTwo clients that separate the operations can be declared using the `@client` decorator from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient, PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetActionClient petActionClient = new PetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nimport { FoodClient, PetActionClient } from \"@azure/package-name\";\r\n\r\nconst client1 = new PetActionClient();\r\nconst client2 = new FoodClient();\r\nclient1.pet();\r\nclient2.feed();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed()\r\npetActionClient.pet()\r\n```\r\n\r\n</ClientTabs>\n\n### One Client and Two Operation Groups\n\nTwo clients that separate the operations can be declared using the `@client` decorator and the `@operationGroup` decorator from `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@client({\r\n  name: \"PetStoreClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@operationGroup\r\ninterface OpGrp1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@operationGroup\r\ninterface OpGrp2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\n\r\nclient.op_grp_1.feed()\r\nclient.op_grp_2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\n\r\nclient.GetOpGrp1Client().Feed();\r\nclient.GetOpGrp2Client().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.opGrp1.feed();\r\nclient.opGrp2.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nOpGrp1Client opGrp1Client = builder.buildOpGrp1Client();\r\nopGrp1Client.feed();\r\n\r\nOpGrp2Client opGrp2Client = builder.buildOpGrp2Client();\r\nopGrp2Client.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Sub-Namespaces\n\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace NewPetStore;\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\nnamespace Food {\r\n  op feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetAction {\r\n  op pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom new_pet_store.food import FoodClient\r\nfrom new_pet_store.pet_action import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport newpetstore.food.FoodClient;\r\nimport newpetstore.food.FoodClientBuilder;\r\nimport newpetstore.petaction.PetActionClient;\r\nimport newpetstore.petaction.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nfoodClient.feed();\r\n\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients and Having Clients in Different Namespaces\n\nTwo clients that separate the operations can be declared using the `client` decorator of `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\n@clientNamespace(\"PetStoreRenamed.SubNamespace\") // use @clientNamespace to specify the namespace of the client\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient\r\nfrom pet_store_renamed.sub_namespace import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\nusing PetStoreRenamed.SubNamespace;\r\n\r\nSubNamespacePetActionClient petActionClient = new SubNamespacePetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport petstorerenamed.FoodClient;\r\nimport petstorerenamed.FoodClientBuilder;\r\nimport petstorerenamed.subnamespace.PetActionClient;\r\nimport petstorerenamed.subnamespace.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Adding Client Initialization Parameters\n\nBy default, we only generate our clients with initialization parameters for `endpoint`, `credential`, and `apiVersion`, whenever any of these are applicable.\r\nThere are cases where spec authors would like their clients to have additional input parameters.\r\n\r\nWith `@clientInitialization`, you can pass in additional parameters you would like your client to have, by passing in `parameters` option of a model.\r\nAll properties of the model will be appended to the current default list of client initialization parameters.\r\nAdditionally, these client parameters will no longer appear on service methods that previously had them as part of the method signature.\r\nThe generated code will automatically pass in the inputted value from the client init to the service.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob_name=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\n\nStorage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\r\n\r\nIf you want to rename the parameter name that you elevate to the client level, you can use the `@paramAlias` decorator.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  @paramAlias(\"blobName\")\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blob(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\n\n### Change Operation Group Initialization Way\n\nBy default, all the nested operation group could only be initialized by parent client or operation group.\r\nThere are cases where spec authors would like their operation groups could both be initialized by parent as well as individually.\r\n\r\nWith `@clientInitialization`, you can change the initialization way, by passing in `initializedBy` option of `InitializedBy.individually | InitializedBy.parent` value.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    initializedBy: InitializedBy.individually | InitializedBy.parent,\r\n  }\r\n);\r\n```\r\n\r\n```python\n\n# TODO\n\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n", "latency": 14.02525019645691, "response_length": 549}
{"query": "What are your thoughts on using TypeSpec to generate bicep modules from tsp definitions for the Azure Verified Modules project?", "ground_truth": "Using TypeSpec to generate bicep modules from tsp definitions for the Azure Verified Modules project is seen as a viable approach, with discussions around the need for a custom Bicep emitter and potential collaboration with the ARM and portal teams who have experience in similar endeavors. The involvement of experts and documentation is highlighted as essential for success.", "response": "Using TypeSpec to generate Bicep modules for the Azure Verified Modules project is a promising approach. TypeSpec is designed to define APIs and generate artifacts like OpenAPI specs, SDKs, and other outputs. By leveraging TypeSpec's extensibility, you could define Azure resources and their configurations in TypeSpec and emit Bicep modules as part of the output. This approach aligns with the goals of the Azure Verified Modules project, which aims to ensure consistency, compliance, and reusability of Azure resource definitions. However, this would require creating or using an existing TypeSpec emitter tailored for Bicep generation. Additionally, you would need to ensure that the generated Bicep modules adhere to Azure's best practices and guidelines for Verified Modules.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: intro.md\n- document_title: Introduction\n- document_link: https://azure.github.io/typespec-azure/docs/intro\n- document_content: # intro.md\n\n# Introduction\n\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\r\n\r\nYou can find more information at https://typespec.io/docs.\r\n\r\nThis site is focused on using TypeSpec in the context of Azure. We have published a set of libraries with standard patterns and templates to make defining Azure management and data-plane services easy and compliant with Azure API guidelines. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\n\n# TypeSpec Azure Libraries\n\n## Packages\n\n| ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\r\n\r\n[typespec-autorest_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest\r\n[typespec-autorest_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest/CHANGELOG.md\r\n[typespec-azure-core_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core\r\n[typespec-azure-core_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core/CHANGELOG.md\r\n[typespec-azure-resource-manager_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager\r\n[typespec-azure-resource-manager_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/CHANGELOG.md\r\n\r\n`@next` version of the package are the latest versions available on the `main` branch.\n\n| Name                                                                          | Type    | Changelog                                        | Latest                                                                                                                                                       | Next                                                                              |\r\n| ----------------------------------------------------------------------------- | ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |\r\n| [@azure-tools/typespec-azure-core][typespec-azure-core_src]                   | Library | [Changelog][typespec-azure-core_chg]             | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-core)](https://www.npmjs.com/package/@azure-tools/typespec-azure-core)                         | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-core/next)             |\r\n| [@azure-tools/typespec-resource-manager][typespec-azure-resource-manager_src] | Library | [Changelog][typespec-azure-resource-manager_chg] | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-resource-manager)](https://www.npmjs.com/package/@azure-tools/typespec-azure-resource-manager) | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\n\n### Package Layering\n\nThe main packages in this repository can be considered a series of layers which progressively add functionality\r\nfor specific scenarios:\r\n\r\n- [**@azure-tools/typespec-azure-core:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core) Provides core models and interfaces for Azure service modelling\r\n- [**@azure-tools/typespec-azure-resource-manager:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager) Provides additional models and interfaces for modelling Azure Resource Manager services\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](./typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n", "latency": 31.533796072006226, "response_length": 780}
{"query": "Would anyone be interested in exploring the generation of bicep modules from tsp definitions for the Azure Verified Modules project or know someone who would?", "ground_truth": "There is interest in exploring the generation of bicep modules from tsp definitions for the Azure Verified Modules project, with suggestions for collaboration and inquiries about the availability of someone to write a Bicep emitter.", "response": "Generating Bicep modules from TypeSpec (TSP) definitions for the Azure Verified Modules project could be an interesting area to explore. TypeSpec provides a declarative way to define APIs and resources, and its extensibility could potentially be leveraged to generate Bicep modules. This would align well with Azure's focus on simplifying resource management and deployment. If you are looking for collaborators or experts in this area, you might consider reaching out to the TypeSpec community on their [Discord server](https://aka.ms/typespec/discord) or engaging with the TypeSpec team through their GitHub discussions. Additionally, exploring the TypeSpec documentation and its integration with Azure tools could provide insights into how this could be implemented.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#08-conclusion.md\n- document_title: Conclusion\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/08-conclusion\n- document_content: # getting-started#getting-started-rest#08-conclusion.md\n\n# Conclusion\n\n## Recap of Key Concepts\n\nThroughout this tutorial, we've covered a wide range of topics to help you build a comprehensive REST API using TypeSpec. Here's a brief recap of the main concepts we explored:\r\n\r\n- **Setting Up the Environment**: We started by setting up the development environment and installing the necessary tools.\r\n- **Defining Models and Services**: We learned how to define models and services using TypeSpec.\r\n- **Creating and Organizing Namespaces**: We organized our API using namespaces to group related models and operations.\r\n- **Defining HTTP Operations**: We defined various HTTP operations, including GET, POST, PUT, and DELETE.\r\n- **Handling Errors**: We created error models to handle different types of errors.\r\n- **Reusing Common Parameters**: We defined common parameters and reused them across multiple operations.\r\n- **Adding Authentication**: We enforced authentication on specific operations using the `@useAuth` decorator.\r\n- **Implementing Versioning**: We implemented versioning in our API using the `@versioned` and `@added` decorators.\r\n- **Creating Custom Response Models**: We created custom response models to reduce duplication and improve readability.\n\n## Further Resources\n\nTo continue learning and exploring TypeSpec, here are some additional resources:\r\n\r\n- [TypeSpec Documentation](https://typespec.io/docs): The official documentation provides detailed information on TypeSpec features and usage.\r\n- [TypeSpec GitHub Repository](https://github.com/microsoft/typespec): The GitHub repository contains the source code and examples.\r\n- [TypeSpec Discord Server](https://aka.ms/typespec/discord): Join the TypeSpec Discord server to participate in discussions, ask questions, and connect with the community.\n\n## Feedback and Community Engagement\n\nWe value your feedback and would love to hear about your experiences with this tutorial. Please feel free to share your thoughts and suggestions in our [GitHub discussions channel](https://github.com/microsoft/typespec/discussions).\r\n\r\nJoin the TypeSpec community on [Discord](https://aka.ms/typespec/discord) to engage with other developers, ask questions, and contribute to discussions. Your participation helps us improve and grow the TypeSpec ecosystem.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#azure-portal#default-experiences.md\n- document_title: Generating experiences in Azure Portal with TypeSpec\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/azure-portal/default-experiences\n- document_content: # howtos#azure-portal#default-experiences.md\n\n# Generating experiences in Azure Portal with TypeSpec\n\nGo to the [TypeSpec guide](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/typespec) to learn how to customize your Azure Portal experience, generated by default for your ARM resource type. Azure Resource Providers can apply TypeSpec decorators to generate and brand Azure Portal experiences.\r\n\r\n![ts6 (1)](https://github.com/user-attachments/assets/ba080602-0edb-4317-bcae-7dffce687a80)\n\n## About Default Experiences\n\nparams)      |\r\n| > Tabs:                       | Get Started template, Properties, Monitoring, Recommendations                     |\r\n| > Essentials                  | _Enable essentials control_                                                       |\r\n| **Resource Menu**             |                                                                                   |\r\n| > Standard Framework Options: | Support + Troubleshooting, Activity Log, IAM, Tags, Monitoring, Diagnostics, etc. |\r\n| > Properties view             | _Enable properties view for resource_                                             |\r\n| > CLI / PS view               | _Enable CLI / PS view for resource_                                               |\r\n| > Child Browse views          | _View child resources in menu_                                                    |\r\n\r\n![alt-text](https://github.com/Azure/portaldocs/raw/main/portal-sdk/media/top-extensions-autogeneration/GeneratedOverviewTabs.jpg \"Overview blade breakdown\")\n\nAzure Portal generates end-to-end experiences automatically, providing Resource Providers with immediate UX in Azure Portal for their resource types. This pipeline runs offline and generates views and an asset for your resource type. These generated experiences done by Azure Portal based on resource type metadata are called \"Default Experiences\". Leveraging TypeSpec affords Resource Providers with an easy, declarative way of branding and promoting these experiences, as the generated default experience is hidden by default. [Learn more](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/generated)\r\n\r\n#### Default experiences include:\r\n\r\n| **Browse + Management**       |                                                                                   |\r\n| ----------------------------- | --------------------------------------------------------------------------------- |\r\n| > Global Search               | _Discover resource instances and browse view through search_                      |\r\n| > All Resources               | _Discover resource instances in All Resources and launch Overview UX_             |\r\n| > Browse                      | _Browse and manage resource instances in standard browse view_                    |\r\n| **Overview UX**               |                                                                                   |\r\n| > Commands:                   | Refresh, Delete, Create, Open in mobile, CMD by REST-API-SPEC (w/out params)      |\r\n| > Tabs:                       | Get Started template, Properties, Monitoring, Recommendations                     |\r\n| > Essentials                  | _Enable essentials control_                                                       |\r\n| **Resource Menu**             |                                                                                   |\r\n| > Standard Framework Options: | Support + Troubleshooting, Activity Log, IAM, Tags, Monitoring, Diagnostics, etc. |\r\n|\n\n## Promoting generated experiences to production\n\nSee [Promoting Default Experiences](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/promotion) to learn how to promote your default generated Portal experience using\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n", "latency": 14.114636421203613, "response_length": 769}
{"query": "Is there interest in starting the exploration of generating bicep modules for the Azure Verified Modules project sooner than the Hackathon in September?", "ground_truth": "There is interest in starting the exploration of generating bicep modules for the Azure Verified Modules project before the Hackathon in September, indicating a proactive approach to the project.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#createproject.md\n- document_title: Creating a project\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/createproject\n- document_content: # getstarted#createproject.md\n\n# Creating a project\n\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\r\n\r\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\r\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n3. To create a new Azure service specification, use the `tsp init` command:\r\n\r\n```bash\r\ntsp init https://aka.ms/typespec/azure-init\r\n```\r\n\r\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\n\n### Understanding Project Templates\n\nWhen initializing a new project, you'll encounter four templates:\r\n\r\n| Template Name                                                   | Description                                                                                                                                                                          |\r\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| **(rest-api-spec repo) Azure Data Plane Service Project**       | This template is configured for projects within the `azure-rest-api-specs` repository, with settings that comply with the repo's requirements, such as file paths and linting rules. |\r\n| **(rest-api-spec repo) Azure Resource Manager Service Project** | Similar to the above, but tailored for Azure Resource Manager services within the `azure-rest-api-specs` repository.                                                                 |\r\n| **(standalone) Azure Data Plane Service Project**               | This template is configured for local use or in a personal repo, allowing for API development without the specific directory structure of the `azure-rest-api-specs` repo.           |\r\n| **(standalone) Azure Resource Manager Service Project**         | Similar to the above but designed for Azure Resource Manager services, configured for local use or in a personal repo.                                                               |\n\n### Target Users\n\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\r\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\n\n### Install the dependencies\n\nNow that the new project has been created, you can install the dependencies by running the following command:\r\n\r\n- `npm ci` - If in the `azure-rest-api-specs` repo.\r\n- `tsp install` - If a standalone project\r\n\r\nAfter setting up your project, run `tsp install` to install dependencies. You can then open the file `main.tsp` to continue with the tutorial. Choose the tutorial that matches your chosen project template:\r\n\r\n| Azure Service Type       | Tutorial                                      | Produces                   |\r\n| ------------------------ | --------------------------------------------- | -------------------------- |\r\n| Azure Data-Plane Service | [Azure-Core tutorial](azure-core/step01)      | OpenApi 2.0 (Swagger) spec |\r\n| Azure Management Service | [ARM tutorial](azure-resource-manager/step00) | OpenApi 2.0 (Swagger) spec |\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#00howtogen.mdx\n- document_title: How to generate client libraries\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/00howtogen\n- document_content: # howtos#generate-client-libraries#00howtogen.mdx\n\n# How to generate client libraries\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page outlines the steps to build a client library based on your TypeSpec specification. It provides a guide for the whole process from initial API design to the release of SDKs. please visit https://aka.ms/azsdk/dpcodegen.\r\n\r\nThe best documentation on how to generate can be found using those links:\r\n\r\n- https://aka.ms/azsdk/dpcodegen/net\r\n- https://aka.ms/azsdk/dpcodegen/python\r\n- https://aka.ms/azsdk/dpcodegen/java\r\n- https://aka.ms/azsdk/rlc/js\r\n- https://aka.ms/azsdk/dpcodegen/js (do not use unless told to do so by the archboard)\r\n\r\nAt a glance, add your emitter name to your `package.json`, along with the right options in the `tspconfig.yaml`.\r\n\r\n> **NOTE:** Generating all languages from the same folder may be complicated due to the preview status of the emitters and TypeSpec libraries, such as `typespec-azure-core` and `typespec-azure-resource-manager`.\r\n> It is recommended to have a unique language emitter in each `package.json` to avoid conflicts until all emitters and the TypeSpec libraries reach their first stable release.\r\n\r\nModify your `package.json` to include the necessary dependencies for the language emitter(s). Remember to run `npm install` after making changes to the file:\r\n\r\n```json\r\n{\r\n  \"name\": \"clients\",\r\n  \"dependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/rest\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@azure-tools/typespec-azure-core\": \"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\n\n\"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\r\n  # add \"@azure-tools/typespec-python\" to your package.json to generate Python code\r\n  - \"@azure-tools/typespec-python\"\r\n  # add \"@azure-tools/typespec-java\" to your package.json to generate Java code\r\n  - \"@azure-tools/typespec-java\"\r\n  # add \"@azure-tools/typespec-csharp\" to your package.json to generate C# code\r\n  - \"@azure-tools/typespec-csharp\"\r\n  # add \"@azure-tools/typespec-ts\" to your package.json to generate Typescript code\r\n  - \"@azure-tools/typespec-ts\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-java\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-csharp\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-ts\":\r\n    flavor: azure\r\n```\r\n\r\nSeveral language repositories utilize the `tsp-client` tool to simplify generating client libraries. For more information on the tool, see [Getting started with `tsp-client`](<./../Generating with tsp-client/tsp_client.md>).\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#x-ms-examples.mdx\n- document_title: x-ms-examples example files\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\n- document_content: # migrate-swagger#faq#x-ms-examples.mdx\n\n# x-ms-examples example files\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe `x-ms-examples` is automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter.\r\nThe examples must be placed in the `examples-directory` (default to `{project-root}/examples`) and have the `operationdId` property.\r\n\r\n:::caution\r\nDo not use `@extension(\"x-ms-examples\", \"<value>\")`.\r\n:::\n\n## Example structure\n\nExample below assume `example-directory` is `{project-root}/examples`.\r\n\r\n- Single version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - example1.json\r\n  - example2.json\r\n</FileTree>\r\n\r\n- Multi version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - 2021-01-01/\r\n    - example1.json\r\n    - example2.json\r\n  - 2021-01-02/\r\n    - example1.json\r\n    - example2.json\r\n</FileTree>\n\n## Generate the examples\n\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\r\n\r\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\r\n\r\n```bash\r\noav generate-examples openapi.json\r\n```\r\n\r\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\r\n\r\n- include `title` field and make sure it is descriptive and unique for each operation.\r\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\r\n\r\n:::caution\r\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\r\n:::\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step12.md\n- document_title: Advanced Topics\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step12\n- document_content: # getstarted#azure-core#step12.md\n\n# Advanced Topics\n\nOnce you have written your first service with `Azure.Core`, you might be interested to try the following features:\n\n## Defining singleton resources\n\nYou can define a singleton resource (a resource type with only one instance) by using a string literal for the key type. Imagine we want to expose an analytics endpoint for each `Widget` instance. Here's what it would look like:\r\n\r\n```typespec\r\n@resource(\"analytics\")\r\n@parentResource(Widget)\r\nmodel WidgetAnalytics {\r\n  @key(\"analyticsId\")\r\n  id: \"current\";\r\n\r\n  /** The number of uses of the widget. */\r\n  useCount: int64;\r\n\r\n  /** The number of times the widget was repaired. */\r\n  repairCount: int64;\r\n}\r\n```\r\n\r\nYou can then use the standard operation signatures with this singleton resource type:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n\r\nop getAnalytics is Operations.ResourceRead<WidgetAnalytics>;\r\nop updateAnalytics is Operations.ResourceCreateOrUpdate<WidgetAnalytics>;\r\n```\r\n\r\nBy using a literal value of `\"current\"` for `\"id\"`, the route path for these operations will be the following:\r\n\r\n```\r\n\"/widgets/{widgetName}/analytics/current\"\r\n```\r\n\r\nThe operations defined against this singleton resource will also exclude the key parameter because it cannot be changed.\n", "latency": 4.798306226730347, "response_length": 79}
{"query": "What hurdles did the AVM team encounter that led them to manually create the bicep modules?", "ground_truth": "The AVM team encountered hurdles that led them to manually create the bicep modules, though specific challenges are not detailed in the provided information.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#reference#data-types.md\n- document_title: Data types\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types\n- document_content: # libraries#azure-core#reference#data-types.md\n\n# Data types\n\n## Azure.Core\n\n### `AadOauth2Auth` {#Azure.Core.AadOauth2Auth}\n\nAzure Active Directory OAuth2 Flow\r\n\r\n```typespec\r\nmodel Azure.Core.AadOauth2Auth<Scopes, AuthUrl, TokenUrl>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                            |\r\n| -------- | -------------------------------------- |\r\n| Scopes   | A list of scopes the token applies to. |\r\n| AuthUrl  | The authorization URL.                 |\r\n| TokenUrl | The token URL.                         |\r\n\r\n#### Properties\r\n\r\n| Name          | Type                                                 | Description                                                                    |\r\n| ------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| type          | `TypeSpec.Http.AuthType.oauth2`                      | OAuth2 authentication                                                          |\r\n| flows         | `[Core.AadTokenAuthFlow<Scopes, AuthUrl, TokenUrl>]` | Supported OAuth2 flows                                                         |\r\n| defaultScopes | `[]`                                                 | Oauth2 scopes of every flow. Overridden by scope definitions in specific flows |\n\n### `AadTokenAuthFlow` {#Azure.Core.AadTokenAuthFlow}\n\nAzure Active Directory (AAD) Token Authentication Flow\r\n\r\n```typespec\r\nmodel Azure.Core.AadTokenAuthFlow<Scopes, AuthUrl, TokenUrl>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                            |\r\n| -------- | -------------------------------------- |\r\n| Scopes   | A list of scopes the token applies to. |\r\n| AuthUrl  | The authorization URL.                 |\r\n| TokenUrl | The token URL.                         |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                             | Description |\r\n| ---------------- | ------------------------------------------------ | ----------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.authorizationCode` |             |\r\n| authorizationUrl | `AuthUrl`                                        |             |\r\n| tokenUrl         | `TokenUrl`                                       |             |\r\n| scopes           | `Scopes`                                         |             |\n\n### `ArmResourceIdentifierAllowedResource` {#Azure.Core.ArmResourceIdentifierAllowedResource}\n\n```typespec\r\nmodel Azure.Core.ArmResourceIdentifierAllowedResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name    | Type                                             | Description                                                                                                                                                                          |\r\n| ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| type    | [`armResourceType`](#Azure.Core.armResourceType) | The type of resource that is being referred to. For example Microsoft.Network/virtualNetworks or Microsoft.Network/virtualNetworks/subnets. See Example Types for more examples.     |\r\n| scopes? | `Core.ArmResourceDeploymentScope[]`              | An array of scopes. If not specified, the default scope is [\"ResourceGroup\"].<br />See [Allowed Scopes](https://github.com/Azure/autorest/tree/main/docs/extensions#allowed-scopes). |\n\n### `AzureApiKeyAuthentication` {#Azure.Core.AzureApiKeyAuthentication}\n\nAzure API Key Authentication using the \"Ocp-Apim-Subscription-Key\" hea\r\n\r\n```typespec\r\nmodel Azure.Core.AzureApiKeyAuthentication\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                                  | Description             |\r\n| ---- | ------------------------------------- | ----------------------- |\r\n| type | `TypeSpec.Http.AuthType.apiKey`       | API key authentication  |\r\n| in   | `TypeSpec.Http.ApiKeyLocation.header` | location of the API key |\r\n| name | `\"Ocp-Apim-Subscription-Key\"`         | name of the API key     |\n\n### `ClientRequestIdHeader` {#Azure.Core.ClientRequestIdHeader}\n\nProvides the 'x-ms-client-request-id' header to enable request correlation in requests and responses.\r\n\r\n```typespec\r\nmodel Azure.Core.ClientRequestIdHeader\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                       | Description                                                                     |\r\n| ---------------- | -------------------------- | ------------------------------------------------------------------------------- |\r\n| clientRequestId? | [`uuid`](#Azure.Core.uuid) | An opaque, globally-unique, client-generated string identifier for the request. |\n\n### `ConditionalRequestHeaders` {#Azure.Core.ConditionalRequestHeaders}\n\nProvides the 'If-\\*' headers to enable conditional (cached) responses\r\n\r\n```typespec\r\nmodel Azure.Core.ConditionalRequestHeaders\r\n```\r\n\r\n#### Properties\r\n\r\n| Name               | Type          | Description                                                                     |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------- |\r\n| ifMatch?           | `string`      | The request should only proceed if an entity matches this string.               |\r\n| ifNoneMatch?       | `string`      | The request should only proceed if no entity matches this string.               |\r\n| ifUnmodifiedSince? | `utcDateTime` | The request should only proceed if the entity was not modified after this time. |\r\n| ifModifiedSince?   | `utcDateTime` | The request should only proceed if the entity was modified after this time.     |\n\n### `EmbeddingVector` {#Azure.Core.EmbeddingVector}\n\nA vector embedding frequently used in similarity search.\r\n\r\n```typespec\r\nmodel Azure.Core.EmbeddingVector<Element>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description                               |\r\n| ------- | ----------------------------------------- |\r\n| Element | The element type of the embedding vector. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `EtagProperty` {#Azure.Core.EtagProperty}\n\nProvides the 'ETag' field to enable conditional (cached) requests. This model can be spread\r\ninto responses and item models to convey the ETag when it cannot simply conveyed in a header.\r\n\r\n```typespec\r\nmodel Azure.Core.EtagProperty\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                       | Description                       |\r\n| ---- | -------------------------- | --------------------------------- |\r\n| etag | [`eTag`](#Azure.Core.eTag) | The entity tag for this resource. |\n\n### `EtagResponseEnvelope` {#Azure.Core.EtagResponseEnvelope}\n\nProvides the 'ETag' header to enable conditional (cached) requests\r\n\r\n```typespec\r\nmodel Azure.Core.EtagResponseEnvelope\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type     | Description                      |\r\n| ----------- | -------- | -------------------------------- |\r\n| etagHeader? | `string` | The entity tag for the response. |\n\n### `ExpandQueryParameter` {#Azure.Core.ExpandQueryParameter}\n\nProvides the standard 'expand' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.ExpandQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name    | Type       | Description                                       |\r\n| ------- | ---------- | ------------------------------------------------- |\r\n| expand? | `string[]` | Expand the indicated resources into the response. |\n\n### `FilterParameter` {#Azure.Core.FilterParameter}\n\nProvides the standard 'filter' query parameter for list operations\r\n\r\n```typespec\r\nmodel Azure.Core.FilterParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name    | Type     | Description                                  |\r\n| ------- | -------- | -------------------------------------------- |\r\n| filter? | `string` | The maximum number of result items per page. |\n\n### `FilterQueryParameter` {#Azure.Core.FilterQueryParameter}\n\nProvides the standard 'filter' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.FilterQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name    | Type     | Description                                        |\r\n| ------- | -------- | -------------------------------------------------- |\r\n| filter? | `string` | Filter the result list using the given expression. |\n\n### `MaxPageSizeQueryParameter` {#Azure.Core.MaxPageSizeQueryParameter}\n\nProvides the standard 'maxpagesize' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.MaxPageSizeQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name         | Type    | Description                                  |\r\n| ------------ | ------- | -------------------------------------------- |\r\n| maxpagesize? | `int32` | The maximum number of result items per page. |\n\n### `OrderByQueryParameter` {#Azure.Core.OrderByQueryParameter}\n\nProvides the standard 'orderby' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.OrderByQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type       | Description                                             |\r\n| -------- | ---------- | ------------------------------------------------------- |\r\n| orderby? | `string[]` | Expressions that specify the order of returned results. |\n\n### `Page` {#Azure.Core.Page}\n\nDescribes a page of resource object.\r\n\r\n```typespec\r\nmodel Azure.Core.Page<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description        |\r\n| -------- | ------------------ |\r\n| Resource | The resource type. |\r\n\r\n#### Properties\r\n\r\n| Name      | Type                             | Description |\r\n| --------- | -------------------------------- | ----------- |\r\n| value     | `Array<Element>`                 |             |\r\n| nextLink? | `TypeSpec.Rest.ResourceLocation` |             |\n\n### `PollingOptions` {#Azure.Core.PollingOptions}\n\nGeneric polling options for LRO operations.\r\n\r\n```typespec\r\nmodel Azure.Core.PollingOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name          | Type                                                                | Description                                                     |\r\n| ------------- | ------------------------------------------------------------------- | --------------------------------------------------------------- |\r\n| kind          | [`PollingOptionKind`](./data-types.md#Azure.Core.PollingOptionKind) | The kind of polling options                                     |\r\n| pollingModel? | `Model \\| void`                                                     | The model that is returned when polling should continue.        |\r\n| finalResult?  | `Model \\| void`                                                     | The type that is returned when polling terminates successfully. |\n\n### `RepeatabilityRequestHeaders` {#Azure.Core.RepeatabilityRequestHeaders}\n\nProvides the 'Repeatability-\\*' headers to enable repeatable requests.\r\n\r\n```typespec\r\nmodel Azure.Core.RepeatabilityRequestHeaders\r\n```\r\n\r\n#### Properties\r\n\r\n| Name                    | Type          | Description                                                                     |\r\n| ----------------------- | ------------- | ------------------------------------------------------------------------------- |\r\n| repeatabilityRequestId? | `string`      | An opaque, globally-unique, client-generated string identifier for the request. |\r\n| repeatabilityFirstSent? | `utcDateTime` | Specifies the date and time at which the request was first created.             |\n\n### `RepeatabilityResponseHeaders` {#Azure.Core.RepeatabilityResponseHeaders}\n\nProvides the 'Repeatability-\\*' headers to enable repeatable requests.\r\n\r\n```typespec\r\nmodel Azure.Core.RepeatabilityResponseHeaders\r\n```\r\n\r\n#### Properties\r\n\r\n| Name                 | Type                                                                    | Description                                                        |\r\n| -------------------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------ |\r\n| repeatabilityResult? | [`RepeatabilityResult`](./data-types.md#Azure.Core.RepeatabilityResult) | Indicates whether the repeatable request was accepted or rejected. |\n\n### `RequestIdResponseHeader` {#Azure.Core.RequestIdResponseHeader}\n\nProvides the 'x-ms-request-id' header to enable request correlation in responses.\r\n\r\n```typespec\r\nmodel Azure.Core.RequestIdResponseHeader\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type                       | Description                                                                     |\r\n| ---------- | -------------------------- | ------------------------------------------------------------------------------- |\r\n| requestId? | [`uuid`](#Azure.Core.uuid) | An opaque, globally-unique, server-generated string identifier for the request. |\n\n### `RequestParameter` {#Azure.Core.RequestParameter}\n\nDefines a property as a request parameter.\r\n\r\n```typespec\r\nmodel Azure.Core.RequestParameter<Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description         |\r\n| ---- | ------------------- |\r\n| Name | The parameter name. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `ResourceOperationStatus` {#Azure.Core.ResourceOperationStatus}\n\n```typespec\r\nmodel Azure.Core.ResourceOperationStatus<Resource, StatusResult, StatusError>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                                                                       |\r\n| ------------ | ------------------------------------------------------------------------------------------------- |\r\n| Resource     | The resource type.                                                                                |\r\n| StatusResult | Model describing the status result object. If not specified, the default is the resource type.    |\r\n| StatusError  | Model describing the status error object. If not specified, the default is the Foundations.Error. |\r\n\r\n#### Properties\r\n\r\n| Name    | Type                                                                      | Description |\r\n| ------- | ------------------------------------------------------------------------- | ----------- |\r\n| id      | `string`                                                                  |             |\r\n| status  | [`OperationState`](./data-types.md#Azure.Core.Foundations.OperationState) |             |\r\n| error?  | `StatusError`                                                             |             |\r\n| result? | `StatusResult`                                                            |             |\n\n### `ResponseProperty` {#Azure.Core.ResponseProperty}\n\nDefines a property as a response header.\r\n\r\n```typespec\r\nmodel Azure.Core.ResponseProperty<Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description      |\r\n| ---- | ---------------- |\r\n| Name | The header name. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `SelectQueryParameter` {#Azure.Core.SelectQueryParameter}\n\nProvides the standard 'select' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.SelectQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name    | Type       | Description                                                 |\r\n| ------- | ---------- | ----------------------------------------------------------- |\r\n| select? | `string[]` | Select the specified fields to be included in the response. |\n\n### `SkipQueryParameter` {#Azure.Core.SkipQueryParameter}\n\nProvides the standard 'skip' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.SkipQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type    | Description                         |\r\n| ----- | ------- | ----------------------------------- |\r\n| skip? | `int32` | The number of result items to skip. |\n\n### `StandardListQueryParameters` {#Azure.Core.StandardListQueryParameters}\n\nProvides the most common query parameters for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.StandardListQueryParameters\r\n```\r\n\r\n#### Properties\r\n\r\n| Name         | Type    | Description                                  |\r\n| ------------ | ------- | -------------------------------------------- |\r\n| top?         | `int32` | The number of result items to return.        |\r\n| skip?        | `int32` | The number of result items to skip.          |\r\n| maxpagesize? | `int32` | The maximum number of result items per page. |\n\n### `StatusMonitorOptions` {#Azure.Core.StatusMonitorOptions}\n\nOptions for Lro status monitors.\r\n\r\n```typespec\r\nmodel Azure.Core.StatusMonitorOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name           | Type                      | Description                                                                             |\r\n| -------------- | ------------------------- | --------------------------------------------------------------------------------------- |\r\n| kind           | `\"statusMonitor\"`         | The kind of polling options                                                             |\r\n| finalProperty? | `ModelProperty \\| string` | A reference to or name of the property of the status monitor that contains the response |\n\n### `StatusMonitorPollingOptions` {#Azure.Core.StatusMonitorPollingOptions}\n\nOptions for overriding a polling endpoint that uses a StatusMonitor\r\n\r\n```typespec\r\nmodel Azure.Core.StatusMonitorPollingOptions<PollingModel, FinalResult, FinalProperty>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name          | Description                                                      |\r\n| ------------- | ---------------------------------------------------------------- |\r\n| PollingModel  | The model that is returned when polling should continue.         |\r\n| FinalResult   | The model that is returned when polling terminates successfully. |\r\n| FinalProperty | The property of the status monitor that contains results.        |\r\n\r\n#### Properties\r\n\r\n| Name          | Type              | Description                                                     |\r\n| ------------- | ----------------- | --------------------------------------------------------------- |\r\n| kind          | `\"statusMonitor\"` | The kind of polling options                                     |\r\n| pollingModel  | `PollingModel`    | The model that is returned when polling should continue         |\r\n| finalResult   | `FinalResult`     | The model that is returned when polling terminates successfully |\r\n| finalProperty | `FinalProperty`   | The property of the status monitor that contains results        |\n\n### `TopQueryParameter` {#Azure.Core.TopQueryParameter}\n\nProvides the standard 'top' query parameter for list operations.\r\n\r\n```typespec\r\nmodel Azure.Core.TopQueryParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type    | Description                           |\r\n| ---- | ------- | ------------------------------------- |\r\n| top? | `int32` | The number of result items to return. |\n\n### `Versions` {#Azure.Core.Versions}\n\nSupported versions of Azure.Core TypeSpec building blocks.\r\n\r\n```typespec\r\nenum Azure.Core.Versions\r\n```\r\n\r\n| Name           | Value             | Description           |\r\n| -------------- | ----------------- | --------------------- |\r\n| v1_0_Preview_1 | `\"1.0-preview.1\"` | Version 1.0-preview.1 |\r\n| v1_0_Preview_2 | `\"1.0-preview.2\"` | Version 1.0-preview.2 |\n\n### `ArmResourceDeploymentScope` {#Azure.Core.ArmResourceDeploymentScope}\n\n```typespec\r\nunion Azure.Core.ArmResourceDeploymentScope\r\n```\n\n### `PollingOptionKind` {#Azure.Core.PollingOptionKind}\n\nThe available kinds of polling options\r\n\r\n```typespec\r\nunion Azure.Core.PollingOptionKind\r\n```\n\n### `RepeatabilityResult` {#Azure.Core.RepeatabilityResult}\n\nRepeatability Result header options\r\n\r\n```typespec\r\nunion Azure.Core.RepeatabilityResult\r\n```\n\n### `armResourceIdentifier` {#Azure.Core.armResourceIdentifier}\n\nA type definition that refers the id to an Azure Resource Manager resource.\r\n\r\n```typespec\r\nscalar Azure.Core.armResourceIdentifier\r\n```\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel MyModel {\r\n  otherArmId: armResourceIdentifier;\r\n  networkId: armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/vnet\";\r\n    }\r\n  ]>;\r\n  vmIds: armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Compute/vm\";\r\n      scopes: [\"*\"];\r\n    }\r\n  ]>;\r\n  scoped: armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Compute/vm\";\r\n      scopes: [\"tenant\", \"resourceGroup\"];\r\n    }\r\n  ]>;\r\n}\r\n```\n\n### `armResourceType` {#Azure.Core.armResourceType}\n\nRepresents an Azure Resource Type.\r\n\r\n```typespec\r\nscalar Azure.Core.armResourceType\r\n```\r\n\r\n#### Examples\r\n\r\n```\r\nMicrosoft.Network/virtualNetworks/subnets\r\n```\n\n### `azureLocation` {#Azure.Core.azureLocation}\n\nRepresents an Azure geography region where supported resource providers live.\r\n\r\n```typespec\r\nscalar Azure.Core.azureLocation\r\n```\r\n\r\n#### Examples\r\n\r\n```\r\nWestUS\r\n```\n\n### `eTag` {#Azure.Core.eTag}\n\nThe ETag (or entity tag) HTTP response header is an identifier for a specific version of a resource.\r\nIt lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content was not changed.\r\n\r\nIt is a string of ASCII characters placed between double quotes, like \"675af34563dc-tr34\".\r\n\r\n```typespec\r\nscalar Azure.Core.eTag\r\n```\r\n\r\n#### Examples\r\n\r\n##### In `ETag` header\r\n\r\n```\r\nETag: \"675af34563dc-tr34\"\r\n```\n\n### `ipV4Address` {#Azure.Core.ipV4Address}\n\nRepresent an IP V4 address serialized as a string.\r\n\r\nIt is formatted as four 8-bit fields separated by periods.\r\n\r\n```typespec\r\nscalar Azure.Core.ipV4Address\r\n```\r\n\r\n#### Examples\r\n\r\n```\r\n129.144.50.56\r\n```\n\n### `ipV6Address` {#Azure.Core.ipV6Address}\n\nRepresent an IP V6 address serialized as a string.\r\n\r\nIt is formatted as eight hex decimal values(16-bit) between 0 and FFFF separated by colon. (i.e. `y:y:y:y:y:y:y:y`)\r\n\r\n```typespec\r\nscalar Azure.Core.ipV6Address\r\n```\r\n\r\n#### Examples\r\n\r\n```\r\n2001:db8:3333:4444:CCCC:DDDD:EEEE:FFFF\r\n```\n\n### `uuid` {#Azure.Core.uuid}\n\nUniversally Unique Identifier\r\n\r\n```typespec\r\nscalar Azure.Core.uuid\r\n```\r\n\r\n#### Examples\r\n\r\n```\r\n123e4567-e89b-12d3-a456-426614174000\r\n```\n\n## Azure.Core.Foundations\n\n### `ApiVersionParameter` {#Azure.Core.Foundations.ApiVersionParameter}\n\nThe ApiVersion query parameter.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.ApiVersionParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                |\r\n| ---------- | -------- | ------------------------------------------ |\r\n| apiVersion | `string` | The API version to use for this operation. |\n\n### `CollectionKeysOf` {#Azure.Core.Foundations.CollectionKeysOf}\n\nA model containing the collection keys of the provided resource's parent resource.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CollectionKeysOf<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description               |\r\n| -------- | ------------------------- |\r\n| Resource | The type of the resource. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `CreateableAndUpdateableProperties` {#Azure.Core.Foundations.CreateableAndUpdateableProperties}\n\nCollection of properties from a resource that are visible to create or update scopes.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CreateableAndUpdateableProperties<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description               |\r\n| -------- | ------------------------- |\r\n| Resource | The type of the resource. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `CustomizationFields` {#Azure.Core.Foundations.CustomizationFields}\n\nThe expected shape of model types passed to the Custom parameter of operation signatures.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CustomizationFields\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type | Description                                                                    |\r\n| ----------- | ---- | ------------------------------------------------------------------------------ |\r\n| parameters? | `{}` | An object containing custom parameters that will be included in the operation. |\r\n| response?   | `{}` | An object containing custom properties that will be included in the response.  |\n\n### `CustomPage` {#Azure.Core.Foundations.CustomPage}\n\nA model describing a customized page of resources.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CustomPage<Resource, Traits>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                     |\r\n| -------- | ------------------------------- |\r\n| Resource | The type of the resource.       |\r\n| Traits   | Traits which apply to the page. |\r\n\r\n#### Properties\r\n\r\n| Name      | Type                             | Description |\r\n| --------- | -------------------------------- | ----------- |\r\n| value     | `Array<Element>`                 |             |\r\n| nextLink? | `TypeSpec.Rest.ResourceLocation` |             |\n\n### `CustomParameters` {#Azure.Core.Foundations.CustomParameters}\n\nA model describing a set of custom request parameters.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CustomParameters<Custom>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                     |\r\n| ------ | ----------------------------------------------- |\r\n| Custom | An object describing custom request parameters. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `CustomResponseFields` {#Azure.Core.Foundations.CustomResponseFields}\n\nA model describing a set of custom response properties.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.CustomResponseFields<Custom>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                      |\r\n| ------ | ------------------------------------------------ |\r\n| Custom | An object describing custom response properties. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `Error` {#Azure.Core.Foundations.Error}\n\nThe error object.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.Error\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                                              | Description                                                                             |\r\n| ----------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------- |\r\n| code        | `string`                                                          | One of a server-defined set of error codes.                                             |\r\n| message     | `string`                                                          | A human-readable representation of the error.                                           |\r\n| target?     | `string`                                                          | The target of the error.                                                                |\r\n| details?    | `Core.Foundations.Error[]`                                        | An array of details about specific errors that led to this reported error.              |\r\n| innererror? | [`InnerError`](./data-types.md#Azure.Core.Foundations.InnerError) | An object containing more specific information than the current object about the error. |\n\n### `ErrorResponse` {#Azure.Core.Foundations.ErrorResponse}\n\nA response containing error details.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.ErrorResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type                                                    | Description                                   |\r\n| ---------- | ------------------------------------------------------- | --------------------------------------------- |\r\n| error      | [`Error`](./data-types.md#Azure.Core.Foundations.Error) | The error object.                             |\r\n| errorCode? | `string`                                                | String error code indicating what went wrong. |\n\n### `ErrorResponseBase` {#Azure.Core.Foundations.ErrorResponseBase}\n\nA response containing error details.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.ErrorResponseBase<Error>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name  | Description                   |\r\n| ----- | ----------------------------- |\r\n| Error | The type of the error object. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description |\r\n| ---------- | -------- | ----------- |\r\n| error      | `Error`  |             |\r\n| errorCode? | `string` |             |\n\n### `InnerError` {#Azure.Core.Foundations.InnerError}\n\nAn object containing more specific information about the error. As per Microsoft One API guidelines - https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#handling-errors.\r\n\r\n```typespec\r\nmodel Azure.Core.Foundations.InnerError\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                                              | Description                                 |\r\n| ----------- | ----------------------------------------------------------------- | ------------------------------------------- |\r\n| code?       | `string`                                                          | One of a server-defined set of error codes. |\r\n| innererror? | [`InnerError`](./data-types.md#Azure.Core.Foundations.InnerError) | Inner error.                                |\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#status-read-only-error.md\n- document_title: `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\n- document_content: # troubleshoot#status-read-only-error.md\n\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\r\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Symptoms\n\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\r\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Cause\n\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\r\ntype schema referenced by the properties to be `readOnly` instead.\n\n## Workaround\n\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\r\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\r\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\r\nenabled automatically.\r\n\r\n```diff lang=yaml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n+    use-read-only-status-schema: true\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n", "latency": 4.88835334777832, "response_length": 79}
{"query": "How did the AVM team use the AzureAPICrawler utility to navigate the inconsistencies in the Azure API?", "ground_truth": "The AVM team used the AzureAPICrawler utility to navigate inconsistencies in the Azure API, indicating a methodical approach to dealing with API variability.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#azure-core#long-running-operations.md\n- document_title: Deep Dive: Long-running (Asynchronous) Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/azure-core/long-running-operations\n- document_content: # howtos#azure-core#long-running-operations.md\n\n# Deep Dive: Long-running (Asynchronous) Operations\n\nLong-running, or asynchronous operations (LROs for short) are Http Operations that are not complete in a single request/response sequence. Such operations require multiple requests and responses, usually to different endpoints before the operation is complete. Some common patterns that services use for LROs include:\r\n\r\n- Polling the resource 'GET' endpoint - Using a 'status' field in the resource to specify the resource state, and polling the resource Get endpoint until the status field reached a terminal status. A 'Location' header is often provided on the initial operation response, with a Url for the resource 'Get' endpoint.\r\n- Using a Status Monitor endpoint - Defining a separate endpoint where operation status can be obtained. An 'Operation-Location' or similar header with a Url for the StatusMonitor endpoint is most often provided in the initial operation response.\r\n- Providing a Push Notification System - Allowing the client to specify an endpoint for the service to call once the operation is complete\r\n\r\nNote that, for many APIs, the Url of the StatusMonitor (or resource GET) endpoint can easily be determined from the values in the initial request and response. This pattern is often followed when linking operations in OpenAPI3 specifications.\n\n## Modeling Long-running Operations in TypeSpec\n\nThe `@azure-tools/typespec-azure-core` library contains specific operation templates for long-running operation patterns recommended by the api review board. Using these templates will ensure that a service has the widest range of compatibility with Azure SDKs and Azure tooling for long-running operations. Service teams **should** use these templates to define their long-running operations. Existing services that have LROs that do not comply with API guidelines should discuss their operations with the Api review board, or the TypeSpec team.\n\n## Long-running Operation Helpers for Emitters and Libraries\n\n| contains values corresponding to the same field in the `x-ms-long-running-operation-options` extension in OpenAPI specifications.                                                                                                                                                       |\r\n| `statusMonitor`   | contains information about the status monitor, including the status monitor type                                                                                                                                                                                                        |\r\n| `polling`         | contains information about polling the status monitor, including the status field and terminal status values                                                                                                                                                                            |\r\n| `final`           | contains information about how to get the result when polling completes. In the standard case. this will contain a reference to the status monitor property that contains result information. If another operation needs to be called to get the status, that information will be here. |\r\n\r\nAs indicated above, operations often contain multiple mechanisms that clients can use to resolve a long-running operation, this means that an operation will frequently contain both operation links and resource links that describe the LRO. The helper prefers the use of resource links to the use of operation links, where possible.\n\nThe Azure.Core library provides a helper that emitters can use to determine if an operation being processed is an LRO, and to provide details about how the LRO should be processed by clients, or about how operations are linked.\r\n\r\n```typespec\r\ngetLroMetadata( program: Program, operation: Operation) : LroMetadata | undefined;\r\n```\r\n\r\nThe `LroMetadata` returned from this function contains information about the linked operations and their behavior, as well as additional that clients used to processing OpenAPI2 will be able to use to process TypeSpec operations similarly:\r\n\r\n| Property          | Description                                                                                                                                                                                                                                                                             |\r\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `logicalResponse` | contains the type of the operation response, for the long-running operation (i.e. the result after polling completes).                                                                                                                                                                  |\r\n| `final-state-via` | contains values corresponding to the same field in the `x-ms-long-running-operation-options` extension in OpenAPI specifications.                                                                                                                                                       |\r\n| `statusMonitor`   | contains information about the status monitor, including the status monitor type\n\n## Describing Custom LRO Patterns using Azure.Core\n\nThe `@azure-tools/typespec-azure-core` library also contains general structures for defining custom long-running operations using specialized model templates and decorators. The following sections describe . The primary mechanisms for linking operations are `Operation Links` and `Resource Links`.\n\n### Custom LROs - Operation Links\n\nOperation links are used when the input parameters to a linked operation can be determined from parameters in the initial operation request and response. For example, if a polling operation uses the identity parameters of the initial request, and an `operationId` parameter which is returned in a header or field in the response, the link between the operations should be modeled as an Operation Link. In order to use an Operation link, each parameter of the linked operation must correspond with a parameter of the initial operation, a property of the initial request (header or body), or property of the initial response (header or body). Operation links encode a reference to the linked operation, and a mapping between the initial request and response and the parameters of the linked operation:\r\n\r\n```typespec\r\nop getWidgetOperationStatus is getResourceOperationStatus<Widget>;\r\n\r\n@pollingOperation(getWidgetOperationStatus, parameterMap)\r\nop createWidgetAsync is longRunningCreateOrReplace<Widget>;\r\n```\r\n\r\nNote that, in the example above, the `@pollingOperation`decorator is used to specify an operation link to a StatusMonitor endpoint. This is just syntactic sugar for `@operationLink(getWidgetOperationStatus, \"polling\", parameterMap)`. To represent the logical stages of an LRO, `@pollingOperation` represents a link to a statusMonitor, and is the only decoration required for operations that comply with the recommended LRO pattern. Another decorator `@finalOperation` represents a link to an operation where the final result must be obtained my making a final request after polling has terminated.\r\n\r\n#### Decorators for Operation Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for operation links\r\n\r\n`@pollingOperation` - links a long-running operation to its status monitor endpoint.\n\na link to a statusMonitor, and is the only decoration required for operations that comply with the recommended LRO pattern. Another decorator `@finalOperation` represents a link to an operation where the final result must be obtained my making a final request after polling has terminated.\r\n\r\n#### Decorators for Operation Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for operation links\r\n\r\n`@pollingOperation` - links a long-running operation to its status monitor endpoint.\r\n`@finalOperation` - links a long-running operation to an additional endpoint, in the case that an additional endpoint must be called to obtain the final result after polling the status monitor is complete.\r\n\r\nEach of these decorators require a reference to the linked operation. They may also provide a mapping between the parameters and response properties of the initial request to the parameters of the linked operation. This mapping can be provided as a `Model` type parameter passed to the decorator, or by decorating the parameters and response properties of the original operation using `@lroParameter`\n\n### Custom LROs - Resource Links\n\nResource links are used when the entire url of the linked operation is provided as part of the response to the initial operation. A resource link encodes the type of the expected response when the link is followed:\r\n\r\n```typespec\r\nmodel WidgetStatusMonitorResponse {\r\n  @pollingLocation\r\n  @header(\"Operation-Location\")\r\n  operationLocation: ResourceLocation<ResourceOperationStatus<Widget>>;\r\n  // following the url in this header will provide a response of type ResourceOperationStatus<Widget>\r\n}\r\n```\r\n\r\n#### Decorators for Resource Links in Azure.Core\r\n\r\nAzure.Core defines the following decorators for resource links used in long-running operations:\r\n\r\n`@pollingLocation` - indicates that the decorated property contains a url to the StatusMonitor. The type of the decorated property **should** be a `ResourceLocation`.\r\n`@finalLocation` - indicates that the decorated property contains a url to the final result, in cases where an additional request must be made after polling to obtain the final result of the operation. The type of the decorated property must be a `ResourceLocation`.\r\n\r\n```typespec\r\nalias ResultHeaders = {\r\n  @pollingLocation\r\n  @header(\"Operation-Location\")\r\n  operationLocation: ResourceLocation<ResourceOperationStatus<Widget>>;\r\n\r\n  @finalLocation\r\n  @header(\"location\")\r\n  location: ResourceLocation<Widget>;\r\n};\r\n```\r\n\r\nNote that the LRO templates provided in Azure.Core automatically provide the appropriate headers and resource location decoration for LROs.\r\nNote that operations often provide multiple mechanisms that clients may use to determine how to logically complete an operation. This is often done to allow clients with different capabilities to determine how to resolve a long-running operation. It is recommended that clients prefer using Operation links in preference to Resource links whenever possible, because OperationLinks provide more information about the next operation.\n\n### Status Monitor Types in Azure.Core\n\nFor Azure services, there is clear API guidance that requires usage of the Status Monitor pattern. In Azure, the Status Monitor has a specific structure, including:\r\n\r\n- A 'status' property containing the current status of the operation\r\n  - The status property is a string property that contains known values for terminal states, by default these are 'Succeeded' for successful operation termination, 'Failed' for operation termination with failure, and 'Canceled' to indicate the operation was canceled.\r\n- A 'result' property, containing the result of the operation once the operation has succeeded (and is null if it has not succeeded)\r\n- An 'error' property, containing any errors that occurred during the operation.\r\n\r\nIn Azure.Core, this structure is represented using the `ResourceOperationStatus<TResource, TSuccess, TError>` model. The initial response to a long-running operation in Azure must contain an `Operation-Location` header that contains a url to the StatusMonitor endpoint. The StatusMonitor endpoint Url can also be calculated using the key properties of the resource and an additional `operationId` key property. To allow repeatability of requests and automatic calculation of the statusMonitor Uri, each LRO should allow an `OperationId` header that sets the operationId for the operation id execution. The `OperationId` must also be included in a header in the initial lro response. These patterns are encoded in the `LongRunning` operation templates provided in Azure.Core. If your service description uses these templates, it will automatically be following the recommended pattern.\n\n### Decorators and Types for Custom StatusMonitors in Azure.Core\n\nA StatusMonitor provides information that drives client polling until an operation completes. This includes a `status` field containing the current state of the operation, with known values for terminal states, headers that suggest polling retry intervals, and fields that will contain result and error information when the operation reaches a terminal status. Azure.Core provides a `ResourceOperationStatus` template that defines the standard Azure status monitor for an Azure operation. However, some services may need to implement custom status monitors. Azure.Core provides additional decorators to help clients use custom status monitors.\r\n\r\n| Decorator                    | Value                                                                                                                                                                                                                                                                     |\r\n| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@lroStatus`                 | A decorator marking the field of the StatusMonitor that contains status information. This field should use a `union` type to specify terminal status values.                                                                                                              |\r\n| `@lroResult`                 | A decorator marking the property of the Status monitor that contains the result of the operation, when the operation completes successfully. By default, any field named 'result' in a StatusMonitor is assumed to contain the result of a successful operation.          |\r\n| `@lroErrorResult`            |\n\na `union` type to specify terminal status values.                                                                                                              |\r\n| `@lroResult`                 | A decorator marking the property of the Status monitor that contains the result of the operation, when the operation completes successfully. By default, any field named 'result' in a StatusMonitor is assumed to contain the result of a successful operation.          |\r\n| `@lroErrorResult`            | A decorator marking the property of the Status monitor that contains errors when the operation is unsuccessful. By default, any field named 'error' in a StatusMonitor is assumed to contain the result of a successful operation.                                        |\r\n| `@lroSucceeded`              | If a status monitor uses a value other than `Succeeded` to indicate operation termination with success, then the variant corresponding to successful completion should be decorated with this decorator.                                                                  |\r\n| `@lroCanceled`               | If a status monitor uses a value other than `Canceled` to indicate that the operation was cancelled, then the variant corresponding to cancellation should be decorated with this decorator.                                                                              |\r\n| `@lroFailed`                 | If a status monitor uses a value other than `Failed` to indicate operation termination with failure, then the variant corresponding to operation failure should be decorated with this decorator.                                                                         |\r\n| `@pollingOperationParameter` | Indicates which request parameters or response properties of an operation can be used to call the operation that retrieves lro status (Status Monitor). Each application of the decorator may reference or name the corresponding parameter in the `getStatus` operation. |\n\n### Examples of common (non-standard) Lro Patterns\n\nStatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Completed\"],\r\n      canceledState [\"Aborted\"],\r\n      failedState: [\"Faulted\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 2 - Status Monitor with custom result fields\r\n\r\nIn this example, the status monitor returns the result of a successful operation in a field with a name other than 'result'\r\n\r\n```tsp\r\n@lroStatus\r\nnum OperationStatus {\r\n  Running,\r\n  Succeeded,\r\n  Canceled,\r\n  Failed\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  @lroResult\r\n  success?: Widget;\r\n  @lroErrorResult\r\n  failure?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\n@pollingOperation(getStatus) // sets the status monitor for the operation\r\nop repairWidget is StandardResourceOperations.LongRUnningResourceAction<Widget, WidgetRepairRequest>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"success\",\r\n  finalStateVia: \"operation-location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: operationLocation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.success,\r\n    errorProperty: StatusMonitor.failure,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 3 - Link to StatusMonitor in the `location` header\r\n\r\nIn this example, the operation returns a `location` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\n\nterminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 3 - Link to StatusMonitor in the `location` header\r\n\r\nIn this example, the operation returns a `location` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header\r\n  location?: ResourceLocation;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 4 - Link to StatusMonitor in the `Azure-AsyncOperation` header\n\nazureAsyncOperation?: string;\r\n\r\n  @finalLocation // this marks the response property or header that will contain a link to the final result\r\n  @header\r\n  location?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@finalOperation(getWidget)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n\r\nop getWidget is StandardResourceOperations.ResourceRead<Widget>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"\",\r\n  finalStateVia: \"location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  finalStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 6 - Calling GetStatusMonitor operation with non-standard parameters\r\n\r\nIn this example, the operation does not return a link, instead, the request parameters and response properties can be used to call the `getStatus` operation that returns the Status Monitor.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path widgetId: string): StatusMonitor | ErrorResult;\n\nreturn a link, instead, the request parameters and response properties can be used to call the `getStatus` operation that returns the Status Monitor.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path widgetId: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget(\r\n  @pollingOperationParameter(getStatus::parameters.widgetId) @path id: string,\r\n  body: WidgetRepairRequest,\r\n): RepairAccepted | ErrorResult;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"custom-operation-reference\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"reference\",\r\n      operation: getStatus,\r\n      parameters: {\r\n        widgetId: {\r\n          sourceKind: \"RequestParameter\",\r\n          source: repairWidget::parameters.id,\r\n          target: getStatus::parameters.widgetId\r\n        }\r\n      }\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\n\ndata for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"azure-async-operation\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 5 - Link to StatusMonitor in the `Azure-AsyncOperation` header and final link\r\n\r\nIn this example, the operation returns a link to the Status Monitor (in `Azure-AsyncOperation`) **and** a link to the final result (in `location`).\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header(\"Azure-AsyncOperation\")\r\n  azureAsyncOperation?: string;\r\n\r\n  @finalLocation // this marks the response property or header that will contain a link to the final result\r\n  @header\r\n  location?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@finalOperation(getWidget)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n\r\nop getWidget is StandardResourceOperations.ResourceRead<Widget>;\r\n```\n\n- Status Monitor with custom terminal status fields\r\n- Status Monitor with custom result field\r\n- Link to StatusMonitor in the `location` header\r\n- Link to StatusMonitor in the `Azure-AsyncOperation` header\r\n- Link to operation with final status\r\n- Calling GetStatusMonitor operation with non-standard parameters\r\n\r\n#### Example 1 - Status Monitor with custom terminal status fields\r\n\r\nIn this example, the Status Monitor terminal properties for \"Succeeded\", \"Failed\", and \"Canceled\" use non-standard names.\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n\r\n  @lroSucceeded\r\n  Completed: \"Completed\",\r\n\r\n  @lroCanceled\r\n  Aborted: \"Aborted\",\r\n\r\n  @lroFailed\r\n  Faulted: \"Faulted\",\r\n\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\n@pollingOperation(getStatus)\r\nop repairWidget is StandardResourceOperations.LongRUnningResourceAction<Widget>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"operation-location\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: operationLocation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Completed\"],\r\n      canceledState [\"Aborted\"],\r\n      failedState: [\"Faulted\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 2 - Status Monitor with custom result fields\r\n\r\nIn this example, the status monitor returns the result of a successful operation in a field with a name other than 'result'\r\n\r\n```tsp\r\n@lroStatus\r\nnum OperationStatus {\n\n{\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: location\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\r\n    terminationStatus: {\r\n      property: StatusMonitor.result,\r\n      succeededState: [\"Succeeded\"],\r\n      canceledState [\"Canceled\"],\r\n      failedState: [\"Failed\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Example 4 - Link to StatusMonitor in the `Azure-AsyncOperation` header\r\n\r\nIn this example, the operation returns a `Azure-AsyncOperation` header with a link to the Status Monitor instead of the recommended `Operation-Location` header\r\n\r\n```tsp\r\n@lroStatus\r\nunion OperationStatus {\r\n  Running: \"Running\",\r\n  Succeeded: \"Succeeded\",\r\n  Canceled: \"Canceled\",\r\n  Failed: \"Failed\",\r\n  string,\r\n}\r\n\r\nmodel StatusMonitor {\r\n  status: OperationStatus;\r\n  result?: Widget;\r\n  error?: Error;\r\n}\r\n\r\n@route(\"/status/{id}\")\r\nop getStatus(@path id: string): StatusMonitor | ErrorResult;\r\n\r\nalias RepairAccepted = {\r\n  @statusCode _: 202;\r\n\r\n  @pollingLocation // this marks the response property or header that will contain a link to the Status Monitor\r\n  @header(\"Azure-AsyncOperation\")\r\n  azureAsyncOperation?: string;\r\n};\r\n\r\n@pollingOperation(getStatus)\r\n@action(\"repairWidget\")\r\n@result\r\n@post\r\nop repairWidget is Azure.Core.Foundations.Operation<\r\n  InstanceKeysOf<Widget> & WidgetRepairRequest,\r\n  RepairAccepted\r\n>;\r\n```\r\n\r\nWe would expect `getLroMetadata` to return the foillowing data for this operation:\r\n\r\n```typescript\r\n{\r\n  envelopeResult: StatusMonitor, // the return value of getStatus\r\n  logicalResult: Widget; // The `result` field in the StatusMonitor\r\n  logicalPath: \"result\",\r\n  finalStateVia: \"azure-async-operation\",\r\n  statusMonitorStep: {\r\n    target: {\r\n      kind: \"link\"\r\n      location: \"ResponseHeader\",\r\n      property: azureAsyncOperation\r\n    }\r\n  },\r\n  pollingInfo: {\r\n    resultProperty: StatusMonitor.result,\r\n    errorProperty: StatusMonitor.error,\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#rest-api-publish#checking-in-api-specs-guide.md\n- document_title: Checking in typespec and generated OpenAPI to azure-rest-api-specs repo\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/checking-in-api-specs-guide\n- document_content: # howtos#rest-api-publish#checking-in-api-specs-guide.md\n\n# Checking in typespec and generated OpenAPI to azure-rest-api-specs repo\n\nSee documentation on the azure-rest-api-specs repo https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/Getting-started-with-TypeSpec-specifications.md\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n", "latency": 4.962421894073486, "response_length": 79}
{"query": "What difficulties did the AVM team face in detecting certain features like diagnostic settings for reliable generation of extension resources?", "ground_truth": "The AVM team faced difficulties in detecting certain features like diagnostic settings for reliable generation of extension resources, highlighting a challenge in ensuring comprehensive module generation.", "response": "The AVM team faced challenges in detecting certain features like diagnostic settings for reliable generation of extension resources due to the inherent complexity of modeling extension resources in TypeSpec. Extension resources are typically used to augment or alter the functionality of other resources, and their metadata is only partially tracked in Azure Resource Manager (ARM). This makes it difficult to ensure consistent diagnostics and reliable generation. Additionally, extension resources require precise modeling of their properties and operations, which can be error-prone if the TypeSpec definitions are not correctly aligned with ARM's requirements. For example, decorators like `@visibility` and `@path` must be used correctly to ensure proper diagnostics and resource identification. Furthermore, the lack of extensibility in enums (now replaced by unions) may also contribute to difficulties in modeling diagnostic settings accurately.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/extending-typespec/diagnostics\n- document_content: # extending-typespec#diagnostics.md\n\n# Diagnostics\n\nThe TypeSpec compiler uses the diagnostic API to report errors and warnings in the specification.\n\n## Best practices\n\n- ❌ Avoid using `throw` to report errors. Any exceptions thrown in this manner will be perceived as bugs in your library by the user.\r\n- ✅ Utilize the diagnostic API to report anticipated errors and warnings.\r\n  - ✅ Employ `reportDiagnostic` in a decorator, `$onValidate` or `$onEmit`\r\n  - ❌ Refrain from using `reportDiagnostic` in an accessor (a function intended to be used in another library or emitter). Refer to the [section on collecting diagnostics](#collect-diagnostics) for more information.\n\n## Diagnostic requirements\n\n- Each diagnostic MUST have a `code`. The complete code is the library name followed by the declared code. (`<lib-name>/<local-code>`)\r\n- Each diagnostic MUST have a `severity`. It can be `error` or `warning`. Errors cannot be suppressed.\r\n- Each diagnostic MUST have at least one message. Using `default` as the `messageId` will make it the default selection.\r\n- Each diagnostic message MAY have parameters to interpolate information into the message.\n\n## How to use\n\n### Declare the diagnostics you plan to report\n\n```ts\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\n// in lib.js\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"@typespec/my-lib\",\r\n  diagnostics: {\r\n    // Basic diagnostic with a fixed message\r\n    \"no-array\": {\r\n      severity: \"error\",\r\n      messages: {\r\n        default: `Array is not allowed in my-lib models.`,\r\n      },\r\n    },\r\n\r\n    // Parameterized message\r\n    \"duplicate-route\": {\r\n      severity: \"error\",\r\n      messages: {\r\n        default: paramMessage`Route '${\"path\"}' is being referenced in 2 different operations.`,\r\n      },\r\n    },\r\n\r\n    // Multiple messages\r\n    \"duplicate-name\": {\r\n      severity: \"warning\",\r\n      messages: {\r\n        default: paramMessage`Duplicate type name: '${\"value\"}'.`,\r\n        parameter: paramMessage`Duplicate parameter key: '${\"value\"}'.`,\r\n      },\r\n    },\r\n  },\r\n} as const);\r\n\r\n// Re-export the helper functions to be able to just call them directly.\r\nexport const { reportDiagnostic, createDiagnostic };\r\n```\r\n\r\nThis will represent three different diagnostics with the full names of:\r\n\r\n- `@typespec/my-lib/no-array`\r\n- `@typespec/my-lib/duplicate-route`\r\n- `@typespec/my-lib/duplicate-name`\n\n### Report diagnostics\n\n```ts\r\nimport { reportDiagnostic } from \"./lib.js\";\r\n\r\n// Basic diagnostic with a fixed message\r\nreportDiagnostic(program, {\r\n  code: \"no-array\",\r\n  target: diagnosticTarget,\r\n});\r\n\r\n// Parameterized message\r\nreportDiagnostic(program, {\r\n  code: \"duplicate-route\",\r\n  format: {path: \"/foo\"}\r\n  target: diagnosticTarget,\r\n});\r\n\r\n// Multiple messages\r\nreportDiagnostic(program, {\r\n  code: \"duplicate-name\",\r\n  messageId: \"parameter\",\r\n  format: {value: \"$select\"},\r\n  target: diagnosticTarget,\r\n});\r\n```\n\n### Collect diagnostics\n\nWhen attempting to report a diagnostic in an accessor, a good practice is not to report the diagnostic to the program directly, but return a tuple to let the user decide what to do.\r\nThis prevents duplicate diagnostics emitter if the accessor is called multiple times.\r\n\r\n```ts\r\nimport { createDiagnosticCollector, Diagnostic } from \"@typespec/compiler\";\r\n\r\nfunction getRoutes(): [Route, readonly Diagnostic] {\r\n  const diagnostics = createDiagnosticCollector();\r\n  diagnostics.add(\r\n    createDiagnostic(program, {\r\n      code: \"no-array\",\r\n      target: diagnosticTarget,\r\n    }),\r\n  );\r\n  const result = diagnostic.pipe(getParameters()); // to pipe diagnostics returned by `getParameters`\r\n  return diagnostics.wrap(routes);\r\n}\r\n```\r\n\r\nor manually\r\n\r\n```ts\r\nimport { Diagnostic } from \"@typespec/compiler\";\r\n\r\nfunction getRoutes(): [Route, readonly Diagnostic] {\r\n  const diagnostics = [];\r\n  diagnostics.push(\r\n    createDiagnostic(program, {\r\n      code: \"no-array\",\r\n      target: diagnosticTarget,\r\n    }),\r\n  );\r\n  return [routes, diagnostics];\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the (ℹ) bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n", "latency": 13.045953512191772, "response_length": 952}
{"query": "How did the AVM team address the challenge of maintaining idempotency to prevent overwriting manual changes to earlier versions of the generated module?", "ground_truth": "The AVM team addressed the challenge of maintaining idempotency to prevent overwriting manual changes to earlier versions of the generated module, though specific strategies are not detailed in the provided information.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_docs\n- document_filename: handbook#reproducibility.md\n- document_title: Reproducibility\n- document_link: https://typespec.io/docs/handbook/reproducibility\n- document_content: # handbook#reproducibility.md\n\n# Reproducibility\n\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\r\n\r\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\r\n- Updates to a new version of a service should not impact older versions.\r\n- Modifications are made to the TypeSpec specification.\r\n\r\nThese issues can be mitigated with a few precautionary measures:\n\n## 1. Defend against dependency changes\n\n_Note: This section applies if using `tsp install` or `npm install` to install dependencies. However other package managers (`yarn`, `pnpm`, etc.) have their own similar lock mechanisms._\r\n\r\nWhen using `tsp install` or `npm install` a `package-lock.json` will be installed. This file SHOULD be committed to source control. It will ensure that later calls to `tsp install` or `npm install` will use the exact versions resolved in the lock files unless the `package.json` was updated or a command like `npm update` was run.\r\n\r\nThe command `npm ci` can also be used in the CI to ensure that the `package.json` and `package-lock.json` are in sync.\n\n## 2. Work with multiple versions of a service\n\nTypeSpec provides a library `@typespec/versioning` that can be used to describe changes to a service or library over time. Using this will ensure that a service can evolve while keeping track of the changes and allowing emitters to see the service representation at different versions.\r\n\r\n[See versioning docs](../libraries/versioning/reference/index.mdx)\n\n## 3. Change to the TypeSpec spec\n\nIf you don't directly control the spec, you might still want to make sure you remember which exact definition was used.\r\nUsing version control and pinning to a specific commit SHA will ensure that the spec will remain exactly as it was.\n\n## Summary\n\n1. Use `package-lock.json`\r\n2. Use [versioning library](../libraries/versioning/reference/index.mdx)\r\n3. Keep track of commit IDs\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#breaking-change-policy.mdx\n- document_title: Breaking Change Policy\n- document_link: https://typespec.io/docs/handbook/breaking-change-policy\n- document_content: # handbook#breaking-change-policy.mdx\n\n# Breaking Change Policy\n\nimport { Badge } from \"@astrojs/starlight/components\";\r\n\r\n:::note\r\nThe information in this document is applicable to TypeSpec packages with version 1.0.0 or greater.\r\n:::\n\n## Versioning Scheme\n\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\n\n## Breaking Change Philosophy\n\nExisting language syntax and semantics will not change without a major version.\r\nThe runtime behavior for a given TypeSpec will not change without a major version.\r\nTypeSpecs leveraging new or updated features may cause runtime API consumers to fail\r\n(e.g. because a new type is unhandled in an emitter or library that it uses)\r\nor builds to fail (e.g. because exhaustive unions are no longer exhaustive).\r\n\r\n- The language syntax and semantics for existing language elements will not change within a major version.\r\n- A spec that builds successfully with a version of the TypeSpec compiler and its libraries will build successfully with a newer version of the compiler and libraries within the same major version.\r\n- New types and functionality may be added in a minor version release to the compiler or any TypeSpec library.\r\n  - If a spec uses the new type or functionality, existing libraries or emitters may not work with it, and this is not considered a breaking change in the compiler or library that introduced the type. Spec authors should expect that _existing_ specs will continue to work with their workflows, but not that newly-added features will work with their existing workflows every time.\r\n- TypeScript API types in TypeScript might change in ways that introduce TypeScript type checking errors (e.g. adding a new variant to a union). TypeScript type checking errors in library builds are not considered breaking changes, and library authors working in TypeScript should take care to program defensively as appropriate. More information about TypeScript API guarantees is provided in the section _Categories of Breaking Changes_ below.\n\n### Bugs\n\nA bug fix that introduces a technically breaking change will not be considered a breaking change for the purposes of TypeSpec versioning if it is clear that the existing behavior was broken or unintended in the first place.\n\n## Categories of Breaking Changes\n\n|\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/experimental` is considered for experimental and its API may change at any time. [See experiemental api](#experimental-apis)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Formatter                           | <Badge text=\"3\" variant=\"note\" />    | Formatting shouldn't affect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.\n\n|\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| Additional library helper functions | <Badge text=\"0\" variant=\"success\" /> | Helper and metadata accessor functions exported from the public surface of the compiler or a TypeSpec library are generally considered stable unless otherwise specified or only exported through an experimental subpath.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\r\n|\n\n|\r\n| TypeSpec AST (`Node`)               | <Badge text=\"1\" variant=\"caution\" /> | The TypeSpec abstract syntax tree may change at any time. **Note**: this is not the same thing as the _type graph_ (`Type` and its variants), which is a <Badge text=\"Tier 0\" variant=\"success\" />, stable feature; this only applies to `Node` and its variants. The only sanctioned reason for using the AST is for some syntax based linting rule or writing codefixes. Libraries depend on the abstract syntax tree _at their own risk_!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| Checker                             | <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.\n\n- <Badge text=\"Tier 0\" variant=\"success\" />: These are stable core APIs and language features that\r\n  define fundamental semantics and will not be broken without a major version update. We recommend\r\n  that library authors depend on these APIs.\r\n- <Badge text=\"Tier 1\" variant=\"caution\" />: These are APIs that have very limited use cases and may\r\n  be broken without a major version update. We recommend that library authors avoid depending on\r\n  these APIs.\r\n- <Badge text=\"Tier 2\" variant=\"danger\" />: These are internal APIs intended only for use by the\r\n  TypeSpec compiler and core libraries. Tier 2 APIs may be changed without a a major version update\r\n  or even documentation of the change. Consuming these APIs is _at your own risk_!\r\n- <Badge text=\"Tier 3\" variant=\"note\" />: These are APIs and language features that don't describe\r\n  semantically meaningful information, but provide information that emitters and libraries may\r\n  choose to use and may introduce changes in emitter output when the features are changed. For\r\n  example: formatting.\r\n\r\n| Example                             | Tier                                 | Description\n\n|\r\n| Stdout                              | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec does not provide any contract with the output emitted to `stdout`/`stderr`. The CLI might change the output at any time. Stderr is used to output progress tracking and should NOT be counted as a failure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| `@internal` exports                 | <Badge text=\"2\" variant=\"danger\" />  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.\n\naffect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| Bug fixes                           | [See bug](#bugs)                     | Bug fixes will not be considered breaking changes for the purposes of TypeSpec versioning if the existing behavior is _clearly_ broken or unintentional (e.g. if it violates the documented and expected behavior, or if there is no reasonable interpretation of the buggy behavior), even if the change is technically a breaking change. Bug fixes that are technically breaking will be documented as breaking changes in the release notes, but will not introduce a major version revision. However, if a bug's behavior has become so widely used as to be considered a \"feature,\" we will consider the impact of the bugfix and make a reasonable determination to the best of our abilities and depending on the non-breaking mitigation strategies we have at our disposal. We will not break behaviors in stable releases that are known to be widely depended upon, even if we believe they are the result of a bug. |\n\n|\r\n| ----------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.\n\n| <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| Symbols                             | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec node symbols (not JavaScript symbols or state keys, rather the internal symbols used to relate TypeSpec types in the parser and type checker) are for internal use only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Stdout                              |\n\n/>  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| `/internals` exports                | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/internals` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  |\n\n### Supported Node.js Versions\n\nTypeSpec will support all [current, active, and maintenance LTS Node.js releases](https://nodejs.org/en/about/previous-releases). We aim to support newly released current LTS versions as soon as possible, and we will provide a six month \"grace period\" after an LTS release leaves maintenance support before we cease testing it. After we drop support for a maintenance LTS version of Node.js, we may begin using syntax and runtime features that outdated Node.js versions may not support in new minor versions of published packages.\r\n\r\nTypeSpec does not guarantee support for any alternative JavaScript engines or runtimes.\n\n### Using Experimental APIs <Badge text=\"Tier 3\" variant=\"danger\" />\n\nTypeSpec compiler and libraries may expose experimental APIs that are not yet stable. These APIs are subject to change without notice.\r\nExperimental APIs or types are exported from sub exports with the name `/experimental` or a sub export (e.g. `/experimental/feature`).\r\n\r\nWhen those APIs become stable the unstable APIs will be deprecated then removed and users will need to migrate to the stable version.\n\n### Emitter output\n\nEmitter output are not guaranteed to be producing the exact same output as the previous version for the same input. A change that is semantically equivalent wouldn't be considered a breaking change by the emitter.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n", "latency": 5.431664705276489, "response_length": 79}
{"query": "What complexities did the introduction of new multiline formatting for parameters add to interpreting the Bicep template correctly?", "ground_truth": "The introduction of new multiline formatting for parameters added complexities to interpreting the Bicep template correctly, indicating a technical challenge in template parsing.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#overview.md\n- document_title: Overview\n- document_link: https://typespec.io/docs/language-basics/overview\n- document_content: # language-basics#overview.md\n\n# Overview\n\nThis document provides a concise overview of the language concepts in TypeSpec. It serves as a quick reference guide rather than an in-depth tutorial.\n\n## Declarations\n\n- Names of declarations must be unique across different types within the same scope. For instance, the following is not permissible:\r\n  <!-- prettier-ignore -->\r\n  ```typespec\r\n  model Dog {}\r\n  namespace Dog {}\r\n  ```\n\n## Imports\n\n_For more details, see: [Imports](./imports.md)_\r\n\r\n| Feature              | Example                   |\r\n| -------------------- | ------------------------- |\r\n| Import TypeSpec file | `import \"./models.tsp\"`   |\r\n| Import JS file       | `import \"./models.js\"`    |\r\n| Import Library       | `import \"@typespec/rest\"` |\n\n## Namespaces\n\n_For more details, see: [Namespaces](./namespaces.md)_\r\n\r\n| Feature           | Example                      |\r\n| ----------------- | ---------------------------- |\r\n| Declare namespace | `namespace PetStore {}`      |\r\n| File namespace    | `namespace PetStore;`        |\r\n| Nested namespace  | `namespace PetStore.Models;` |\r\n| Using namespace   | `using PetStore.Models;`     |\n\n## Decorators\n\n_For more details, see: [Decorators](./decorators.md)_\r\n\r\n| Feature                      | Example                                                                             |\r\n| ---------------------------- | ----------------------------------------------------------------------------------- |\r\n| Use decorator                | `@mark`                                                                             |\r\n| Use decorator with arguments | `@tag(\"abc\")`                                                                       |\r\n| Declare a decorator in JS    | `export function $tag(context: DecoratorContext, target: Type, name: string) {...}` |\r\n| Save state in decorator      | `context.program.stateMap(key).set(target, <value>)`                                |\r\n| Augment decorator            | `@@tag(MyType, \"abc\");`                                                             |\n\n## Scalars\n\n_For more details, see: [Scalars](./scalars.md)_\r\n\r\n| Feature            | Example                                     |\r\n| ------------------ | ------------------------------------------- |\r\n| Scalar declaration | `scalar ternary`                            |\r\n| Extend scalar      | `scalar Password extends string`            |\r\n| Template scalar    | `@doc(T) scalar Password<T extends string>` |\n\n## Models\n\n_For more details, see: [Models](./models.md)_\r\n\r\n| Feature                        | Example                               |\r\n| ------------------------------ | ------------------------------------- |\r\n| Model declaration              | `model Pet {}`                        |\r\n| Model inheritance              | `model Dog extends Pet {}`            |\r\n| scalar is                      | `model uuid extends string;`          |\r\n| Model spread                   | `model Dog {...Animal}`               |\r\n| Property                       | `model Dog { name: string }`          |\r\n| Optional property              | `model Dog { owner?: string }`        |\r\n| Optional property with default | `model Dog { name?: string = \"Rex\" }` |\r\n| Model template                 | `model Pet<T> { t: T }`               |\n\n## Operations\n\n_For more details, see: [Operations](./operations.md)_\r\n\r\n| Feature                       | Example                                          |\r\n| ----------------------------- | ------------------------------------------------ |\r\n| Operation declaration         | `op ping(): void`                                |\r\n| Operation with parameters     | `op upload(filename: string, data: bytes): void` |\r\n| Operation with return type    | `op health(): HealthStatus`                      |\r\n| Operation with multiple types | `op health(): HealthStatus \\| ErrorResponse`     |\r\n| Operation template            | `op getter<T>(id: string): T`                    |\r\n| Operation is                  | `op getPet is getter<Pet>;`                      |\n\n## Interfaces\n\n_For more details, see: [Interfaces](./interfaces.md)_\r\n\r\n| Feature               | Example                                |\r\n| --------------------- | -------------------------------------- |\r\n| Interface declaration | `interface PetStore { list(): Pet[] }` |\r\n| Interface composition | `interface PetStore extends Store { }` |\r\n| Interface template    | `interface Restful<T> { list(): T[] }` |\n\n## Templates\n\n_For more details, see: [Templates](./templates.md)_\r\n\r\n| Feature                           | Example                                             |\r\n| --------------------------------- | --------------------------------------------------- |\r\n| Simple template                   | `model Response<T> {value: T}`                      |\r\n| Template with multiple parameters | `model Response<K, V> {key: K, value: T}`           |\r\n| Template default                  | `model Response<T = string> {value: T}`             |\r\n| Template constraints              | `model Response<T extends {id: string}> {value: T}` |\r\n| Template constraints and defaults | `model Response<T extends string = \"\"> {value: T}`  |\n\n## Enums\n\n_For more details, see: [Enums](./enums.md)_\r\n\r\n| Feature            | Example                                        |\r\n| ------------------ | ---------------------------------------------- |\r\n| Enum declaration   | `enum Direction {Up, Down}`                    |\r\n| Enum string values | `enum Direction {Up: \"up\", Down: \"down\"}`      |\r\n| Enum int values    | `enum Size {Small: 1000, Large: 2000}`         |\r\n| Enum float values  | `enum Part {Quarter: 0.25, Half: 0.5}`         |\r\n| Enum composing     | `enum Direction2D {...Direction, Left, Right}` |\n\n## Unions\n\n_For more details, see: [Unions](./unions.md)_\r\n\r\n| Feature                 | Example                          |\r\n| ----------------------- | -------------------------------- |\r\n| Union declaration       | `\"cat\" \\| \"dog\"`                 |\r\n| Named union declaration | `union Pet {cat: Cat, dog: Dog}` |\n\n## Intersections\n\n_For more details, see: [Intersections](./intersections.md)_\r\n\r\n| Feature                  | Example        |\r\n| ------------------------ | -------------- |\r\n| Intersection declaration | `Pet & Animal` |\n\n## Type literals\n\n_For more details, see: [Type literals](./type-literals.md)_\r\n\r\n| Feature           | Example                                                  |\r\n| ----------------- | -------------------------------------------------------- |\r\n| String            | `\"Hello world!\"`                                         |\r\n| Multi line String | `\"\"\"\\nHello world!\\n\"\"\"` (\\n) represent actual new lines |\r\n| Int               | `10`                                                     |\r\n| Float             | `10.0`                                                   |\r\n| Boolean           | `false`                                                  |\n\n## Aliases\n\n_For more details, see: [Aliases](./alias.md)_\r\n\r\n| Feature           | Example                           |\r\n| ----------------- | --------------------------------- |\r\n| Alias declaration | `alias Options = \"one\" \\| \"two\";` |\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#built-in-data-types.md\n- document_title: Built-in Data types\n- document_link: https://typespec.io/docs/standard-library/built-in-data-types\n- document_content: # standard-library#built-in-data-types.md\n\n# Built-in Data types\n\n## TypeSpec\n\n### `Array` {#Array}\n\n```typespec\r\nmodel Array<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the array elements |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Create` {#Create}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" resource lifecycle phase.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Create<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has only the `name` field.\r\nmodel CreateDog is Create<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `CreateOrUpdate` {#CreateOrUpdate}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" or \"Update\" resource lifecycle phases.\r\n\r\nThe \"CreateOrUpdate\" lifecycle phase is used by default for properties passed as parameters to operations\r\nthat can create _or_ update data, like HTTP PUT operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` or `Lifecycle.Update` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel CreateOrUpdate<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create)\r\n  immutableSecret: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `immutableSecret`, `secretName`, and `name` fields, but not the `id` field.\r\nmodel CreateOrUpdateDog is CreateOrUpdate<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DefaultKeyVisibility` {#DefaultKeyVisibility}\n\nApplies a visibility setting to a collection of properties.\r\n```typespec\r\nmodel DefaultKeyVisibility<Source, Visibility>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Visibility | The visibility to apply to all properties. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Delete` {#Delete}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Delete\" resource lifecycle phase.\r\n\r\nThe \"Delete\" lifecycle phase is used for properties passed as parameters to operations\r\nthat delete data, like HTTP DELETE operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Delete` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Delete<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // Set when the Dog is removed from our data store. This happens when the\r\n  // Dog is re-homed to a new owner.\r\n  @visibility(Lifecycle.Delete)\r\n  nextOwner: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `nextOwner` and `name` fields, but not the `id` field.\r\nmodel DeleteDog is Delete<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DiscriminatedOptions` {#DiscriminatedOptions}\n\nOptions for `@discriminated` decorator.\r\n```typespec\r\nmodel DiscriminatedOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| envelope? | `\"object\" \\| \"none\"` | How is the discriminated union serialized. |\r\n| discriminatorPropertyName? | [`string`](#string) | Name of the discriminator property |\r\n| envelopePropertyName? | [`string`](#string) | Name of the property envelopping the data |\n\n### `ExampleOptions` {#ExampleOptions}\n\nOptions for example decorators\r\n```typespec\r\nmodel ExampleOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | The title of the example |\r\n| description? | [`string`](#string) | Description of the example |\n\n### `OmitDefaults` {#OmitDefaults}\n\nRepresents a collection of properties with default values omitted.\r\n```typespec\r\nmodel OmitDefaults<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread property defaults are all omitted. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OmitProperties` {#OmitProperties}\n\nRepresents a collection of omitted properties.\r\n```typespec\r\nmodel OmitProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to omit. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OperationExample` {#OperationExample}\n\nOperation example configuration.\r\n```typespec\r\nmodel OperationExample\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| parameters? | `unknown` | Example request body. |\r\n| returnType? | `unknown` | Example response body. |\n\n### `OptionalProperties` {#OptionalProperties}\n\nRepresents a collection of optional properties.\r\n```typespec\r\nmodel OptionalProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all optional. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `PickProperties` {#PickProperties}\n\nRepresents a collection of properties with only the specified keys included.\r\n```typespec\r\nmodel PickProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to include. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Query` {#Query}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Query\" resource lifecycle phase.\r\n\r\nThe \"Query\" lifecycle phase is used for properties passed as parameters to operations\r\nthat read data, like HTTP GET or HEAD operations. This should not be confused for\r\nthe `@query` decorator, which specifies that the property is transmitted in the\r\nquery string of an HTTP request.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Query` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Query<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // When getting information for a Dog, you can set this field to true to include\r\n  // some extra information about the Dog's pedigree that is normally not returned.\r\n  // Alternatively, you could just use a separate option parameter to get this\r\n  // information.\r\n  @visibility(Lifecycle.Query)\r\n  includePedigree?: boolean;\r\n\r\n  name: string;\r\n\r\n  // Only included if `includePedigree` is set to true in the request.\r\n  @visibility(Lifecycle.Read)\r\n  pedigree?: string;\r\n}\r\n\r\n// This model will have the `includePedigree` and `name` fields, but not `id` or `pedigree`.\r\nmodel QueryDog is Query<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Read` {#Read}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Read\" resource lifecycle phase.\r\n\r\nThe \"Read\" lifecycle phase is used for properties returned by operations that read data, like\r\nHTTP GET operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Read` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Read<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has the `id` and `name` fields, but not `secretName`.\r\nmodel ReadDog is Read<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Record` {#Record}\n\n```typespec\r\nmodel Record<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the properties |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `ServiceOptions` {#ServiceOptions}\n\nService options.\r\n```typespec\r\nmodel ServiceOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | Title of the service. |\r\n| version? | [`string`](#string) | Version of the service. |\n\n### `Update` {#Update}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Update\" resource lifecycle phase.\r\n\r\nThe \"Update\" lifecycle phase is used for properties passed as parameters to operations\r\nthat update data, like HTTP PATCH operations.\r\n\r\nThis transformation will include only the properties that have the `Lifecycle.Update`\r\nvisibility modifier, and the types of all properties will be replaced with the\r\nequivalent `CreateOrUpdate` transformation.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Update<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `secretName` and `name` fields, but not the `id` field.\r\nmodel UpdateDog is Update<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `UpdateableProperties` {#UpdateableProperties}\n\nRepresents a collection of updateable properties.\r\n```typespec\r\nmodel UpdateableProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all updateable. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `VisibilityFilter` {#VisibilityFilter}\n\nA visibility filter, used to specify which properties should be included when\r\nusing the `withVisibilityFilter` decorator.\r\n\r\nThe filter matches any property with ALL of the following:\r\n- If the `any` key is present, the property must have at least one of the specified visibilities.\r\n- If the `all` key is present, the property must have all of the specified visibilities.\r\n- If the `none` key is present, the property must have none of the specified visibilities.\r\n```typespec\r\nmodel VisibilityFilter\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| any? | `EnumMember[]` |  |\r\n| all? | `EnumMember[]` |  |\r\n| none? | `EnumMember[]` |  |\n\n### `ArrayEncoding` {#ArrayEncoding}\n\nEncoding for serializing arrays\r\n```typespec\r\nenum ArrayEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| pipeDelimited |  | Each values of the array is separated by a \\| |\r\n| spaceDelimited |  | Each values of the array is separated by a <space> |\n\n### `BytesKnownEncoding` {#BytesKnownEncoding}\n\nKnown encoding to use on bytes\r\n```typespec\r\nenum BytesKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| base64 | `\"base64\"` | Encode to Base64 |\r\n| base64url | `\"base64url\"` | Encode to Base64 Url |\n\n### `DateTimeKnownEncoding` {#DateTimeKnownEncoding}\n\nKnown encoding to use on utcDateTime or offsetDateTime\r\n```typespec\r\nenum DateTimeKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| rfc3339 | `\"rfc3339\"` | RFC 3339 standard. https://www.ietf.org/rfc/rfc3339.txt<br />Encode to string. |\r\n| rfc7231 | `\"rfc7231\"` | RFC 7231 standard. https://www.ietf.org/rfc/rfc7231.txt<br />Encode to string. |\r\n| unixTimestamp | `\"unixTimestamp\"` | Encode a datetime to a unix timestamp.<br />Unix timestamps are represented as an integer number of seconds since the Unix epoch and usually encoded as an int32. |\n\n### `DurationKnownEncoding` {#DurationKnownEncoding}\n\nKnown encoding to use on duration\r\n```typespec\r\nenum DurationKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| ISO8601 | `\"ISO8601\"` | ISO8601 duration |\r\n| seconds | `\"seconds\"` | Encode to integer or float |\n\n### `Lifecycle` {#Lifecycle}\n\nA visibility class for resource lifecycle phases.\r\n\r\nThese visibilities control whether a property is visible during the various phases of a resource's lifecycle.\r\n```typespec\r\nenum Lifecycle\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| Create |  | The property is visible when a resource is being created. |\r\n| Read |  | The property is visible when a resource is being read. |\r\n| Update |  | The property is visible when a resource is being updated. |\r\n| Delete |  | The property is visible when a resource is being deleted. |\r\n| Query |  | The property is visible when a resource is being queried.<br /><br />In HTTP APIs, this visibility applies to parameters of GET or HEAD operations. |\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n @visibility(Lifecycle.Read)\r\n id: int32;\r\n\r\n @visibility(Lifecycle.Create, Lifecycle.Update)\r\n secretName: string;\r\n\r\n name: string;\r\n}\r\n```\r\n\r\nIn this example, the `id` property is only visible during the read phase, and the `secretName` property is only visible\r\nduring the create and update phases. This means that the server will return the `id` property when returning a `Dog`,\r\nbut the client will not be able to set or update it. In contrast, the `secretName` property can be set when creating\r\nor updating a `Dog`, but the server will never return it. The `name` property has no visibility modifiers and is\r\ntherefore visible in all phases.\n\n### `boolean` {#boolean}\n\nBoolean with `true` and `false` values.\r\n```typespec\r\nscalar boolean\r\n```\n\n### `bytes` {#bytes}\n\nRepresent a byte array\r\n```typespec\r\nscalar bytes\r\n```\n\n### `decimal` {#decimal}\n\nA decimal number with any length and precision. This represent any `decimal` value possible.\r\nIt is commonly represented as `BigDecimal` in some languages.\r\n```typespec\r\nscalar decimal\r\n```\n\n### `decimal128` {#decimal128}\n\nA 128-bit decimal number.\r\n```typespec\r\nscalar decimal128\r\n```\n\n### `duration` {#duration}\n\nA duration/time period. e.g 5s, 10h\r\n```typespec\r\nscalar duration\r\n```\n\n### `float` {#float}\n\nA number with decimal value\r\n```typespec\r\nscalar float\r\n```\n\n### `float32` {#float32}\n\nA 32 bit floating point number. (`±1.5 x 10^−45` to `±3.4 x 10^38`)\r\n```typespec\r\nscalar float32\r\n```\n\n### `float64` {#float64}\n\nA 64 bit floating point number. (`±5.0 × 10^−324` to `±1.7 × 10^308`)\r\n```typespec\r\nscalar float64\r\n```\n\n### `int16` {#int16}\n\nA 16-bit integer. (`-32,768` to `32,767`)\r\n```typespec\r\nscalar int16\r\n```\n\n### `int32` {#int32}\n\nA 32-bit integer. (`-2,147,483,648` to `2,147,483,647`)\r\n```typespec\r\nscalar int32\r\n```\n\n### `int64` {#int64}\n\nA 64-bit integer. (`-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`)\r\n```typespec\r\nscalar int64\r\n```\n\n### `int8` {#int8}\n\nA 8-bit integer. (`-128` to `127`)\r\n```typespec\r\nscalar int8\r\n```\n\n### `integer` {#integer}\n\nA whole number. This represent any `integer` value possible.\r\nIt is commonly represented as `BigInteger` in some languages.\r\n```typespec\r\nscalar integer\r\n```\n\n### `numeric` {#numeric}\n\nA numeric type\r\n```typespec\r\nscalar numeric\r\n```\n\n### `offsetDateTime` {#offsetDateTime}\n\nA date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"\r\n```typespec\r\nscalar offsetDateTime\r\n```\n\n### `plainDate` {#plainDate}\n\nA date on a calendar without a time zone, e.g. \"April 10th\"\r\n```typespec\r\nscalar plainDate\r\n```\n\n### `plainTime` {#plainTime}\n\nA time on a clock without a time zone, e.g. \"3:00 am\"\r\n```typespec\r\nscalar plainTime\r\n```\n\n### `safeint` {#safeint}\n\nAn integer that can be serialized to JSON (`−9007199254740991 (−(2^53 − 1))` to `9007199254740991 (2^53 − 1)` )\r\n```typespec\r\nscalar safeint\r\n```\n\n### `string` {#string}\n\nA sequence of textual characters.\r\n```typespec\r\nscalar string\r\n```\n\n### `uint16` {#uint16}\n\nA 16-bit unsigned integer (`0` to `65,535`)\r\n```typespec\r\nscalar uint16\r\n```\n\n### `uint32` {#uint32}\n\nA 32-bit unsigned integer (`0` to `4,294,967,295`)\r\n```typespec\r\nscalar uint32\r\n```\n\n### `uint64` {#uint64}\n\nA 64-bit unsigned integer (`0` to `18,446,744,073,709,551,615`)\r\n```typespec\r\nscalar uint64\r\n```\n\n### `uint8` {#uint8}\n\nA 8-bit unsigned integer (`0` to `255`)\r\n```typespec\r\nscalar uint8\r\n```\n\n### `unixTimestamp32` {#unixTimestamp32}\n\nRepresent a 32-bit unix timestamp datetime with 1s of granularity.\r\nIt measures time by the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970.\r\n```typespec\r\nscalar unixTimestamp32\r\n```\n\n### `url` {#url}\n\nRepresent a URL string as described by https://url.spec.whatwg.org/\r\n```typespec\r\nscalar url\r\n```\n\n### `utcDateTime` {#utcDateTime}\n\nAn instant in coordinated universal time (UTC)\"\r\n```typespec\r\nscalar utcDateTime\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmResourcePatchSync<Resource, ResourceProperties>;`  |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                         |\r\n| -------------------- | ----------- | -------- | --------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                             |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`   |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmResourcePatchSync<Resource, ResourceProperties>;` |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                    |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`            |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason fro choosing another PATCH operation.\r\n\r\n| Operation Description             | TypeSpec                                                            |\r\n| --------------------------------- | ------------------------------------------------------------------- |\r\n| Sync Updateable Properties PATCH  | `update is ArmResourcePatchSync<ResourceType, ResourceProperties>`  |\r\n| Async Updateable Properties PATCH | `update is ArmResourcePatchAsync<ResourceType, ResourceProperties>` |\r\n| Sync TagsOnly PATCH               | `update is ArmTagsPatchSync<ResourceType>`                          |\r\n| Async TagsOnly PATCH              | `update is ArmTagsPatchAsync<ResourceType>`                         |\r\n| Sync Custom PATCH                 | `update is ArmCustomPatchSync<ResourceType, PatchRequest>`          |\r\n| Async Custom PATCH                | `update is ArmCustomPatchAsync<ResourceType, PatchRequest>`         |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n", "latency": 12.320569276809692, "response_length": 79}
{"query": "Why did the AVM team prefer to avoid developing their own language interpreter?", "ground_truth": "The AVM team preferred to avoid developing their own language interpreter, suggesting a preference for leveraging existing tools and avoiding the complexities of language interpretation.", "response": "The AVM team preferred to avoid developing their own language interpreter because TypeSpec provides a robust framework for generating client libraries and handling complex type graphs. By leveraging existing tools like the TypeSpec Client Generator Core (TCGC), they can focus on language-specific code generation without reinventing the wheel. TCGC abstracts common logic for client emitters, simplifying the process and ensuring consistency across different languages. Additionally, TypeSpec's emitter framework and semantic walker offer efficient methods for traversing and emitting types, reducing the need for custom implementations. This approach aligns with best practices for minimizing complexity and ensuring compatibility with TypeSpec's evolving ecosystem.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#breaking-change-policy.mdx\n- document_title: Breaking Change Policy\n- document_link: https://typespec.io/docs/handbook/breaking-change-policy\n- document_content: # handbook#breaking-change-policy.mdx\n\n# Breaking Change Policy\n\nimport { Badge } from \"@astrojs/starlight/components\";\r\n\r\n:::note\r\nThe information in this document is applicable to TypeSpec packages with version 1.0.0 or greater.\r\n:::\n\n## Versioning Scheme\n\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\n\n## Breaking Change Philosophy\n\nExisting language syntax and semantics will not change without a major version.\r\nThe runtime behavior for a given TypeSpec will not change without a major version.\r\nTypeSpecs leveraging new or updated features may cause runtime API consumers to fail\r\n(e.g. because a new type is unhandled in an emitter or library that it uses)\r\nor builds to fail (e.g. because exhaustive unions are no longer exhaustive).\r\n\r\n- The language syntax and semantics for existing language elements will not change within a major version.\r\n- A spec that builds successfully with a version of the TypeSpec compiler and its libraries will build successfully with a newer version of the compiler and libraries within the same major version.\r\n- New types and functionality may be added in a minor version release to the compiler or any TypeSpec library.\r\n  - If a spec uses the new type or functionality, existing libraries or emitters may not work with it, and this is not considered a breaking change in the compiler or library that introduced the type. Spec authors should expect that _existing_ specs will continue to work with their workflows, but not that newly-added features will work with their existing workflows every time.\r\n- TypeScript API types in TypeScript might change in ways that introduce TypeScript type checking errors (e.g. adding a new variant to a union). TypeScript type checking errors in library builds are not considered breaking changes, and library authors working in TypeScript should take care to program defensively as appropriate. More information about TypeScript API guarantees is provided in the section _Categories of Breaking Changes_ below.\n\n### Bugs\n\nA bug fix that introduces a technically breaking change will not be considered a breaking change for the purposes of TypeSpec versioning if it is clear that the existing behavior was broken or unintended in the first place.\n\n## Categories of Breaking Changes\n\n|\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/experimental` is considered for experimental and its API may change at any time. [See experiemental api](#experimental-apis)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Formatter                           | <Badge text=\"3\" variant=\"note\" />    | Formatting shouldn't affect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.\n\n|\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| Additional library helper functions | <Badge text=\"0\" variant=\"success\" /> | Helper and metadata accessor functions exported from the public surface of the compiler or a TypeSpec library are generally considered stable unless otherwise specified or only exported through an experimental subpath.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\r\n|\n\n|\r\n| TypeSpec AST (`Node`)               | <Badge text=\"1\" variant=\"caution\" /> | The TypeSpec abstract syntax tree may change at any time. **Note**: this is not the same thing as the _type graph_ (`Type` and its variants), which is a <Badge text=\"Tier 0\" variant=\"success\" />, stable feature; this only applies to `Node` and its variants. The only sanctioned reason for using the AST is for some syntax based linting rule or writing codefixes. Libraries depend on the abstract syntax tree _at their own risk_!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| Checker                             | <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.\n\n- <Badge text=\"Tier 0\" variant=\"success\" />: These are stable core APIs and language features that\r\n  define fundamental semantics and will not be broken without a major version update. We recommend\r\n  that library authors depend on these APIs.\r\n- <Badge text=\"Tier 1\" variant=\"caution\" />: These are APIs that have very limited use cases and may\r\n  be broken without a major version update. We recommend that library authors avoid depending on\r\n  these APIs.\r\n- <Badge text=\"Tier 2\" variant=\"danger\" />: These are internal APIs intended only for use by the\r\n  TypeSpec compiler and core libraries. Tier 2 APIs may be changed without a a major version update\r\n  or even documentation of the change. Consuming these APIs is _at your own risk_!\r\n- <Badge text=\"Tier 3\" variant=\"note\" />: These are APIs and language features that don't describe\r\n  semantically meaningful information, but provide information that emitters and libraries may\r\n  choose to use and may introduce changes in emitter output when the features are changed. For\r\n  example: formatting.\r\n\r\n| Example                             | Tier                                 | Description\n\n|\r\n| Stdout                              | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec does not provide any contract with the output emitted to `stdout`/`stderr`. The CLI might change the output at any time. Stderr is used to output progress tracking and should NOT be counted as a failure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| `@internal` exports                 | <Badge text=\"2\" variant=\"danger\" />  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.\n\naffect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| Bug fixes                           | [See bug](#bugs)                     | Bug fixes will not be considered breaking changes for the purposes of TypeSpec versioning if the existing behavior is _clearly_ broken or unintentional (e.g. if it violates the documented and expected behavior, or if there is no reasonable interpretation of the buggy behavior), even if the change is technically a breaking change. Bug fixes that are technically breaking will be documented as breaking changes in the release notes, but will not introduce a major version revision. However, if a bug's behavior has become so widely used as to be considered a \"feature,\" we will consider the impact of the bugfix and make a reasonable determination to the best of our abilities and depending on the non-breaking mitigation strategies we have at our disposal. We will not break behaviors in stable releases that are known to be widely depended upon, even if we believe they are the result of a bug. |\n\n|\r\n| ----------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.\n\n| <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| Symbols                             | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec node symbols (not JavaScript symbols or state keys, rather the internal symbols used to relate TypeSpec types in the parser and type checker) are for internal use only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Stdout                              |\n\n/>  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| `/internals` exports                | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/internals` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  |\n\n### Supported Node.js Versions\n\nTypeSpec will support all [current, active, and maintenance LTS Node.js releases](https://nodejs.org/en/about/previous-releases). We aim to support newly released current LTS versions as soon as possible, and we will provide a six month \"grace period\" after an LTS release leaves maintenance support before we cease testing it. After we drop support for a maintenance LTS version of Node.js, we may begin using syntax and runtime features that outdated Node.js versions may not support in new minor versions of published packages.\r\n\r\nTypeSpec does not guarantee support for any alternative JavaScript engines or runtimes.\n\n### Using Experimental APIs <Badge text=\"Tier 3\" variant=\"danger\" />\n\nTypeSpec compiler and libraries may expose experimental APIs that are not yet stable. These APIs are subject to change without notice.\r\nExperimental APIs or types are exported from sub exports with the name `/experimental` or a sub export (e.g. `/experimental/feature`).\r\n\r\nWhen those APIs become stable the unstable APIs will be deprecated then removed and users will need to migrate to the stable version.\n\n### Emitter output\n\nEmitter output are not guaranteed to be producing the exact same output as the previous version for the same input. A change that is semantically equivalent wouldn't be considered a breaking change by the emitter.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#00howtogen.mdx\n- document_title: How to generate client libraries\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/00howtogen\n- document_content: # howtos#generate-client-libraries#00howtogen.mdx\n\n# How to generate client libraries\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page outlines the steps to build a client library based on your TypeSpec specification. It provides a guide for the whole process from initial API design to the release of SDKs. please visit https://aka.ms/azsdk/dpcodegen.\r\n\r\nThe best documentation on how to generate can be found using those links:\r\n\r\n- https://aka.ms/azsdk/dpcodegen/net\r\n- https://aka.ms/azsdk/dpcodegen/python\r\n- https://aka.ms/azsdk/dpcodegen/java\r\n- https://aka.ms/azsdk/rlc/js\r\n- https://aka.ms/azsdk/dpcodegen/js (do not use unless told to do so by the archboard)\r\n\r\nAt a glance, add your emitter name to your `package.json`, along with the right options in the `tspconfig.yaml`.\r\n\r\n> **NOTE:** Generating all languages from the same folder may be complicated due to the preview status of the emitters and TypeSpec libraries, such as `typespec-azure-core` and `typespec-azure-resource-manager`.\r\n> It is recommended to have a unique language emitter in each `package.json` to avoid conflicts until all emitters and the TypeSpec libraries reach their first stable release.\r\n\r\nModify your `package.json` to include the necessary dependencies for the language emitter(s). Remember to run `npm install` after making changes to the file:\r\n\r\n```json\r\n{\r\n  \"name\": \"clients\",\r\n  \"dependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/rest\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@azure-tools/typespec-azure-core\": \"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\n\n\"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\r\n  # add \"@azure-tools/typespec-python\" to your package.json to generate Python code\r\n  - \"@azure-tools/typespec-python\"\r\n  # add \"@azure-tools/typespec-java\" to your package.json to generate Java code\r\n  - \"@azure-tools/typespec-java\"\r\n  # add \"@azure-tools/typespec-csharp\" to your package.json to generate C# code\r\n  - \"@azure-tools/typespec-csharp\"\r\n  # add \"@azure-tools/typespec-ts\" to your package.json to generate Typescript code\r\n  - \"@azure-tools/typespec-ts\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-java\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-csharp\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-ts\":\r\n    flavor: azure\r\n```\r\n\r\nSeveral language repositories utilize the `tsp-client` tool to simplify generating client libraries. For more information on the tool, see [Getting started with `tsp-client`](<./../Generating with tsp-client/tsp_client.md>).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n", "latency": 18.58451747894287, "response_length": 768}
{"query": "Is it possible to have a nullable primitive (e.g., Guid?) but also required in the spec at the same time?", "ground_truth": "It is possible to have a nullable primitive (e.g., Guid?) and also mark it as required in the specification. This approach allows a field to be explicitly marked as required, meaning some value must be supplied upon creation, which could be null. This method is useful for scenarios like patch request bodies where fields are optional but still need to be explicitly provided, even if null. However, this concept may conflict with the generation of C# models, where the need to mark a nullable value type as required can seem contradictory but serves specific use cases, such as ensuring a property is always sent over the wire, regardless of it being null or having a UUID value.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Models with additional properties\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\n### Discriminator\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\n### Nullable\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#basics.md\n- document_title: Creating a TypeSpec Library\n- document_link: https://typespec.io/docs/extending-typespec/basics\n- document_content: # extending-typespec#basics.md\n\n# Creating a TypeSpec Library\n\nA TypeSpec library is a package that includes TypeSpec types, decorators, emitters or linters. These libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional TypeSpec-specific metadata and conventions. This guide will walk you through the process of creating a new TypeSpec library, adding types to it, and distributing it on the public npm registry. Further sections will delve into the specifics of creating [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\r\n\r\nWhile this guide assumes that you'll be using [TypeScript](https://typescriptlang.org) to develop your library, you can skip the TypeScript-related steps if you prefer to use plain JavaScript.\n\n## Prerequisites\n\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\n\n## Setting up with templates\n\nYou can use the following templates:\r\n\r\n```bash\n\n# Create a TypeSpec library (Decorators & Linters) with TypeScript enabled.\n\ntsp init --template library-ts\n\n# Create a TypeSpec emitter with TypeScript enabled.\n\ntsp init --template emitter-ts\r\n```\n\n## Standard package structure\n\nHere's a high-level overview of what a TypeSpec package typically contains. Each of these files will be explained in more detail in the following sections.\r\n\r\n- **dist/index.js** - The main file for your Node library\r\n- **lib/main.tsp** - The main file for your TypeSpec types (optional)\r\n- **src/index.ts** - The main file for your Node library in TypeScript\r\n- **src/lib.ts** - The file that defines your TypeSpec library\r\n- **package.json** - Metadata about your TypeSpec package\n\n## Step 1: Initial setup\n\nYou can skip this step if you've used one of the templates above.\n\n### a. Initialize your package directory & package.json\n\nRun the following commands:\r\n\r\n```bash\r\nmkdir myLibrary\r\ncd myLibrary\r\nnpm init\r\n```\r\n\r\nAfter completing the wizard, you'll have a package.json file that defines your TypeSpec library.\r\n\r\nUnlike Node libraries which support CommonJS (cjs), TypeSpec libraries must be ECMAScript Modules. To specify this, open your `package.json` and add the following top-level configuration key:\r\n\r\n```jsonc\r\n  \"type\": \"module\"\r\n```\n\n### b. Install TypeSpec dependencies\n\nRun the following command:\r\n\r\n```bash\r\nnpm install --save-peer @typespec/compiler\r\n```\r\n\r\nYou might need to install other dependencies from the TypeSpec standard library. For example, if you want to use the metadata found in `@typespec/openapi`, you'll need to install that as well.\r\n\r\nRefer to the [dependency section](#step-3-defining-dependencies) for more information on defining your dependencies.\n\n### c. Define your main files\n\nYour package.json needs to refer to two main files: your Node module main file, and your TypeSpec main. The Node module main file is specified by the `\"main\"` key in your package.json file, and it defines the entry point for your library when it's used as a Node library. This must reference a JS file. The TypeSpec main defines the entry point for your library when it's used from a TypeSpec program, and it can reference either a JS file (when your library doesn't contain any TypeSpec types) or a TypeSpec file.\r\n\r\n```jsonc\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"typespec\": \"./lib/main.tsp\"\r\n    },\r\n    // Additional named export are possible\r\n    \"./experimental\": {\r\n      \"typespec\": \"./lib/experimental.tsp\"\r\n    },\r\n    // Wildcard export as well\r\n    \"./lib/*\": {\r\n      \"typespec\": \"./lib/*.tsp\"\r\n    }\r\n  }\r\n```\n\n### d. Install and initialize TypeScript\n\nRun the following commands:\r\n\r\n```bash\r\nnpm install -D typescript\r\nnpx tsc --init --strict\r\n```\r\n\r\nThis will create a `tsconfig.json` file. You'll need to make a few changes to this file. Open `tsconfig.json` and set the following settings:\r\n\r\n```jsonc\r\n\"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\r\n\"moduleResolution\": \"Node16\",\r\n\"target\": \"es2019\",\r\n\"rootDir\": \".\",\r\n\"outDir\": \"./dist\",\r\n\"sourceMap\": true,\r\n```\n\n### e. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\r\n\r\n:::caution\r\nIf `$lib` is not accessible from your library package (for example, `import {$lib} from \"my-library\";`), some features such as linting and emitter option validation will not be available.\r\n:::\r\n\r\nFor example:\r\n\r\n```typescript\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"myLibrary\",\r\n  diagnostics: {},\r\n} as const);\r\n\r\n// Optional but convenient, these are meant to be used locally in your library.\r\nexport const { reportDiagnostic, createDiagnostic } = $lib;\r\n```\r\n\r\nDiagnostics are used for linters and decorators, which are covered in subsequent topics.\n\n### f. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\r\n\r\n```typescript\r\n// Re-export $lib so the compiler can access it and register your library correctly.\r\nexport { $lib } from \"./lib.js\";\r\n```\n\n### g. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any changes made to TypeScript sources need to be compiled before they are visible to TypeSpec. To do this, run `npx tsc -p .` in your library's root directory. If you want to re-run the TypeScript compiler whenever files are changed, you can run `npx tsc -p . --watch`.\r\n\r\nAlternatively, you can add these as scripts in your `package.json` to make them easier to invoke. Consider adding the following:\r\n\r\n```jsonc\r\n  \"scripts\": {\r\n    \"clean\": \"rimraf ./dist ./temp\",\r\n    \"build\": \"tsc -p .\",\r\n    \"watch\": \"tsc -p . --watch\",\r\n    \"test\": \"node --test ./dist/test/**/*.test.js\", // Node 22+\r\n    \"test\": \"node --test ./dist/test/\"              // Node 18, 20\r\n  }\r\n```\r\n\r\nYou can then run `npm run build` or `npm run watch` to build or watch your library.\n\n### h. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when TypeSpec imports your library, the code to define the library is run. When we add decorators in later topics, this import will ensure those get exposed as well.\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n```\n\n## Step 2: Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It's strongly recommended to put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n\r\nnamespace MyLibrary;\r\nmodel Person {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\n\n## Step 3: Defining dependencies\n\nWhen defining dependencies in a TypeSpec library, follow these rules:\r\n\r\n- Use `peerDependencies` for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\r\n- Use `devDependencies` for other TypeSpec libraries that are only used in tests.\r\n- Use `dependencies` or `devDependencies` for any other packages, depending on whether they're used in library code or in test/dev scripts.\r\n\r\nTypeSpec libraries are defined using `peerDependencies` to avoid having multiple versions of the compiler or library running at the same time.\r\n\r\n**Example**\r\n\r\n```jsonc\r\n{\r\n  \"dependencies\": {\r\n    \"yaml\": \"~2.3.1\", // This is a regular package this library/emitter will use\r\n  },\r\n  \"peerDependencies\": {\r\n    // These are all TypeSpec libraries this library/emitter depends on\r\n    \"@typespec/compiler\": \"~0.43.0\",\r\n    \"@typespec/http\": \"~0.43.1\",\r\n    \"@typespec/openapi\": \"~0.43.0\",\r\n  },\r\n  \"devDependencies\": {\r\n    // This TypeSpec library is only used in the tests but is not required to use this library.\r\n    \"@typespec/versioning\": \"~0.43.0\",\r\n    // TypeScript is only used during development\r\n    \"typescript\": \"~5.0.2\",\r\n  },\r\n}\r\n```\n\n## Step 4: Testing your TypeSpec library\n\nTypeSpec provides a testing framework to assist in testing libraries. The examples here are shown using Node.js's built-in test framework (available in Node 20+), but any other JS test framework can be used that will provide more advanced features like vitest, which is used in this project.\n\n### a. Add devDependencies\n\nEnsure that you have the following in your `package.json`:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types/node\": \"~18.11.9\",\r\n  \"source-map-support\": \"^0.5.21\"\r\n}\r\n```\r\n\r\nAlso add a `vitest.config.ts` file at the root of your project.\r\n\r\n```ts\r\nimport { defineConfig, mergeConfig } from \"vitest/config\";\r\n\r\nexport default defineConfig({\r\n  test: {\r\n    environment: \"node\",\r\n    // testTimeout: 10000, // Uncomment to increase the default timeout\r\n    isolate: false, // Your test shouldn't have side effects to this will improve performance.\r\n  },\r\n});\r\n```\n\n### b. Define the testing library\n\nThe first step is to define how your library can be loaded from the test framework. This will allow your library to be reused by other library tests.\r\n\r\n1. Create a new file `./src/testing/index.ts` with the following content\r\n\r\n```ts\r\nimport { createTestLibrary, findTestPackageRoot } from \"@typespec/compiler/testing\";\r\n\r\nexport const MyTestLibrary = createTestLibrary({\r\n  name: \"<name-of-npm-pkg>\",\r\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\r\n  packageRoot: await findTestPackageRoot(import.meta.url),\r\n});\r\n```\r\n\r\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\r\n\r\n```jsonc\r\n{\r\n  // ...\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"default\": \"./dist/src/index.js\",\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n    },\r\n    \"./testing\": {\r\n      \"default\": \"./dist/src/testing/index.js\",\r\n      \"types\": \"./dist/src/testing/index.d.ts\",\r\n    },\r\n  },\r\n}\r\n```\n\n### c. Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There are 2 functions:\r\n\r\n- `createTestHost`: This is a lower-level API that provides a virtual file system.\r\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\r\n\r\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\r\n\r\n```ts\r\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\r\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\r\nimport { MyTestLibrary } from \"../src/testing/index.js\";\r\n\r\nexport async function createMyTestHost() {\r\n  return createTestHost({\r\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\r\n  });\r\n}\r\nexport async function createMyTestRunner() {\r\n  const host = await createMyTestHost();\r\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\r\n}\r\n```\n\n### d. Write tests\n\nAfter setting up that infrastructure you can start writing tests. By default Node.js will run all files matching these patterns:\r\n\r\n```\r\n**/*.test.?(c|m)js\r\n**/*-test.?(c|m)js\r\n**/*_test.?(c|m)js\r\n**/test-*.?(c|m)js\r\n**/test.?(c|m)js\r\n**/test/**/*.?(c|m)js\r\n```\r\n\r\n[See nodejs doc](https://nodejs.org/api/test.html)\r\n\r\n```ts\r\nimport { createMyTestRunner } from \"./test-host.js\";\r\nimport { describe, beforeEach, it } from \"node:test\";\r\n\r\ndescribe(\"my library\", () => {\r\n  let runner: BasicTestRunner;\r\n\r\n  beforeEach(async () => {\r\n    runner = await createMyTestRunner();\r\n  });\r\n\r\n  // Check everything works fine\r\n  it(\"does this\", async () => {\r\n    const { Foo } = await runner.compile(`\r\n      @test model Foo {}\r\n    `);\r\n    strictEqual(Foo.kind, \"Model\");\r\n  });\r\n\r\n  // Check diagnostics are emitted\r\n  it(\"errors\", async () => {\r\n    const diagnostics = await runner.diagnose(`\r\n       model Bar {}\r\n    `);\r\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\r\n  });\r\n});\r\n```\r\n\r\n#### e. `@test` decorator\r\n\r\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\r\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annotated with the `@test` decorator.\r\n\r\n```ts\r\nconst { Foo, CustomName } = await runner.compile(`\r\n  @test model Foo {}\r\n\r\n  model Bar {\r\n    @test(\"CustomName\") name: string\r\n  }\r\n`);\r\n\r\nFoo; // type of: model Foo {}\r\nCustomName; // type of : Bar.name\r\n```\r\n\r\n#### f. Install VS Code extension for the test framework\r\n\r\nIf you are using VS Code, you can install the [Node test runner](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing) to run your tests from the editor. This will also allow you to easily debug your tests.\r\n\r\nAfter installing the extension, you should be able to discover, run, and debug your tests from the test explorer.\n\n## Step 5: Publishing your TypeSpec library\n\nTo publish your library to the public npm registry, follow the instructions in the [npm documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Step 6: Importing your TypeSpec library\n\nOnce your TypeSpec library is published, users can install and use it just like any of the standard TypeSpec libraries. First, they need to install it:\r\n\r\n```bash\r\nnpm install $packageName\r\n```\r\n\r\nNext, they can import it into their TypeSpec program and use the namespace (if desired):\r\n\r\n```typespec\r\nimport \"MyLibrary\";\r\nusing MyLibrary;\r\n\r\nmodel Employee extends Person {\r\n  job: string;\r\n}\r\n```\n\n## Step 7: Next steps\n\nTypeSpec libraries can contain more than just types. For more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md), refer to the subsequent topics.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n", "latency": 6.807684659957886, "response_length": 79}
{"query": "How can I replace the knownValues with a named union in my PR, and will this change affect the generated swagger?", "ground_truth": "To replace the knownValues with a named union in your PR, use the pattern of defining a union type with specific variants and a string type to mark it as extensible. This approach should not cause a breaking change in the generated swagger. However, if it does introduce a breaking change, you may need assistance with getting the changes approved.", "response": "To replace `knownValues` with a named union in your PR, you can define a named union using the `union` keyword in TypeSpec. This allows you to explicitly name and reference the variants, which can be beneficial for emitters like OpenAPI to recognize the union as a named entity. For example:\n\n```typespec\nunion KnownValues {\n  option1: \"value1\",\n  option2: \"value2\",\n}\n```\n\nThis change will affect the generated Swagger (OpenAPI) output. Named unions are emitted as `oneOf` or `anyOf` constructs in OpenAPI, depending on whether the `@oneOf` decorator is applied. Additionally, named unions provide better clarity and structure in the generated schemas compared to inline union expressions.\n\nIf you are using the OpenAPI emitter, the named union will appear in the `components/schemas` section of the OpenAPI document, making it reusable and easier to reference across operations.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#unions.md\n- document_title: Unions\n- document_link: https://typespec.io/docs/language-basics/unions\n- document_content: # language-basics#unions.md\n\n# Unions\n\nUnions define a type that must be exactly one of several possible variants. There are two types of unions:\r\n\r\n- Union expressions\r\n- Named unions\n\n## Union expressions\n\nUnnamed unions, or union expressions, can be declared by combining the variants using the `|` operator.\r\n\r\n```typespec\r\nalias Breed = Beagle | GermanShepherd | GoldenRetriever;\r\n```\r\n\r\nIn this example, `Breed` can be either a `Beagle`, a `GermanShepherd`, or a `GoldenRetriever`.\n\n## Named unions\n\nNamed unions allow you to assign a name to the union and provide explicit variant references. Named unions are somewhat similar to [enums](./enums.md), but instead of having `string` or `numeric` values, they use [record models](./models.md).\r\n\r\nA named union can be declared with the `union` keyword. Its name must be an [`identifier`](./identifiers.md).\r\n\r\n```typespec\r\nunion Breed {\r\n  beagle: Beagle,\r\n  shepherd: GermanShepherd,\r\n  retriever: GoldenRetriever,\r\n}\r\n```\r\n\r\nThe above example is equivalent to the `Breed` alias mentioned earlier, with the difference that emitters can recognize `Breed` as a named entity and also identify the `beagle`, `shepherd`, and `retriever` names for the options. This format also allows the application of [decorators](./decorators.md) to each of the options.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Models with additional properties\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\n### Discriminator\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\n### Nullable\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#openapi.md\n- document_title: OpenAPI v3 emitter\n- document_link: https://typespec.io/docs/emitters/openapi3/openapi\n- document_content: # emitters#openapi3#openapi.md\n\n# OpenAPI v3 emitter\n\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\r\n\r\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\n\n## Server Details\n\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\r\n\r\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\r\n\r\n```typespec\r\n@server(\"https://api.example.com/v1\", \"Primary production endpoint\")\r\n@server(\"https://api-dev.example.com/v1\", \"Development endpoint\")\r\nnamespace MyService;\r\n```\n\n## Operations\n\nEach TypeSpec operation is converted into an OpenAPI operation.\n\n### HTTP Method\n\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\r\n\r\n- `@get`\r\n- `@post`\r\n- `@put`\r\n- `@patch`\r\n- `@delete`\r\n\r\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\r\n\r\n```typespec\r\n// Explicitly declared as GET /{id}\r\n@get\r\nop getUser(@path id: string): User;\r\n\r\n// Explicitly declared as POST /\r\n@post\r\nop createUser(user: User): User;\r\n\r\n// Automatically detected as GET /{id}\r\nop getUser(@path id: string): User;\r\n\r\n// Automatically detected as POST /\r\nop createUser(user: User): User;\r\n```\n\n### Operation Path\n\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\r\n\r\n- Individual operations\r\n- Interfaces (groups of operations)\r\n- Namespaces\r\n\r\nWhen you apply routes to multiple levels, they're combined to form the complete path:\r\n\r\n```typespec\r\n@route(\"/api\")\r\nnamespace MyService {\r\n  @route(\"/users\")\r\n  interface Users {\r\n    // Results in GET /api/users/{id}\r\n    @route(\"/{id}\")\r\n    @get\r\n    getUser(@path id: string): User;\r\n  }\r\n}\r\n```\r\n\r\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\r\n\r\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\r\n\r\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### Description\n\nThe operation's description comes from the documentation of the TypeSpec operation.\r\n\r\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n\r\n@doc(\"Retrieves a user by their unique identifier.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no documentation is provided, the description field is omitted.\r\n\r\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\n\n### Summary\n\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\n@summary(\"Get a User by ID.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no `@summary` is provided, the summary field is omitted.\r\n\r\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\n\n### Operation ID\n\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\r\n\r\n```typespec\r\n@operationId(\"getUserById\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nIf not explicitly defined, the operation ID defaults to:\r\n\r\n- The operation name (when the operation is not in an interface)\r\n- The interface name followed by the operation name (when in an interface)\r\n\r\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\n\n### Parameters and Request Body\n\nTypeSpec operation parameters map to OpenAPI parameters and request body.\r\n\r\n#### Parameter Location\r\n\r\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\r\n\r\n- `@query` - Query parameter in the URL\r\n- `@header` - HTTP header parameter\r\n- `@path` - Path parameter in the URL\r\n\r\nParameters without these decorators are assumed to be in the request body.\r\n\r\n```typespec\r\nop createUser(\r\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\r\n  // to the `content-type` header\r\n  @header contentType: string,\r\n\r\n  @query include: string,\r\n  @path id: string,\r\n\r\n  // The request body will be a JSON object `{ \"user\": <User> }`\r\n  user: User, // This goes in the request body\r\n): User;\r\n```\r\n\r\n#### Request Body\r\n\r\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\r\n\r\n```typespec\r\n// The request body will be a JSON object that _only_ contains the User at the top level.\r\nop createUser(@body user: User): User;\r\n```\r\n\r\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\r\n\r\n```typespec\r\nop updateUser(@path id: string, @body user?: User): User;\r\n```\r\n\r\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../..\n\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\n### Responses\n\nstatus code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\r\n\r\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\nThe operation's return type(s) translate into OpenAPI responses.\r\n\r\n#### Status Codes\r\n\r\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  body: User;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse;\r\n```\r\n\r\nYou can define multiple response types to handle different status codes:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  user: User;\r\n}\r\n\r\nmodel UserNotFoundResponse {\r\n  @statusCode\r\n  code: 404;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\r\n```\r\n\r\n#### Error Responses\r\n\r\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \"default\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\r\n\r\n```typespec\r\n@error\r\nmodel ErrorResponse {\r\n  @statusCode\r\n  code: 404 | 500;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): User | ErrorResponse;\r\n```\r\n\r\n#### Response Body\r\n\r\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode code: 200;\r\n\r\n  // If the status code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\n\n### Tags\n\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\r\n\r\n```typespec\r\n@tag(\"Users\")\r\nop getUser(id: string): User;\r\n\r\n// Or at interface/namespace level\r\n@tag(\"Users\")\r\ninterface UserOperations {\r\n  getUser(id: string): User;\r\n  createUser(@body user: User): User;\r\n}\r\n```\r\n\r\nTags from operations, interfaces, and enclosing namespaces are combined.\r\n\r\n[tag-decorator]: ../../standard-library/built-in-decorators.md#@tag\n\n### Deprecated\n\nMark an operation as deprecated using the (built-in) `#deprecated` directive.\r\n\r\n```typespec\r\n#deprecated \"Use getUser instead\"\r\nop fetchUser(id: string): User;\r\n```\r\n\r\nThis sets the `deprecated` field to `true` in the OpenAPI operation.\n\n### External Documentation\n\nAdd external documentation links using the [(OpenAPI) `@externalDocs` decorator](../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.externalDocs):\r\n\r\n```typespec\r\n@externalDocs(\"https://example.com/docs/users\", \"Additional user documentation\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nThe external documentation links are specific to the OpenAPI emitter and will not be used by any other emitters unless they are designed to interoperate with OpenAPI.\n\n### Specification Extensions\n\nAdd custom OpenAPI extensions for your use cases using the [(OpenAPI) `@extension` decorator][openapi-extension-decorator].\r\n\r\n```typespec\r\n@extension(\"x-ms-pageable\", #{ nextLinkName: \"nextLink\" })\r\nop listUsers(): UserList;\r\n```\r\n\r\nThe first argument to `@extension` becomes a key in the operation object, and the second argument is any JSON/YAML-like value. This decorator may be used to add arbitrary customization/extension to many OpenAPI constructs including schemas for TypeSpec types, operations, etc.\r\n\r\n[openapi-extension-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.extension\n\n## Models and Enums\n\nTypeSpec models and enums convert to OpenAPI schemas.\n\n### Schema Location\n\nModels are handled differently based on how they're defined:\r\n\r\n- **Named models**: defined in `components/schemas` section.\r\n- **Inline models**: defined inline where used.\r\n- **Template instances**: treated as inline unless they have a [(built-in) `@friendlyName` decorator][friendlyname], which causes them to be treated as named models.\r\n\r\n[friendlyname]: ../../standard-library/built-in-decorators.md#@friendlyName\n\n### Type Mapping\n\nThis table shows how TypeSpec types map to OpenAPI/JSON Schema types:\r\n\r\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\r\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\r\n| `int32`          | `type: integer, format: int32`    |                                                                           |\r\n| `int64`          | `type: integer, format: int64`    |                                                                           |\r\n| `float32`        | `type: number, format: float`     |                                                                           |\r\n| `float64`        | `type: number, format: double`    |                                                                           |\r\n| `string`         | `type: string`                    |                                                                           |\r\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\r\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `boolean`        | `type: boolean`                   |                                                                           |\r\n| `plainDate`      | `type: string, format: date`      |                                                                           |\r\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n### Data Validation Decorators\n\nThe tables below show how various built-in decorators add validation constraints to model properties:\r\n\r\n**For numeric types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                      |\r\n| ------------------ | -------- | --------------------------- | ---------------------------- |\r\n| `@minValue(value)` | built-in | `minimum: value`            | `@minValue(0) age: int32;`   |\r\n| `@maxValue(value)` | built-in | `maximum: value`            | `@maxValue(120) age: int32;` |\r\n\r\n**For string types:**\r\n\r\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Example                                 |\r\n| ------------------- | -------- | --------------------------- | --------------------------------------- |\r\n| `@format(name)`     | built-in | `format: name`              | `@format(\"email\") email: string;`       |\r\n| `@minLength(value)` | built-in | `minLength: value`          | `@minLength(8) password: string;`       |\r\n| `@maxLength(value)` | built-in | `maxLength: value`          | `@maxLength(50) name: string;`          |\r\n| `@pattern(regex)`   | built-in | `pattern: regex`            | `@pattern(\"^[A-Z]{2}$\") state: string;` |\r\n| `@secret`           | built-in | `format: password`          | `@secret password: string;`             |\r\n\r\n**For array types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                         |\r\n| ------------------ | -------- | --------------------------- | ------------------------------- |\r\n| `@minItems(value)` | built-in | `minItems: value`           | `@minItems(1) tags: string[];`  |\r\n| `@maxItems(value)` | built-in | `maxItems: value`           | `@maxItems(10) tags: string[];` |\n\n### Using External References\n\nThe [`@useRef` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.useRef) configures a TypeSpec model with a reference to an external schema that will be used in place of references to that model's schema:\r\n\r\n```typespec\r\n// Whenever the OpenAPI emitter would try to reference the Sku model's schema, it will reference the below\r\n// external schema instead.\r\n@useRef(\"common.json#/components/schemas/Sku\")\r\nmodel Sku {\r\n  name: string;\r\n  tier: string;\r\n}\r\n```\n\n### Enums\n\nTypeSpec enums and unions convert to OpenAPI enum schemas. You can define enums in two ways:\r\n\r\n**TypeSpec enum declaration:**\r\n\r\n```typespec\r\nenum Color {\r\n  Red: \"red\",\r\n  Blue: \"blue\",\r\n  Green: \"green\",\r\n}\r\n```\r\n\r\n**Union of literal values:**\r\n\r\n```typespec\r\nmodel Settings {\r\n  // `status` can be any of the following strings.\r\n  status: \"Running\" | \"Stopped\" | \"Failed\";\r\n}\r\n```\r\n\r\nBoth approaches result in an OpenAPI schema with a type of `string` and an `enum` array containing the specified values.\n\n## Model Composition\n\nTypeSpec offers several ways to compose models.\n\n### Spread Operator\n\nThe spread operator copies properties from one model to another without creating a semantic relationship:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n}\r\n\r\nmodel UserProfile {\r\n  name: string;\r\n\r\n  // Copy all the properties of Address into this model as if they were declared here.\r\n  ...Address;\r\n\r\n  email: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, the result is a flat schema named `UserProfile` with the properties of `Address` declared inline.\n\n### Extends Keyword\n\nThe `extends` keyword creates an inheritance relationship:\r\n\r\n```typespec\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  breed: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, this creates a schema `Dog` that references the schema `Pet` using `allOf`.\r\n\r\n#### Discriminated Union with Extends\r\n\r\nYou can create discriminated type hierarchies using the `@discriminator` decorator:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  kind: \"dog\"; // Must be a literal string value\r\n  breed: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  kind: \"cat\"; // Must be a literal string value\r\n  whiskerCount: int32;\r\n}\r\n```\r\n\r\nThis creates a discriminator object in the OpenAPI schema with a mapping from discriminator values to schemas.\n\n### Is Keyword\n\nThe `is` keyword creates a new model with the same shape as another model:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n}\r\n\r\nmodel ShippingDetails is Address {\r\n  zipCode: string; // Additional property\r\n}\r\n```\r\n\r\nIn OpenAPI, `ShippingDetails` is an independent schema with all properties from `Address` plus `zipCode`.\n\n### Unions\n\nUnions represent values that could be one of several types:\r\n\r\n**Union type alias:**\r\n\r\n```typespec\r\nalias PetType = Dog | Cat | Hamster;\r\n```\r\n\r\n**Named union declaration:**\r\n\r\n```typespec\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\r\n\r\nBy default, unions emit as `anyOf` in OpenAPI. You can use the [`@oneOf` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.oneOf) on a named union declaration to emit it as `oneOf` instead:\r\n\r\n```typespec\r\n@oneOf\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\n\n## Encoding and Formats\n\nThe `@encode` decorator lets you control how TypeSpec types are serialized. The general pattern is:\r\n\r\n```typespec\r\n@encode(\"<encoding name>\", encodingTargetType) property: trueType;\r\n```\r\n\r\nWhere:\r\n\r\n- `\"<encoding name>\"`: The format or method of encoding (e.g., `\"base64\"`, `\"rfc3339\"`, `\"unixTimestamp\"`)\r\n- `encodingTargetType`: The type to encode to and decode from (e.g., `int32`, `string`)\r\n- `trueType`: The \"true\" semantic data type of the property (e.g., `duration`, `utcDateTime`)\r\n\r\nThe emitter follows these rules to determine the OpenAPI format:\r\n\r\n1. For date/time types:\r\n\r\n   - `@encode(\"rfc3339\", string) _: utcDateTime` → `type: string, format: date-time`\r\n   - `@encode(\"rfc7231\", string) _: utcDateTime` → `type: string, format: http-date`\r\n   - `@encode(\"unixTimestamp\", int32) _: utcDateTime` → `type: integer, format: unixtime`\r\n\r\n2. For other types, the format comes from either the encoding name or the `encodingTargetType`'s format.\r\n\r\nThis table summarizes common encodings:\r\n\r\n| TypeSpec with encoding                           | OpenAPI 3 result                  |\r\n| ------------------------------------------------ | --------------------------------- |\r\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    |\r\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  |\r\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` |\r\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` |\n\n## Security Definitions\n\nUse the [(HTTP) `@useAuth` decorator][http-useauth-decorator] to define authentication and security schemes for your API.\r\n\r\nFor example, to define an authentication/authorization scheme based on Microsoft Entra ID:\r\n\r\n```typespec\r\n@useAuth(EntraIDToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** Microsoft Entra ID OAuth2 Flow */\r\nmodel EntraIDToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\nAuthentication/authorization is a complex and highly configurable feature. See the [`@useAuth` decorator documentation for more information][http-useauth-decorator].\r\n\r\n[http-useauth-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.useAuth\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#x-ms-examples.mdx\n- document_title: x-ms-examples example files\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\n- document_content: # migrate-swagger#faq#x-ms-examples.mdx\n\n# x-ms-examples example files\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe `x-ms-examples` is automatically populated in the generated OpenAPI 2.0 when using the `typespec-autorest` emitter.\r\nThe examples must be placed in the `examples-directory` (default to `{project-root}/examples`) and have the `operationdId` property.\r\n\r\n:::caution\r\nDo not use `@extension(\"x-ms-examples\", \"<value>\")`.\r\n:::\n\n## Example structure\n\nExample below assume `example-directory` is `{project-root}/examples`.\r\n\r\n- Single version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - example1.json\r\n  - example2.json\r\n</FileTree>\r\n\r\n- Multi version structure\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- examples/\r\n  - 2021-01-01/\r\n    - example1.json\r\n    - example2.json\r\n  - 2021-01-02/\r\n    - example1.json\r\n    - example2.json\r\n</FileTree>\n\n## Generate the examples\n\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\r\n\r\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\r\n\r\n```bash\r\noav generate-examples openapi.json\r\n```\r\n\r\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\r\n\r\n- include `title` field and make sure it is descriptive and unique for each operation.\r\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\r\n\r\n:::caution\r\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\r\n:::\n", "latency": 25.06604790687561, "response_length": 880}
{"query": "Is it possible to replace the value inside the CSPROJ with a key in tspconfig.yaml?", "ground_truth": "Yes, it is possible to replace the value inside the CSPROJ with a key in tspconfig.yaml by using the `arm-types-dir` as an autorest option.", "response": "Yes, it is possible to replace values inside a CSPROJ file with keys defined in the `tspconfig.yaml` file using variable interpolation. TypeSpec supports variable interpolation for built-in variables, environment variables, and configuration file parameters. You can define parameters or environment variables in `tspconfig.yaml` and reference them using `{<expression>}` syntax. For example, you can define a parameter in `tspconfig.yaml` and use it to dynamically set values in your CSPROJ file.", "context": "- document_dir: typespec_docs\n- document_filename: handbook#configuration#configuration.mdx\n- document_title: Configuration\n- document_link: https://typespec.io/docs/handbook/configuration/configuration\n- document_content: # handbook#configuration#configuration.mdx\n\n# Configuration\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe TypeSpec compiler and libraries can be configured either via a configuration-file or command line flags.\n\n## Configuration file\n\nTypeSpec configuration can be provided via the `tspconfig.yaml` configuration file.\n\n### Discovery\n\nThe TypeSpec compiler will look for the closest `tspconfig.yaml` file located in the same directory or closest parent directory from the TypeSpec entrypoint.\r\n\r\nFor example if running `tsp compile /dev/foo/bar/main.tsp`, the compiler will lookup the file at the folllowing paths (in order):\r\n\r\n- `/dev/foo/bar/tspconfig.yaml`\r\n- `/dev/foo/tspconfig.yaml`\r\n- `/dev/tspconfig.yaml`\r\n- `/tspconfig.yaml`\n\n### Schema\n\nThe file is a `yaml` document with the following structure. See the [next section](#typespec-configuration-options) for details on each option.\r\n\r\n```typespec\r\nmodel TypeSpecProjectSchema {\r\n  extends?: string;\r\n  parameters?: Record<{default: string}>\r\n  `environment-variables`?: Record<{default: string}>\r\n  `warn-as-error`?: boolean;\r\n  `output-dir`?: string;\r\n  `trace`?: string | string[];\r\n  imports?: string[];\r\n  emit?: string[];\r\n  `dry-run`?: boolean;\r\n  options?: Record<unknown>;\r\n  linter?: LinterConfig;\r\n}\r\n\r\nmodel LinterConfig {\r\n  extends?: RuleRef[];\r\n  enable?: Record<RuleRef, boolean>;\r\n  disable?: Record<RuleRef, string>;\r\n}\r\n```\n\n### Extending Project Files\n\nThere may be instances where you want to build different folders with varying options (such as different emitters), but still want to share some common configurations.\r\n\r\nIn such cases, you can use the `extends` property in the configuration file.\r\n\r\nFor instance, in `<my-pkg>/tspconfig.yaml`:\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  emitter1:\r\n    some-option: my-name\r\n  emitter2:\r\n    some-other-option: This is a title\r\n```\r\n\r\nin `<my-pkg>/proj2/tspconfig.yaml`, enable `emitter1` using the options specified in the parent `tspconfig.yaml`\r\n\r\n```yaml title=proj2/tspconfig.yaml\r\nextends: ../tspconfig.yaml\r\nemit:\r\n  - emitter1\r\n```\n\n### Variable interpolation\n\nThe TypeSpec project file provides variable interpolation using:\r\n\r\n- built-in variables\r\n- environment variables\r\n- config file parameters\r\n- emitter options can reference each other\r\n\r\nVariable interpolation is done using an variable expression surrounded by `{` and `}`. (`{<expression>}`)\r\n\r\nExamples:\r\n\r\n- `{output-dir}/my-path`\r\n- `{env.SHARED_PATH}/my-path`\n\n### Interpolation of Emitter Path Config\n\nfile can specify which environment variables it can interpolate.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be used in the default value of these environment variables.\r\n\r\nThese environment variables can then be referred to by their name in a variable interpolation expression, using the `env.` prefix.\r\n\r\nAll environment variables must have a default value.\r\n\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nenvironment-variables:\r\n  BASE_DIR:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {env.BASE_DIR}/output\r\n```\r\n\r\n#### Emitter Options\r\n\r\nEmitter options can refer to each other by using the other option's name as the variable expression.\r\n\r\nInterpolation is only possible among emitter options from the same emitter.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  @typespec/openapi3:\r\n    emitter-output-dir: {output-dir}/{emitter-sub-folder}\r\n    emitter-sub-folder: bar\r\n\r\n```\r\n\r\nEmitter options support a nested structure, enabling complex configurations.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  emitter-sub-folder:\r\n    sub-folder: bar\r\n```\r\n\r\nTo set these values via the CLI, use dots to navigate deeper levels in the definition. `--option \"<option-name>.<nested-option-name>=<value>\"`\r\nDue to this capability, emitter option names should not contain a `.` in their name.\n\n|\r\n| `emitter-name`             | emitter options          | Name of the emitter                                                                  |\r\n| `service-name`             | service name             | Name of the service                                                                  |\r\n| `service-name-if-multiple` | service name if multiple | Name of the service if multiple, undefined if one                                    |\r\n\r\n#### Project Parameters\r\n\r\nA TypeSpec project file can define certain parameters that can subsequently be specified through the CLI.\r\nParameters can be organized in a nested structure, to access different levels of the structure, use dots (`.`) in the variable expression.\r\nTherefore, parameter names should not contain `.` in their name.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be utilized in the default value of these parameters.\r\n\r\nThese parameters can then be referred to by their name in a variable interpolation expression.\r\n\r\nAll parameters must have a default value.\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nparameters:\r\n  base-dir:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {base-dir}/output\r\n```\r\n\r\nThe parameter can then be specified via `--arg` in this format `--arg \"<parameter-name>=<value>\"` and for nested structures `--arg \"<parameter-name>.<nested-parameter-name>=<value>\"`\r\n\r\n```bash\r\ntsp compile . --arg \"base-dir=/path/to/base\"\r\n```\r\n\r\n#### Environment variables\r\n\r\nA TypeSpec project file can specify which environment variables it can interpolate.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be used in the default value of these environment variables.\r\n\r\nThese environment variables can then be referred to by their name in a variable interpolation expression, using the `env.` prefix.\r\n\r\nAll environment variables must have a default value.\r\n\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nenvironment-variables:\r\n  BASE_DIR:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {env.\n\nCertain emitter configurations can be interpolated using a specific rule designed to collapse a path.\r\n\r\nIf a variable is succeeded by a `/` or `.` and the emitter responsible for interpolating the config doesn't supply that variable, the path segment will be omitted.\r\n\r\nFor instance, consider the following config value: `{service-name}/output.{version}.json`\r\nHere's what would be produced:\r\n\r\n| Service name value | Version value | Result                    |\r\n| ------------------ | ------------- | ------------------------- |\r\n| `\"PetStore\"`       | `\"v1\"`        | `PetStore/output.v1.json` |\r\n| `\"PetStore\"`       | `undefined`   | `PetStore/output.json`    |\r\n\r\n#### Built-in variables\r\n\r\n| Variable name              | Scope                    | Description                                                                          |\r\n| -------------------------- | ------------------------ | ------------------------------------------------------------------------------------ |\r\n| `cwd`                      | \\*                       | Points to the current working directory                                              |\r\n| `project-root`             | \\*                       | Points to the the tspconfig.yaml file containing folder.                             |\r\n| `output-dir`               | emitter options          | Common `output-dir` See [output-dir](#output-dir---configure-the-default-output-dir) |\r\n| `emitter-name`             | emitter options          | Name of the emitter                                                                  |\r\n| `service-name`             | service name             | Name of the service                                                                  |\r\n| `service-name-if-multiple` | service name if multiple | Name of the service if multiple, undefined if one                                    |\r\n\r\n#### Project Parameters\n\n## TypeSpec Configuration Options\n\n| Config          | Cli                       | Description                                              |\r\n| --------------- | ------------------------- | -------------------------------------------------------- |\r\n| `output-dir`    | `--output-dir`            | Default output directory                                 |\r\n| `config`        | `--config`                | Path to config file or folder to search for config file. |\r\n| `trace`         | `--trace`                 | Specify tracing area to enable                           |\r\n| `warn-as-error` | `--warn-as-error`         | Treat warning as error                                   |\r\n| `imports`       | `--import`                | Additional imports to include                            |\r\n| `emit`          | `--emit`                  | Emitter configuration                                    |\r\n| `options`       | `--option` or `--options` | Emitter configuration                                    |\r\n| `dry-run`       | `--dry-run`               | Tell emitters to run in dryRun mode                      |\r\n| `linter`        |                           | Linter configuration                                     |\n\n### `output-dir` - Configure the default output dir\n\nSpecify the common output-dir for all emitters. See [this](#configuring-output-directory) to configure per emitter.\r\n\r\n```yaml title=tspconfig.yaml\r\noutput-dir: {cwd}/typespec-build\r\n```\r\n\r\nOutput dir can be provided using the `--output-dir` cli flag\r\n\r\n```bash\r\ntsp compile . --output-dir \"./typespec-build\"\r\n```\r\n\r\nOutput dir must be an absolute path in the config. Use `{cwd}` or `{project-root}` to explicitly specify what it should be relative to.\r\n\r\nSee [output directory configuration for mode details](#configuring-output-directory)\n\n### `trace` - Configure what to trace\n\nConfigure what area to trace. See [tracing docs](./tracing.md)\r\n\r\n```yaml title=tspconfig.yaml\n\n# Trace all.\n\ntrace: *\n\n# or specific areas\n\ntrace:\r\n  - import-resolution\r\n  - projection\r\n```\r\n\r\nTrace can be provided using the `--trace` cli flag\r\n\r\n```bash\r\ntsp compile . --trace import-resolution --trace projection\r\n```\n\n### `warn-as-error` - Treating Warnings as Errors\n\nAll warnings will be treated and emitted as errors, resulting in a non-zero exit code in the event of a warning.\r\n\r\n**It is recommended to use this feature in Continuous Integration (CI) to ensure all warnings are addressed.**\r\n\r\n```yaml title=tspconfig.yaml\r\nwarn-as-error: true\r\n```\r\n\r\nor via the cli\r\n\r\n```bash\r\ntsp compile . --warn-as-error\r\n```\n\n### `--ignore-deprecated`\n\nSuppress all `deprecated` diagnostics that are raised when declarations are marked with the `#deprecated` directive.\r\n\r\n```bash\r\ntsp compile . --ignore-deprecated\r\n```\n\n### `imports` - Configure additional imports\n\n```yaml title=tspconfig.yaml\r\nimports:\r\n  - sidecar.tsp\r\n```\r\n\r\nSpecify additional TypeSpec files to import\r\n\r\n```bash\r\ntsp compile . --import \"sidecar.tsp\"\r\n```\n\n### `emit` - Specifying which emitters to run\n\nSpecify which emitters to use and their options if applicable.\r\n\r\nThe value can be the name of an emitter or a path to the emitter package/entrypoint.\r\n\r\n```yaml title=tspconfig.yaml\r\nemit:\r\n  - emitter1 # Package name\r\n  - /path/to/emitter2 # Give a path to an emitter\r\n```\r\n\r\nor via the cli\r\n\r\n```bash\r\ntsp compile . --emit emitter1 --emit /path/to/emitter2\r\n```\n\n### `options` - Configuring emitters\n\nEmitters can define a set of options, those can be set as the value of the map.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  # Enable and configure emitter1\r\n  emitter1:\r\n    option1: \"option1-value\"\r\n    option2: \"option1-value\"\r\n  # Only enable emitter2\r\n  emitter2: true\r\n```\r\n\r\nEmitters options can also be provided using the `--option` in this format `--option=<emitterName>.<optionName>=<value>`\r\n\r\n```bash\r\ntsp compile . --option \"emitter1.option1=option1-value\"\r\n```\r\n\r\nOptions specified via the CLI take precedence over the ones specified in `tspconfig.yaml`.\r\n\r\n#### Emitters built-in options\r\n\r\n##### `emitter-output-dir`\r\n\r\nRepresent the path where the emitter should be outputing the generated files.\r\n\r\nDefault: `{output-dir}/{emitter-name}`\r\n\r\nSee [output directory configuration for mode details](#configuring-output-directory)\n\n### `linter` - Setting Up Linters\n\nThis allows you to configure the linter rules to be enabled in this repository. When referencing a rule or ruleset, use their ID, which follows the format `<libraryName>:<ruleName>`.\r\n\r\n```yaml\r\nlinter:\r\n  extends: # Extend `recommended` ruleset from @typespec/best-practices library\r\n    - \"@typespec/best-practices/recommended\"\r\n\r\n  enable: # Explicitly enable some rules\r\n    \"@typespec/best-practices/no-x\": true\r\n\r\n  disable: # Disable some rules defined in one of the ruleset extended.\r\n    \"@typespec/best-practices/no-y\": \"This rule cannot be applied in this project because X\"\r\n```\n\n## CLI Flags for Emitter Control\n\n### `--no-emit`\n\nThis flag disables emitters. Emitters will not run, and no files will be emitted.\r\n\r\nThis flag can also be used to suppress the \"There are no emitters\" warning.\r\n\r\n```yaml title=tspconfig.yaml\r\ntsp compile . --no-emit\r\n```\n\n### `--dry-run`\n\nThis flag tells compatible emitters to run in dry-run mode. In this mode, emitters will not emit any files, but will still run and log diagnostics.\r\n\r\n```yaml title=tspconfig.yaml\r\ntsp compile . --dry-run\r\n```\n\n## Other Command line flags\n\n### `--config`\n\nSpecify a different config file\r\n\r\n```bash\r\ntsp compile . --config ./tspconfig.alt.yaml\r\n```\n\n### `--watch`\n\nStart the tsp compiler in watch mode: watch for file changes and compile on save.\r\n\r\n```bash\r\ntsp compile . --watch\r\n```\r\n\r\n:::caution\r\nKnown issue: the watch mode does not pickup changes in JS files that are indirectly included (only imported via another JS file.)\r\n:::\n\n### `--nostdlib`\n\nDon't load the TypeSpec standard library.\r\n\r\n```bash\r\ntsp compile . --nostdlib\r\n```\n\n### `--version`\n\nLog the version of the tsp compiler.\r\n\r\n```bash\r\ntsp compile . --version\r\n```\n\n### `--pretty`\n\n**Default: `true`**\r\n\r\nEnable/Disable pretty logging (colors, diagnostic preview, etc.).\r\n\r\n```bash\r\ntsp compile . --pretty=false\r\n```\n\n## Configuring Output Directory\n\nThe TypeSpec compiler assigns a unique output directory to each emitter that runs, in order to minimize conflicts. By default, the output directory of an emitter is set to:\r\n\r\n```\r\n{output-dir}/{emitter-name}\r\n```\r\n\r\nwhere:\r\n\r\n- `output-dir` is the common output directory for the compiler, which can be configured via `--output-dir`.\r\n- `emitter-name` is the name of the emitter package (for example, `/openapi3`).\r\n\r\nFor instance, if the emitters `@typespec/openapi3` and `@typespec/jsonschema` are given, the default output folder structure would be:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{project-root}/tsp-output\r\n  - @typespec:\r\n    - openapi3\r\n      - ... openapi3 files ...\r\n    - jsonschema\r\n      - ... json schema files ...\r\n</FileTree>\r\n\r\nYou can change the compiler's `output-dir` with `--output-dir` or by setting that value in the tspconfig.yaml, which would result in the following structure:\r\n\r\n```bash\r\n--output-dir={cwd}/my-custom-output-dir\r\n```\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{cwd}/my-custom-output-dir\r\n  - @typespec:\r\n    - openapi3\r\n      - ... openapi3 files ...\r\n    - jsonschema\r\n      - ... json schema files ...\r\n</FileTree>\r\n\r\nTo change a specific emitter's output directory, you can set the `emitter-output-dir` option for that emitter:\r\n\r\n```bash\r\n--option \"@typespec/openapi3.emitter-output-dir={project-root}/openapispec\"\r\n```\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{project-root}\r\n  - openapispec\r\n    - ... openapi3 files ...\r\n  - tsp-output\r\n    - @typespec\r\n      - jsonschema\r\n        - ... json schema files ...\r\n</FileTree>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest#index.md\n- document_title: TypeSpec AutoRest Library\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/index\n- document_content: # emitters#typespec-autorest#index.md\n\n# TypeSpec AutoRest Library\n\nThis is a TypeSpec library that will emit an enriched OpenAPI 2.0 specification that can be consumed by AutoRest.\r\nThe generated OpenAPI spec will have custom `x-ms-` extensions properties and conform to standards required by AutoRest to generate a more accurate SDK.\n\n## Getting started\n\n1. Include `@azure-tools/typespec-autorest` dependencies in package.json\r\n\r\n```json\r\n{\r\n  ...\r\n  \"dependencies\": {\r\n    ...\r\n    \"@azure-tools/typespec-autorest\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\n2. Run `npm install` to install the dependency\r\n3. Import `@azure-tools/typespec-autorest` in your `main.tsp` file\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-autorest\";\r\n```\r\n\r\n4. Run `tsp compile`. This will result in a `swagger.json` file crated in `./tsp-output/swagger.json`\n\n## Use in autorest\n\nGenerate the OpenAPI spec as shown above then run autorest cli directly on it.\r\n\r\n```bash\r\nautorest --input-file=<path/to/generated/file.json>\n\n# Example\n\nautorest --input-file=./tsp-output/@azure-tools/typespec-autorest/openapi.json --python\r\n```\n\n## Configuration\n\n### Emitter options:\n\nEmitter options can be configured via the `tspconfig.yaml` configuration:\r\n\r\n```yaml\r\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    <optionName>: <value>\n\n# For example\n\n`openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\r\n\r\nDirectory where the x-ms-examples are located so the emitter can automatically link.\r\n\r\n#### `version`\r\n\r\nSelect which version should be emitted if the spec support versioning. By default all the version with be emitted in this format `<outputFileName>.<version>.json`\n\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    output-file: my-custom-swagger.json\r\n```\r\n\r\nor via the command line with\r\n\r\n```bash\r\n--option \"@azure-tools/typespec-autorest.<optionName>=<value>\"\r\n\r\n--option \"@azure-tools/typespec-autorest.output-file=my-custom-swagger.json\"\r\n```\r\n\r\n#### `azure-resource-provider-folder`\r\n\r\n`resource-manager` directory under your service folder are located so the emitter can emit correct sub-folder structure and swagger files for each of the API versions. You must specify it for ARM specs with folder path relative to the TypeSpec files.\r\n\r\n#### `emitter-output-dir`\r\n\r\nSet the emitter output-dir. [See here](https://typespec.io/docs/handbook/configuration#emitter-output-dir)\r\n\r\n#### `output-file`\r\n\r\nConfigure the name of the swagger output file relative to the `output-dir`.\r\n\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- version: Version of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\r\n\r\nExample: Single service no versioning\r\n\r\n- `openapi.yaml`\r\n\r\nExample: Multiple services no versioning\r\n\r\n- `openapi.Org1.Service1.yaml`\r\n- `openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\n\n### `new-line`\n\nSet the newline character for emitting files. Can be either:\r\n\r\n- `lf`(Default)\r\n- `crlf`\n\n### `omit-unreachable-types`\n\nOnly include types referenced via an operation.\n\n## Decorators\n\n- [@collectionFormat](#collectionformat)\r\n- [@example](#example)\r\n- [@useRef](#useref)\n\n### @collectionFormat\n\nSyntax:\r\n\r\n```\r\n@collectionFormat(formatString)\r\n```\r\n\r\n`@collectionFormat` specifies array property type serialization format. Valid format strings are \"csv\", \"multi\", \"ssv\", \"tsv\", \"pipes\" though \"csv\" or \"multi\" are recommended.\r\n\r\n`@collectionFormat` can only be specified on model properties that are arrays.\n\n### @example\n\nSyntax:\r\n\r\n```\r\n@example(pathOrUri, title)\r\n```\r\n\r\n`@example` attaches example files to an operation. Multiple examples can be specified.\r\n\r\n`@example` can only be specified on operations.\n\n### @useRef\n\nSyntax:\r\n\r\n```\r\n@useRef(urlString)\r\n```\r\n\r\n`@useRef` is used to replace the TypeSpec model type in emitter output with a pre-existing named OpenAPI schema such as ARM common types.\n\n## How to\n\n### Include `x-ms-skip-url-encoding` in `x-ms-parmaeterized-host` parameter\n\nEvery parameter of type `uri` in `@server` will be marked with `x-ms-skip-url-encoding`.\r\n\r\n```typespec\r\n@server(\"{endpoint}/v2\", \"Account endpoint\", {endpoint: url})\r\n```\r\n\r\nResult in\r\n\r\n```json5\r\n{\r\n  in: \"path\",\r\n  name: \"endpoint\",\r\n  required: true,\r\n  type: \"string\",\r\n  format: \"uri\",\r\n  \"x-ms-skip-url-encoding\": true,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n✅ **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n✅ **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 11.985782861709595, "response_length": 497}
{"query": "What is the equivalent of the current implementation with @encodedName, considering the error 'Invalid mime type 'csharp'?", "ground_truth": "The equivalent of the current implementation with @encodedName, considering the error 'Invalid mime type 'csharp'', is to use the @clientName decorator for SDK renames as specified in the TypeSpec Azure documentation.", "response": "The `@encodedName` decorator is used to provide an alternative name for a property when serialized to a specific MIME type. If you encounter the error 'Invalid mime type 'csharp'', it indicates that the MIME type provided is not valid. MIME types should follow the standard format as described in the documentation, such as 'application/json' or 'application/xml'.\n\nTo resolve this issue, ensure that the MIME type provided in the `@encodedName` decorator is valid. For example:\n\n```typespec\nmodel Certificate {\n  @encodedName(\"application/json\", \"exp\")\n  expireAt: int32;\n}\n```\n\nIf you are trying to rename properties for specific programming languages like C#, you should use the `@clientName` decorator instead, as recommended in the Azure TypeSpec documentation. For example:\n\n```typespec\n@@clientName(Certificate.expireAt, \"Expiry\", \"csharp\");\n```", "context": "- document_dir: typespec_docs\n- document_filename: standard-library#built-in-decorators.md\n- document_title: Built-in Decorators\n- document_link: https://typespec.io/docs/standard-library/built-in-decorators\n- document_content: # standard-library#built-in-decorators.md\n\n# Built-in Decorators\n\n## TypeSpec\n\n### `@continuationToken` {#@continuationToken}\n\nPagination property defining the token to get to the next page.\r\nIt MUST be specified both on the request parameter and the response.\r\n```typespec\r\n@continuationToken\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @continuationToken continuationToken: string;\r\n}\r\n@list op listPets(@continuationToken continuationToken: string): Page<Pet>;\r\n```\n\n### `@defaultVisibility` {#@defaultVisibility}\n\nDeclares the default visibility modifiers for a visibility class.\r\n\r\nThe default modifiers are used when a property does not have any visibility decorators\r\napplied to it.\r\n\r\nThe modifiers passed to this decorator _MUST_ be members of the target Enum.\r\n```typespec\r\n@defaultVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | the list of modifiers to use as the default visibility modifiers. |\n\n### `@discriminated` {#@discriminated}\n\nSpecify that this union is discriminated.\r\n```typespec\r\n@discriminated(options?: valueof DiscriminatedOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `DiscriminatedOptions`](./built-in-data-types.md#DiscriminatedOptions) | Options to configure the serialization of the discriminated union. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminated\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"kind\": \"cat\",\r\n  \"value\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"kind\": \"dog\",\r\n  \"value\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\r\n\r\n##### Custom property names\r\n\r\n\r\n```typespec\r\n@discriminated(#{discriminatorPropertyName: \"dataKind\", envelopePropertyName: \"data\"})\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"dataKind\": \"cat\",\r\n  \"data\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"dataKind\": \"dog\",\r\n  \"data\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\r\n```typespec\r\n@discriminator(propertyName: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| propertyName | [valueof `string`](#string) | The property name to use for discrimination |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet{ kind: string }\r\n\r\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\r\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\r\n```\n\n### `@doc` {#@doc}\n\nAttach a documentation string. Content support CommonMark markdown formatting.\r\n```typespec\r\n@doc(doc: valueof string, formatArgs?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n| formatArgs | `{}` | Record with key value pair that can be interpolated in the doc. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@doc(\"Represent a Pet available in the PetStore\")\r\nmodel Pet {}\r\n```\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\r\n```typespec\r\n@encode(encodingOrEncodeAs: Scalar | valueof string | EnumMember, encodedAs?: Scalar)\r\n```\r\n\r\n#### Target\r\n\r\n`Scalar | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| encodingOrEncodeAs | `Scalar` \\| `valueof string \\| EnumMember` | Known name of an encoding or a scalar type to encode as(Only for numeric types to encode as string). |\r\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\r\n\r\n#### Examples\r\n##### offsetDateTime encoded with rfc7231\r\n\r\n\r\n```tsp\r\n@encode(\"rfc7231\")\r\nscalar myDateTime extends offsetDateTime;\r\n```\r\n\r\n##### utcDateTime encoded with unixTimestamp\r\n\r\n\r\n```tsp\r\n@encode(\"unixTimestamp\", int32)\r\nscalar myDateTime extends unixTimestamp;\r\n```\r\n\r\n##### encode numeric type to string\r\n\r\n\r\n```tsp\r\nmodel Pet {\r\n  @encode(string) id: int64;\r\n}\r\n```\n\n### `@encodedName` {#@encodedName}\n\nProvide an alternative name for this type when serialized to the given mime type.\r\n```typespec\r\n@encodedName(mimeType: valueof string, name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mimeType | [valueof `string`](#string) | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| name | [valueof `string`](#string) | Alternative name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Certificate {\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"expiry\")\r\n  expireAt: int32;\r\n}\r\n```\r\n\r\n##### Invalid values\r\n\r\n\r\n```typespec\r\n@encodedName(\"application/merge-patch+json\", \"exp\")\r\n             ^ error cannot use subtype\r\n```\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\r\n```typespec\r\n@error\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@error\r\nmodel PetStoreError {\r\n  code: string;\r\n  message: string;\r\n}\r\n```\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\r\n```typespec\r\n@errorsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@errorsDoc(\"Errors doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@example` {#@example}\n\nProvide an example value for a data type.\r\n```typespec\r\n@example(example: valueof unknown, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Scalar | Union | ModelProperty | UnionVariant`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | `valueof unknown` | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@example(#{name: \"Fluffy\", age: 2})\r\nmodel Pet {\r\n name: string;\r\n age: int32;\r\n}\r\n```\n\n### `@firstLink` {#@firstLink}\n\nPagination property defining a link to the first page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@firstLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\r\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\r\nThe format names are open ended and are left to emitter to interpret.\r\n```typespec\r\n@format(format: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| format | [valueof `string`](#string) | format name. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\r\n```typespec\r\n@friendlyName(name: valueof string, formatArgs?: unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| name | [valueof `string`](#string) | name the template instance should take |\r\n| formatArgs | `unknown` | Model with key value used to interpolate the name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@friendlyName(\"{name}List\", T)\r\nmodel List<Item> {\r\n  value: Item[];\r\n  nextLink: string;\r\n}\r\n```\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\r\n```typespec\r\n@inspectType(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\r\n```typespec\r\n@inspectTypeName(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@invisible` {#@invisible}\n\nIndicates that a property is not visible in the given visibility class.\r\n\r\nThis decorator removes all active visibility modifiers from the property within\r\nthe given visibility class, making it invisible to any context that selects for\r\nvisibility modifiers within that class.\r\n```typespec\r\n@invisible(visibilityClass: Enum)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilityClass | `Enum` | The visibility class to make the property invisible within. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  @invisible(Lifecycle)\r\n  hidden_property: string;\r\n}\r\n```\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\r\n```typespec\r\n@key(altName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| altName | [valueof `string`](#string) | Name of the property. If not specified, the decorated property name is used. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Pet {\r\n  @key id: string;\r\n}\r\n```\n\n### `@lastLink` {#@lastLink}\n\nPagination property defining a link to the last page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@lastLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation that returns a paginated list of items.\r\n```typespec\r\n@list\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\nNone\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\r\n```typespec\r\n@maxItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxItems(5)\r\nmodel Endpoints is string[];\r\n```\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\r\n```typespec\r\n@maxLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxLength(20)\r\nscalar Username extends string;\r\n```\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\r\n```typespec\r\n@maxValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValue(200)\r\nscalar Age is int32;\r\n```\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@maxValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValueExclusive(50)\r\nscalar distance is float64;\r\n```\n\n### `@mediaTypeHint` {#@mediaTypeHint}\n\nApplies a media type hint to a TypeSpec type. Emitters and libraries may choose to use this hint to determine how a\r\ntype should be serialized. For example, the `@typespec/http` library will use the media type hint of the response\r\nbody type as a default `Content-Type` if one is not explicitly specified in the operation.\r\n\r\nMedia types (also known as MIME types) are defined by RFC 6838. The media type hint should be a valid media type\r\nstring as defined by the RFC, but the decorator does not enforce or validate this constraint.\r\n\r\nNotes: the applied media type is _only_ a hint. It may be overridden or not used at all. Media type hints are\r\ninherited by subtypes. If a media type hint is applied to a model, it will be inherited by all other models that\r\n`extend` it unless they delcare their own media type hint.\r\n```typespec\r\n@mediaTypeHint(mediaType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Scalar | Enum | Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mediaType | [valueof `string`](#string) | The media type hint to apply to the target type. |\r\n\r\n#### Examples\r\n##### create a model that serializes as XML by default\r\n\r\n\r\n```tsp\r\n@mediaTypeHint(\"application/xml\")\r\nmodel Example {\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n```\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\r\n```typespec\r\n@minItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minItems(1)\r\nmodel Endpoints is string[];\r\n```\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\r\n```typespec\r\n@minLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minLength(2)\r\nscalar Username extends string;\r\n```\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\r\n```typespec\r\n@minValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValue(18)\r\nscalar Age is int32;\r\n```\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@minValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValueExclusive(0)\r\nscalar distance is float64;\r\n```\n\n### `@nextLink` {#@nextLink}\n\nPagination property defining a link to the next page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@nextLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@offset` {#@offset}\n\nPagination property defining the number of items to skip.\r\n```typespec\r\n@offset\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@offset skip: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@opExample` {#@opExample}\n\nProvide example values for an operation's parameters and corresponding return type.\r\n```typespec\r\n@opExample(example: valueof OperationExample, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | [valueof `OperationExample`](./built-in-data-types.md#OperationExample) | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@opExample(#{parameters: #{name: \"Fluffy\", age: 2}, returnType: #{name: \"Fluffy\", age: 2, id: \"abc\"})\r\nop createPet(pet: Pet): Pet;\r\n```\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\r\n```typespec\r\n@overload(overloadbase: Operation)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\r\n@overload(upload)\r\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\r\n@overload(upload)\r\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\r\n```\n\n### `@pageIndex` {#@pageIndex}\n\nPagination property defining the page index.\r\n```typespec\r\n@pageIndex\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageItems` {#@pageItems}\n\nSpecify the the property that contains the array of page items.\r\n```typespec\r\n@pageItems\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageSize` {#@pageSize}\n\nSpecify the pagination parameter that controls the maximum number of items to include in a page.\r\n```typespec\r\n@pageSize\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nDeclares the visibility constraint of the parameters of a given operation.\r\n\r\nA parameter or property nested within a parameter will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@parameterVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the parameters of this operation. |\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\r\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\r\nAdvanced features like look-around, capture groups, and references are not supported.\r\n\r\nThis decorator may optionally provide a custom validation _message_. Emitters may choose to use the message to provide\r\ncontext when pattern validation fails. For the sake of consistency, the message should be a phrase that describes in\r\nplain language what sort of content the pattern attempts to validate. For example, a complex regular expression that\r\nvalidates a GUID string might have a message like \"Must be a valid GUID.\"\r\n```typespec\r\n@pattern(pattern: valueof string, validationMessage?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | bytes | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| pattern | [valueof `string`](#string) | Regular expression. |\r\n| validationMessage | [valueof `string`](#string) | Optional validation message that may provide context when validation fails. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@pattern(\"[a-z]+\", \"Must be a string consisting of only lower case letters and of at least one character.\")\r\nscalar LowerAlpha extends string;\r\n```\n\n### `@prevLink` {#@prevLink}\n\nPagination property defining a link to the previous page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@prevLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@removeVisibility` {#@removeVisibility}\n\nRemoves visibility modifiers from a property.\r\n\r\nIf the visibility modifiers for a visibility class have not been initialized,\r\nthis decorator will use the default visibility modifiers for the visibility\r\nclass as the default modifier set.\r\n```typespec\r\n@removeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\nThe property to remove visibility from.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | The visibility modifiers to remove from the target property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  // This property will have all Lifecycle visibilities except the Read\r\n  // visibility, since it is removed.\r\n  @removeVisibility(Lifecycle.Read)\r\n  secret_property: string;\r\n}\r\n```\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\r\n```typespec\r\n@returnsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@returnsDoc(\"Returns doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nDeclares the visibility constraint of the return type of a given operation.\r\n\r\nA property within the return type of the operation will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@returnTypeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the return type of this operation. |\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\r\n```typespec\r\n@secret\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@secret\r\nscalar Password is string;\r\n```\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\r\n```typespec\r\n@service(options?: valueof ServiceOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `ServiceOptions`](./built-in-data-types.md#ServiceOptions) | Optional configuration for the service. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service title\r\n\r\n```typespec\r\n@service(#{title: \"Pet store\"})\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service version\r\n\r\n```typespec\r\n@service(#{version: \"1.0\"})\r\nnamespace PetStore;\r\n```\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\r\n```typespec\r\n@summary(summary: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| summary | [valueof `string`](#string) | Summary string. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@summary(\"This is a pet\")\r\nmodel Pet {}\r\n```\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\r\n```typespec\r\n@tag(tag: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| tag | [valueof `string`](#string) | Tag value |\n\n### `@visibility` {#@visibility}\n\nSets the visibility modifiers that are active on a property, indicating that it is only considered to be present\r\n(or \"visible\") in contexts that select for the given modifiers.\r\n\r\nA property without any visibility settings applied for any visibility class (e.g. `Lifecycle`) is considered to have\r\nthe default visibility settings for that class.\r\n\r\nIf visibility for the property has already been set for a visibility class (for example, using `@invisible` or\r\n`@removeVisibility`), this decorator will **add** the specified visibility modifiers to the property.\r\n\r\nSee: [Visibility](https://typespec.io/docs/language-basics/visibility)\r\n\r\nThe `@typespec/http` library uses `Lifecycle` visibility to determine which properties are included in the request or\r\nresponse bodies of HTTP operations. By default, it uses the following visibility settings:\r\n\r\n- For the return type of operations, properties are included if they have `Lifecycle.Read` visibility.\r\n- For POST operation parameters, properties are included if they have `Lifecycle.Create` visibility.\r\n- For PUT operation parameters, properties are included if they have `Lifecycle.Create` or `Lifecycle.Update` visibility.\r\n- For PATCH operation parameters, properties are included if they have `Lifecycle.Update` visibility.\r\n- For DELETE operation parameters, properties are included if they have `Lifecycle.Delete` visibility.\r\n- For GET or HEAD operation parameters, properties are included if they have `Lifecycle.Query` visibility.\r\n\r\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type |\n\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibilities which apply to this property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  // The service will generate an ID, so you don't need to send it.\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // The service will store this secret name, but won't ever return it.\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  // The regular name has all vi\r\n  name: string;\r\n}\r\n```\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\r\n\r\nThis will set the visibility modifiers of all key properties in the model if the visibility is not already _explicitly_ set,\r\nbut will not change the visibility of any properties that have visibility set _explicitly_, even if the visibility\r\nis the same as the default visibility.\r\n\r\nVisibility may be set explicitly using any of the following decorators:\r\n\r\n- `@visibility`\r\n- `@removeVisibility`\r\n- `@invisible`\r\n```typespec\r\n@withDefaultKeyVisibility(visibility: valueof EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibility | `valueof EnumMember` | The desired default visibility value. If a key property already has visibility set, it will not be changed. |\n\n### `@withLifecycleUpdate` {#@withLifecycleUpdate}\n\nTransforms the `target` model to include only properties that are visible during the\r\n\"Update\" lifecycle phase.\r\n\r\nAny nested models of optional properties will be transformed into the \"CreateOrUpdate\"\r\nlifecycle phase instead of the \"Update\" lifecycle phase, so that nested models may be\r\nfully updated.\r\n```typespec\r\n@withLifecycleUpdate\r\n```\r\n\r\n#### Target\r\nThe model to apply the transformation to.\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@withLifecycleUpdate\r\nmodel DogUpdate {\r\n  ...Dog\r\n}\r\n```\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\r\n```typespec\r\n@withOptionalProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#encoded-names.md\n- document_title: Encoded names\n- document_link: https://typespec.io/docs/standard-library/encoded-names\n- document_content: # standard-library#encoded-names.md\n\n# Encoded names\n\nThere is some cases where the name you have in TypeSpec might differ from the name over the wire or for a certain language.\n\n## Update name for a given target\n\nTo update the name of a TypeSpec entity you can use the `@encodedName` decorator. This decorator takes 2 parameters:\r\n\r\n| Parameter     | Type     | Description                                                                                                                                                                                                            |\r\n| ------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `mimeType`    | `string` | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| `encodedName` | `string` | The name should be when serialized to the given mime type.                                                                                                                                                             |\r\n\r\nExample:\r\n\r\n```typespec\r\nmodel Foo {\r\n  // Specify that when serializing to JSON `expireAt` property should be named `exp`\r\n  @encodedName(\"json\", \"exp\")\r\n  expireAt: string;\r\n}\r\n```\n\n## Example\n\n```typespec\r\nmodel CertificateAttributes {\r\n  @encodedName(\"application/json\", \"nbf\")\r\n  notBefore: int32;\r\n\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"ExpireAt\")\r\n  expires: int32;\r\n\r\n  created: int32;\r\n  updated: int32;\r\n}\r\n```\r\n\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>Json</th>\r\n<th>Xml</th>\r\n<th>Yaml</th>\r\n</tr>\r\n</thead>\r\n<tr>\r\n<td>When serialized to `application/json` properties will use the encodedName for `application/json` if available or default to the property name.</td>\r\n<td>When serialized to `application/xml` properties will use the encodedName for `application/xml` if available or default to the property name.</td>\r\n<td>Yaml didn't provide any different names so it will serialize using the property names.</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n\r\n```json\r\n{\r\n  \"nbf\": 1430344421,\r\n  \"exp\": 2208988799,\r\n  \"created\": 1493938289,\r\n  \"updated\": 1493938291\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<CertificateAttributes>\r\n  <notBefore>1430344421</notBefore>\r\n  <ExpireAt>2208988799</ExpireAt>\r\n  <created>1493938289</created>\r\n  <updated>1493938291</updated>\r\n</CertificateAttributes>\r\n```\r\n\r\n</td>\r\n\r\n<td>\r\n\r\n```yaml\r\nnotBefore: 1430344421\r\nexpires: 2208988799\r\ncreated: 1493938289\r\nupdated: 1493938291\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## Use in library/emitter\n\nTo consume the value of `@encodedName` in your library or emitter you can use `resolveEncodedName(target: Type, mimeType: string): string` from the compiler.\r\n\r\n```ts\r\nimport { resolveEncodedName } from \"@typespec/compiler\";\r\n\r\n// Resolve the encoded name for the given property and mime type. If the property doesn't have a encoded name for the given mime type it will return the property name.\r\nconst encodedName = resolveEncodedName(property, \"application/json\");\r\n\r\n// You can also pass a full http mime type and `resolveEncodedName` will automatically resolve it to the base mime type.\r\nconst encodedName = resolveEncodedName(property, \"application/merge-patch+json\");\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#type-relations.md\n- document_title: Type Relations\n- document_link: https://typespec.io/docs/language-basics/type-relations\n- document_content: # language-basics#type-relations.md\n\n# Type Relations\n\n## Type hierarchy\n\n```mermaid\r\ngraph RL\r\n    record[\"Record<Element>\"] --> unknown\r\n    customModel[\"Custom model with properties\"] --> record[\"Record<T>\"]\r\n    array[\"Array<Element>\"] --> unknown\r\n    tuple[\"Tuple\"] --> array\r\n    numeric --> unknown\r\n    subgraph numerics[For numeric types, a narrower type can be assigned to a wider one]\r\n      integer --> numeric\r\n        int8 --> integer\r\n        int16 --> integer\r\n        int32 --> integer\r\n        safeint --> integer\r\n        int64 --> integer\r\n        uint8 --> integer\r\n        uint16 --> integer\r\n        uint32 --> integer\r\n        uint64 --> integer\r\n      float --> numeric\r\n        float32 --> float\r\n        float64 -->  float\r\n      decimal --> numeric\r\n        decimal128 --> decimal\r\n    end\r\n    string --> unknown\r\n    boolean --> unknown\r\n    null --> unknown\r\n    bytes --> unknown\r\n    plainDate --> unknown\r\n    plainTime --> unknown\r\n    zoneDateTime --> unknown\r\n    duration --> unknown\r\n```\n\n## Model with properties\n\nWhen determining if type `S` can be assigned to type `T`, if `T` is a model with properties, it checks whether all those properties are present in `S` and if their types can be assigned to the type of the corresponding property in `T`.\r\n\r\nFor instance,\r\n\r\n```typespec\r\nmodel T {\r\n  foo: string;\r\n  bar: int32;\r\n}\r\n\r\n// Valid\r\n\r\nmodel S { // When properties types are the exact same\r\n  foo: string;\r\n  bar: int32;\r\n}\r\nmodel S { // When the properties types are literal assignable to the target type\r\n  foo: \"abc\";\r\n  bar: 123;\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int8; // int8 is assignable to int16\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int32;\r\n  otherProp: boolean; // Additional properties are valid.\r\n}\r\n\r\n// Invalid\r\nmodel S { // Missing property bar\r\n  foo: string;\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int64; // int64 is NOT assignable to int32\r\n}\r\n```\n\n## `Record<T>`\n\nA record is a model indexed with a string with a value of T. It represents a model where all properties (string keys) are assignable to the type T. You can assign a model expression where all the properties are of type T or another model that `is` also a `Record<T>`.\r\n\r\n```typespec\r\n// Represent an object where all the values are int32.\r\nalias T = Record<int32>;\r\n\r\n// Valid\r\nalias S = {\r\n  foo: 123;\r\n  bar: 345;\r\n};\r\nalias S = {\r\n  foo: int8;\r\n  bar: int32;\r\n};\r\nmodel S is Record<int32>;\r\nmodel S is Record<int32> {\r\n  foo: 123;\r\n}\r\n\r\n// Invalid\r\nalias S = {\r\n  foo: \"abc\";\r\n  bar: 456;\r\n};\r\nalias S = {\r\n  foo: int64;\r\n  bar: int32;\r\n};\r\nmodel S {\r\n  foo: 123;\r\n  bar: 456;\r\n}\r\n```\r\n\r\n#### Why isn't the last case assignable to `Record<int32>`?\r\n\r\nIn this scenario,\r\n\r\n```typespec\r\nalias T = Record<int32>;\r\nmodel S {\r\n  foo: 123;\r\n  bar: 456;\r\n}\r\n```\r\n\r\nThe reason why `model S` is not assignable, but the model expression `{ foo: 123; bar: 456; }` is, is because model S could be extended with additional properties that might not be compatible.\r\n\r\nFor instance, if you add a new model,\r\n\r\n```typespec\r\nmodel Foo is S {\r\n  otherProp: string;\r\n}\r\n```\r\n\r\nHere, `Foo` is assignable to `S` following the [model with property logic](#model-with-properties), and if `S` was assignable to `Record<int32>`, `Foo` would also be passable. However, this is now invalid as `otherProp` is not an `int32` property.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#models.md\n- document_title: Models\n- document_link: https://typespec.io/docs/language-basics/models\n- document_content: # language-basics#models.md\n\n# Models\n\nModels in TypeSpec are utilized to define the structure or schema of data.\n\n## Types of models\n\nModels can be categorized into two main types:\r\n\r\n- [Record](#record)\r\n- [Array](#array)\n\n### Record\n\nA Record model is a structure that consists of named fields, referred to as properties.\r\n\r\n- The name can be an [`identifier`](./identifiers.md) or `string literal`.\r\n- The type can be any type reference.\r\n- Properties are arranged in a specific order. Refer to [property ordering](#property-ordering) for more details.\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\r\n\r\n#### Optional properties\r\n\r\nProperties can be designated as optional by using the `?` symbol.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string;\r\n}\r\n```\r\n\r\n#### Default values\r\n\r\nProperties can be assigned a default value using the `=` operator.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string = \"wild\";\r\n  age: uint8 = 0;\r\n}\r\n```\r\n\r\n#### Property ordering\r\n\r\nProperties are arranged in the order they are defined in the source. Properties acquired via `model is` are placed before properties defined in the model body. Properties obtained via `...` are inserted at the point where the spread appears in the source.\r\n\r\nExample:\r\n\r\n```tsp\r\nmodel Pet {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n\r\nmodel HasHome {\r\n  address: string;\r\n}\r\n\r\nmodel Cat is Pet {\r\n  meow: boolean;\r\n  ...HasHome;\r\n  furColor: string;\r\n}\r\n\r\n// The resulting property order for Cat is:\r\n// name, age, meow, address, furColor\r\n```\n\n### Additional properties\n\nThe `Record<T>` model can be used to define a model with an arbitrary number of properties of type T. It can be combined with a named model to provide some known properties.\r\n\r\nThere are three ways to achieve this, each with slightly different semantics:\r\n\r\n- Using the `...` operator\r\n- Using the `is` operator\r\n- Using the `extends` operator\r\n\r\n#### Using the `...` operator\r\n\r\nSpreading a Record into your model implies that your model includes all the properties you have explicitly defined, plus any additional properties defined by the Record. This means that a property in the model could be of a different and incompatible type with the Record value type.\r\n\r\n```tsp\r\n// In this example, the Person model has a property `age` that is an int32, but also has other properties that are all strings.\r\nmodel Person {\r\n  age: int32;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\n#### Using the `is` operator\r\n\r\nWhen using `is Record<T>`, it indicates that all properties of this model are of type T. This means that each property explicitly defined in the model must also be of type T.\r\n\r\nThe example above would be invalid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  age: int32;\r\n  //   ^ int32 is not assignable to string\r\n}\r\n```\r\n\r\nBut the following would be valid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  name: string;\r\n}\r\n```\r\n\r\n#### Using the `extends` operator\r\n\r\nThe `extends` operator has similar semantics to `is`, but it defines the relationship between the two models. In many languages, this would probably result in the same emitted code as `is` and it is recommended to use `is Record<T>` instead.\r\n\r\n```tsp\r\nmodel Person extends Record<string> {\r\n  name: string;\r\n}\r\n```\n\n### Special property types\n\n#### `never`\r\n\r\nA model property can be declared as having the type `never`. This can be interpreted as the model not having that property.\r\n\r\nThis can be useful in a model template to omit a property.\r\n\r\n```typespec\r\nmodel Address<TState> {\r\n  state: TState;\r\n  city: string;\r\n  street: string;\r\n}\r\n\r\nmodel UKAddress is Address<never>;\r\n```\r\n\r\n:::note\r\nThe responsibility of removing `never` properties lies with the emitter. The TypeSpec compiler will not automatically omit them.\r\n:::\n\n### Array\n\nArrays are models created using the `[]` syntax, which is a shorthand for using the `Array<T>` model type.\n\n## Model composition\n\n### Spread\n\nThe spread operator (`...`) copies the members of a source model into a target model. This operation doesn't create any nominal relationship between the source and target, making it useful when you want to reuse common properties without generating complex inheritance relationships.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Dog {\r\n  ...Animal;\r\n  ...Pet;\r\n}\r\n\r\n// The Dog model is equivalent to the following declaration:\r\nmodel Dog {\r\n  species: string;\r\n  name: string;\r\n}\r\n```\n\n### Extends\n\nThere are times when you want to create an explicit relationship between two models, such as when you're generating class definitions in languages that support inheritance. The `extends` keyword can be used to establish this relationship.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Dog extends Animal {}\r\n```\n\n### Is\n\nThere are instances when you want to create a new type that is an exact copy of an existing type but with additional properties or metadata, without creating a nominal inheritance relationship. The `is` keyword can be used for this purpose. It copies all the properties (like spread), but also copies [decorators](./decorators.md) as well. A common use case is to provide a better name to a [template](#model-templates) instantiation:\r\n\r\n```typespec\r\n@decorator\r\nmodel Thing<T> {\r\n  property: T;\r\n}\r\n\r\nmodel StringThing is Thing<string>;\r\n\r\n// The StringThing declaration is equivalent to the following declaration:\r\n@decorator\r\nmodel StringThing {\r\n  property: string;\r\n}\r\n```\n\n## Model templates\n\nRefer to [templates](./templates.md) for more details on templates.\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Meta type references\n\nSome model property meta types can be referenced using `::`.\r\n\r\n| Name | Example          | Description                              |\r\n| ---- | ---------------- | ---------------------------------------- |\r\n| type | `Pet.name::type` | Reference the type of the model property |\n", "latency": 10.96690058708191, "response_length": 852}
{"query": "Is there any way to bypass TypeSpec validation checks for a specific PR?", "ground_truth": "To bypass TypeSpec validation checks for a specific PR, spec owners are responsible for either fixing or suppressing these issues in their next PR to their spec. Additionally, for detailed guidance on specific errors, one can search the main for specs similar to theirs that might already be fixed, or consult the TypeSpec Azure documentation and use the TypeSpec extension for VSCode or VS for inline violations and automated codefixes.", "response": "Yes, you can bypass specific TypeSpec validation checks for a PR by suppressing warnings using the `#suppress` directive. This directive allows you to suppress specific linting rules or validation errors by providing the error code and a reason for suppression. For example:\n\n```tsp\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\n/** An array of details about specific errors that led to this reported error. */\ndetails: Error[];\n```\n\nThis approach is useful for cases where the validation error is a false positive or has been reviewed and approved for suppression. However, it is recommended to address the underlying issue whenever possible instead of suppressing warnings.", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#installation.md\n- document_title: Installation\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/installation\n- document_content: # getstarted#installation.md\n\n# Installation\n\n## Try TypeSpec without installing anything\n\nYou can try TypeSpec on the web without installing anything.\r\n\r\n- [TypeSpec playground](https://aka.ms/trytypespec)\r\n- [TypeSpec playground for Azure services](https://azure.github.io/typespec-azure/playground)\n\n## Installing TypeSpec core toolset\n\nSee https://typespec.io/docs to install the base requirements for working with TypeSpec:\r\n\r\n- NodeJS\r\n- Typespec CLI\r\n- VSCode or VS extension\n\n## Create an Azure TypeSpec project\n\n[See next doc](./createproject.md)\n\n## Additional tooling\n\n- `tsp-client`: A CLI tool that provides several commands to help during the TypeSpec development process, such as converting a swagger specification to a TypeSpec project, providing a simple interface to generate client libraries within the `azure-sdk-for-<language>` repositories, and more. For more information on the CLI tool, see the [tsp-client usage](https://aka.ms/azsdk/tsp-client) documentation\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#suppresswarnings.md\n- document_title: How to suppress warnings\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\n- document_content: # troubleshoot#suppresswarnings.md\n\n# How to suppress warnings\n\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\n\n## Symptoms\n\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\n\n## Cause\n\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\n\n## Workaround\n\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\r\n\r\nFor example:\r\n\r\n```tsp\r\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\r\n/** An array of details about specific errors that led to this reported error. */\r\ndetails: Error[];\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n✅ **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n✅ **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n✅ **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n❌ **DON'T** suppress documentation warnings\r\n\r\n✅ **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n✅ **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n✅ **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n❌ **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n✅ **DO** make client customizations in a `client.tsp` file\r\n\r\n❌ **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n✅ **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n✅ **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n✅ **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n❌ **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n❌ **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n❌ **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n✅ **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 13.788464546203613, "response_length": 753}
{"query": "Is the change in property behavior from version 0.40 to 0.41 a bug or a feature?", "ground_truth": "The change in property behavior from version 0.40 to 0.41 is by design, not a bug. It was decided that the original change wasn't suitable for the spec repository.", "response": "The change in property behavior from version 0.40 to 0.41 could be considered either a bug fix or a feature depending on the nature of the change. According to the TypeSpec breaking change policy, if the change addresses an existing behavior that was clearly broken or unintended, it is classified as a bug fix and not considered a breaking change. However, if the change introduces new functionality or modifies existing behavior intentionally, it would be considered a feature. If the previous behavior was widely relied upon despite being unintended, the impact of the change would be assessed carefully to avoid breaking stable releases.", "context": "- document_dir: typespec_docs\n- document_filename: handbook#breaking-change-policy.mdx\n- document_title: Breaking Change Policy\n- document_link: https://typespec.io/docs/handbook/breaking-change-policy\n- document_content: # handbook#breaking-change-policy.mdx\n\n# Breaking Change Policy\n\nimport { Badge } from \"@astrojs/starlight/components\";\r\n\r\n:::note\r\nThe information in this document is applicable to TypeSpec packages with version 1.0.0 or greater.\r\n:::\n\n## Versioning Scheme\n\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\n\n## Breaking Change Philosophy\n\nExisting language syntax and semantics will not change without a major version.\r\nThe runtime behavior for a given TypeSpec will not change without a major version.\r\nTypeSpecs leveraging new or updated features may cause runtime API consumers to fail\r\n(e.g. because a new type is unhandled in an emitter or library that it uses)\r\nor builds to fail (e.g. because exhaustive unions are no longer exhaustive).\r\n\r\n- The language syntax and semantics for existing language elements will not change within a major version.\r\n- A spec that builds successfully with a version of the TypeSpec compiler and its libraries will build successfully with a newer version of the compiler and libraries within the same major version.\r\n- New types and functionality may be added in a minor version release to the compiler or any TypeSpec library.\r\n  - If a spec uses the new type or functionality, existing libraries or emitters may not work with it, and this is not considered a breaking change in the compiler or library that introduced the type. Spec authors should expect that _existing_ specs will continue to work with their workflows, but not that newly-added features will work with their existing workflows every time.\r\n- TypeScript API types in TypeScript might change in ways that introduce TypeScript type checking errors (e.g. adding a new variant to a union). TypeScript type checking errors in library builds are not considered breaking changes, and library authors working in TypeScript should take care to program defensively as appropriate. More information about TypeScript API guarantees is provided in the section _Categories of Breaking Changes_ below.\n\n### Bugs\n\nA bug fix that introduces a technically breaking change will not be considered a breaking change for the purposes of TypeSpec versioning if it is clear that the existing behavior was broken or unintended in the first place.\n\n## Categories of Breaking Changes\n\n|\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/experimental` is considered for experimental and its API may change at any time. [See experiemental api](#experimental-apis)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Formatter                           | <Badge text=\"3\" variant=\"note\" />    | Formatting shouldn't affect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.\n\n|\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| Additional library helper functions | <Badge text=\"0\" variant=\"success\" /> | Helper and metadata accessor functions exported from the public surface of the compiler or a TypeSpec library are generally considered stable unless otherwise specified or only exported through an experimental subpath.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\r\n|\n\n|\r\n| TypeSpec AST (`Node`)               | <Badge text=\"1\" variant=\"caution\" /> | The TypeSpec abstract syntax tree may change at any time. **Note**: this is not the same thing as the _type graph_ (`Type` and its variants), which is a <Badge text=\"Tier 0\" variant=\"success\" />, stable feature; this only applies to `Node` and its variants. The only sanctioned reason for using the AST is for some syntax based linting rule or writing codefixes. Libraries depend on the abstract syntax tree _at their own risk_!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| Checker                             | <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.\n\n- <Badge text=\"Tier 0\" variant=\"success\" />: These are stable core APIs and language features that\r\n  define fundamental semantics and will not be broken without a major version update. We recommend\r\n  that library authors depend on these APIs.\r\n- <Badge text=\"Tier 1\" variant=\"caution\" />: These are APIs that have very limited use cases and may\r\n  be broken without a major version update. We recommend that library authors avoid depending on\r\n  these APIs.\r\n- <Badge text=\"Tier 2\" variant=\"danger\" />: These are internal APIs intended only for use by the\r\n  TypeSpec compiler and core libraries. Tier 2 APIs may be changed without a a major version update\r\n  or even documentation of the change. Consuming these APIs is _at your own risk_!\r\n- <Badge text=\"Tier 3\" variant=\"note\" />: These are APIs and language features that don't describe\r\n  semantically meaningful information, but provide information that emitters and libraries may\r\n  choose to use and may introduce changes in emitter output when the features are changed. For\r\n  example: formatting.\r\n\r\n| Example                             | Tier                                 | Description\n\n|\r\n| Stdout                              | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec does not provide any contract with the output emitted to `stdout`/`stderr`. The CLI might change the output at any time. Stderr is used to output progress tracking and should NOT be counted as a failure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| `@internal` exports                 | <Badge text=\"2\" variant=\"danger\" />  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.\n\naffect the meaning of the language. Changes to the formatting should be taken with consideration, as changes in formatting may introduce significant and unexpected differences in formatted output, but changes to the formatter output are not considered breaking changes for the purposes of issuing a major version change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| Bug fixes                           | [See bug](#bugs)                     | Bug fixes will not be considered breaking changes for the purposes of TypeSpec versioning if the existing behavior is _clearly_ broken or unintentional (e.g. if it violates the documented and expected behavior, or if there is no reasonable interpretation of the buggy behavior), even if the change is technically a breaking change. Bug fixes that are technically breaking will be documented as breaking changes in the release notes, but will not introduce a major version revision. However, if a bug's behavior has become so widely used as to be considered a \"feature,\" we will consider the impact of the bugfix and make a reasonable determination to the best of our abilities and depending on the non-breaking mitigation strategies we have at our disposal. We will not break behaviors in stable releases that are known to be widely depended upon, even if we believe they are the result of a bug. |\n\n|\r\n| ----------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| TypeKits                            | <Badge text=\"0\" variant=\"success\" /> | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.\n\n| <Badge text=\"2\" variant=\"danger\" />  | Direct use of the Program's type checker instance is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| Symbols                             | <Badge text=\"2\" variant=\"danger\" />  | TypeSpec node symbols (not JavaScript symbols or state keys, rather the internal symbols used to relate TypeSpec types in the parser and type checker) are for internal use only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| Stdout                              |\n\n/>  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| `/internals` exports                | <Badge text=\"2\" variant=\"danger\" />  | Any types exported from a sub export with the name `/internals` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| `/experimental` exports             | <Badge text=\"2\" variant=\"danger\" />  |\n\n### Supported Node.js Versions\n\nTypeSpec will support all [current, active, and maintenance LTS Node.js releases](https://nodejs.org/en/about/previous-releases). We aim to support newly released current LTS versions as soon as possible, and we will provide a six month \"grace period\" after an LTS release leaves maintenance support before we cease testing it. After we drop support for a maintenance LTS version of Node.js, we may begin using syntax and runtime features that outdated Node.js versions may not support in new minor versions of published packages.\r\n\r\nTypeSpec does not guarantee support for any alternative JavaScript engines or runtimes.\n\n### Using Experimental APIs <Badge text=\"Tier 3\" variant=\"danger\" />\n\nTypeSpec compiler and libraries may expose experimental APIs that are not yet stable. These APIs are subject to change without notice.\r\nExperimental APIs or types are exported from sub exports with the name `/experimental` or a sub export (e.g. `/experimental/feature`).\r\n\r\nWhen those APIs become stable the unstable APIs will be deprecated then removed and users will need to migrate to the stable version.\n\n### Emitter output\n\nEmitter output are not guaranteed to be producing the exact same output as the previous version for the same input. A change that is semantically equivalent wouldn't be considered a breaking change by the emitter.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-csharp#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-csharp/project\n- document_content: # emitters#servers#http-server-csharp#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Layout\n\nThe code layout inside the 'generated' folder is as follows:\r\n\r\n- **generated**\r\n\r\n  - **controllers**: A set of ASP.Net core MVC controllers representing the operations in the spec, one for each interface or namespace with operations\r\n  - **lib**: A set of library files used in implementing generated models and controllers\r\n  - **models**: A set of models, each serving one of two distinct purposes:\r\n    - Request/Response Models: Represent the data used in requests and responses.\r\n    - Exception Models: Represent errors. These models inherit from `HttpServiceException` and are designed to encapsulate error details, making them suitable for throwing and handling exceptions.\r\n  - **operations**: A set of interfaces called by the controllers, that should be implemented with the business logic for each operation.\r\n\r\n  You should recompile whenever you make changes in your TypeSpec and these files will be replaced inline to reflect the spec changes, without changing any of your hand-written implementation in the project.\n\n## Scaffolding\n\nIf you use the scaffolding cli (hscs-scaffold) or use the `--emit-mocks \"mocks-and-project-files\"` option on compilation, a fully-functional .Net 9 project will be created with mock implementations of your business\r\nlogic, ready to compile and run.\r\n\r\nThe following additional files will be generated. It is expected that you will edit or replace these\r\nfiles as you implement your service, so you should only regenerate them when needed.\r\nTo protect from inadvertently changing any edits you may have made to these files,\r\nthese files will be overwritten by the emitter unless you specify the `--overwrite` option.\r\n\r\n- **ServiceProject.csproj**: The project file\r\n- **Program.cs**: Entry point that sets up the app\r\n- **appSettings.Development.json**: Configuration settings for the development environment\r\n- **appSettings.json**: Configuration settings for the production environment\r\n- **Properties**\r\n  - **launchSettings.json**: Launch configurations for the service (including local ports)\r\n- **mocks**: Simple implementations of business logic interfaces that return simple responses.\r\n  this allows testing your service out before writing any implementation code.\r\n\r\n  - **MockRegistration.cs**: Called from the Program.cs startup, registers each of the business\r\n    logic implementations in the dependency injection container.\r\n  - **IInitializer.cs**: Interface used in the mocks to create responses.\r\n  - **Initializer.cs**: Implementation of the interface to create mock responses.\n\n### Generating a Project and Mock Implementations using `tsp compile`\n\nIf you downloaded the `tsp` standalone component and you don't have `node` and `npm` installed, you will not be able to use the `hscs-scaffold` command to create an ASP.Net project. Instead, you can use compiler options, for example, the following command will create a new project using the TypeSpec in the current directory, enabling SwaggerUI, and overwriting any existing mocks or project files:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --emit @typespec/openapi3 --option @typespec/http-server-csharp.emit-mocks=emit-mocks-and-project-files --option @typespec/http-server-csharp.use-swaggerui=true --option @typespec/http-server-csharp.overwrite=true\r\n```\r\n\r\nOnce you have customized the project, you can generate new mocks for any new APIs while leaving existing implementations unchanged using:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --option @typespec/http-server-csharp.emit-mocks=mocks-only\r\n```\n\n## SwaggerUI\n\nIf you include the `@typespec/openapi3` emitter in your typespec project, you can include a\r\nSwaggerUI endpoint in the generated service using the `--use-swaggerui` option. This endpoint\r\nprovides a visual representation of operations and provides a web GUI client connected to the service that you can use right away to try out service operations.\n\n## How Components Work Together\n\n### Controllers\n\nThe generated controllers automatically listen at the routes you specified in TypeSpec. Controllers perform validation of input requests, call your implementation of business logic interfaces to perform the operation, and return the appropriate Http response.\n\n### Business Logic Interfaces\n\nYou must implement business loginc interfaces to perform the work of each operation. There is one\r\nbusiness logic interface for each `interface` type in your spec, or for each namespace that contain operations. Business logic can assume that input types meet the constraints specified in TypeSpec and are responsible for returning the response type for the operation.\r\n\r\nYou can use the `--emit-mocks` option to emit mock implementations of your business logic, these mocks demonstrate a simple implementation that returns responses that match the response type in TypeSpec. They also show how to use `IHttpContextAccessor` to access additional details of the Http request and response.\n\n### Discovery using the ASP.Net Core Dependency Injection Container\n\nThe Controllers find your business logic implementation through the ASP.Net dependency injection container. At server start, you register each of your implementations with the dependency injection container and they will automatically be instantiated and used by the controllers.\r\n\r\nIf you use the `--emit-mocks` option, sample code registering mock implementations is emitted to `mocks/MockRegistration.cs`.\n\n### Models\n\nModel classes represent the data passed in Http requests and response and the data that passes from the front end controllers to your business logic.\r\n\r\nModels are partial, so you can add additional members for internal usage as needed by putting a partial class definition with additional members outside the `generated` folder in your project.\n\n### Next Steps\n\nAfter successful generation, you should:\r\n\r\n- Use the SwaggerUI endpoint to test out the running service\r\n- Implement the business logic interfaces for your operations\r\n- Update MockRegistration.cs, or register each of your interfaces as part of application startup\r\n- Update configuration to suit your needs\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-js#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-js/project\n- document_content: # emitters#servers#http-server-js#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Functionality and generated code\n\nThe emitter generates a few major components:\n\n### Router\n\nThe highest-level component that your code interacts with directly is the router implementation.\r\n`@typespec/http-server-js` generates a static router that you can bind to an implementation of an HTTP server.\r\n\r\nThe router is generated in the `http/router.js` module within the output directory. Each service will have its own\r\nrouter implementation named after the service. For example, given a service namespace named `Todo`, the router module\r\nwill export a function `createTodoRouter`. This function creates an instance of a router that dispatches methods within\r\nthe `Todo` service.\r\n\r\n```ts\r\nimport { createTodoRouter } from \"../tsp-output/@typespec/http-server-js/http/router.js\";\r\n\r\nconst router = createTodoRouter(users, todoItems, attachments);\r\n```\r\n\r\nAs arguments, the `createTodoRouter` function expects implementations of the underlying service interfaces. These\r\ninterfaces are explained further in the next section.\r\n\r\nOnce the router is created, it is bound to an instance of the HTTP server. The router's `dispatch` method implements the\r\nNode.js event handler signature for the `request` event on a Node.js HTTP server.\r\n\r\n```ts\r\nconst server = http.createServer();\r\n\r\nserver.on(\"request\", router.dispatch);\r\n\r\nserver.listen(8080, () => {\r\n  console.log(\"Server listening on http://localhost:8080\");\r\n});\r\n```\r\n\r\nAlternatively, the router can be used with Express.js instead of the Node.js HTTP server directly. If the `express`\r\nfeature is enabled in the emitter options, the router will expose an `expressMiddleware` property that implements the\r\nExpress.js middleware interface.\r\n\r\n```ts\r\nimport express from \"express\";\r\n\r\nconst app = express();\r\n\r\napp.use(router.expressMiddleware);\r\n\r\napp.listen(8080, () => {\r\n  console.log(\"Server listening on http://localhost:8080\");\r\n});\r\n```\n\n### Service interfaces\n\nThe emitter generates interfaces for each collection of service methods that exists in the service namespace.\r\nImplementations of these interfaces are required to instantiate the router. When the router processes an HTTP request,\r\nit will call the appropriate method on the service implementation after determining the route and method.\r\n\r\nFor example, given the following TypeSpec namespace `Users` within the `Todo` service:\r\n\r\n```tsp\r\nnamespace Users {\r\n  @route(\"/users\")\r\n  @post\r\n  op create(\r\n    user: User,\r\n  ): WithStandardErrors<UserCreatedResponse | UserExistsResponse | InvalidUserResponse>;\r\n}\r\n```\r\n\r\nThe emitter will generate a corresponding interface `Users` within the module `models/all/todo/index.js` in the output\r\ndirectory.\r\n\r\n```ts\r\n/** An interface representing the operations defined in the 'Todo.Users' namespace. */\r\nexport interface Users<Context = unknown> {\r\n  create(\r\n    ctx: Context,\r\n    user: User,\r\n  ): Promise<\r\n    | UserCreatedResponse\r\n    | UserExistsResponse\r\n    | InvalidUserResponse\r\n    | Standard4XxResponse\r\n    | Standard5XxResponse\r\n  >;\r\n}\r\n```\r\n\r\nAn object implementing this `Users` interface must be passed to the router when it is created. The `Context` type\r\nparameter represents the underlying protocol or framework-specific context that the service implementation may inspect.\r\nIf you need to access the HTTP request or response objects directly in the implementation of the service methods, you\r\nmust use the `HttpContext` type as the `Context` argument when implementing the service interface. Otherwise, it is safe\r\nto use the default `unknown` argument.\r\n\r\n```ts\r\nimport { HttpContext } from \"../tsp-output/@typespec/http-server-js/helpers/router.js\";\r\nimport { Users } from \"../tsp-output/@typespec/http-server-js/models/all/todo/index.js\";\r\n\r\nexport const users: Users<HttpContext> = {\r\n  async create(ctx, user) {\r\n    // Implementation\r\n  },\r\n};\r\n```\n\n### Models\n\nThe emitter generates TypeScript interfaces that represent the model types used in the service operations. This allows\r\nthe service implementation to interact with the data structures carried over the HTTP protocol in a type-safe manner.\n\n### Operation functions\n\nWhile your code should never need to interact with these functions directly, the emitter generates a function per HTTP\r\noperation that handles the parsing and validation of the request contents. This allows the service implementation to be\r\nwritten in terms of ordinary TypeScript types and values rather than raw HTTP request and response objects. In general:\r\n\r\n- The Node.js HTTP server or Express.js application (your code) calls the router (generated code), which determines\r\n  which service operation function (generated code) to call based on the route, method, and other HTTP metadata in the\r\n  case of shared routes.\r\n- The operation function (generated code) deserializes the request body, query parameters, and headers into TypeScript\r\n  types, and may perform request validation.\r\n- The operation function (generated code) calls the service implementation (your code) with the deserialized request\r\n  data.\r\n- The service implementation (your code) returns a result or throws an error.\r\n- The operation function (generated code) responds to the HTTP request on your behalf, converting the result or error\r\n  into HTTP response data.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#versioning_operation_template_changes.md\n- document_title: How can I change the operation template of an operation in newer versions\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes\n- document_content: # troubleshoot#versioning_operation_template_changes.md\n\n# How can I change the operation template of an operation in newer versions\n\n## Symtoms\n\nIf you are switching to a different operation template in a new version, you may run into compilation errors if you only leverage `@added` and `@removed` versioning decorators.\n\n## Workaround\n\nIn the example below, you are switch from an old deprecated operation template to the new one. Note the uses of `@sharedRoute` and `renamedFrom` to avoid name and route conflict errors.\r\n\r\n```typespec\r\n  #suppress \"deprecated\" \"back compat\"\r\n  @removed(Versions.`2024-10-01-preview`)\r\n  @sharedRoute\r\n  @renamedFrom(Versions.`2024-10-01-preview`, \"delete\")\r\n  deleteOld is ArmResourceDeleteAsync<Employee>;\r\n\r\n  @added(Versions.`2024-10-01-preview`)\r\n  @sharedRoute\r\n  delete is ArmResourceDeleteWithoutOkAsync<Employee>;\r\n```\r\n\r\n**Please note**: In the `delete is ArmResourceDeleteAsync` example above, if you are RPSaaS service, you CAN do a direct replacement with `delete is ArmResourceDeleteWithoutOkAsync`. This is because RPSaaS will never send `200 OK`. Update in-place is just an API spec bug fix.\n", "latency": 7.13934063911438, "response_length": 641}
{"query": "Can someone help in fixing the update scenario issue in CLI that broke after migrating our swagger to use the TypeSpec spec?", "ground_truth": "To fix the update scenario issue in CLI that broke after migrating your swagger to use the TypeSpec spec, you need to add an `@OpenAPI.extension` decorator with the settings `\"x-ms-mutability\": [\"create\", \"update\", \"read\"]` for each of your resources that are affected. This change is necessary for both ProxyResource and TrackedResource types, and any resources using these templates. This adjustment addresses the visibility and mutability of properties in the ARM resource templates, ensuring they are correctly marked for create, update, and read operations. If your service is an RPaaS service and you're encountering issues with CLI updates, this solution should help rectify the problem by ensuring the properties bag is visible and mutable as required. Additionally, ensure all properties marked for creation are also marked for update to maintain consistency in PUT calls for both creation and update operations.", "response": "To fix the update scenario issue in your CLI after migrating from Swagger to TypeSpec, you can address potential breaking changes by ensuring the correct operation templates and augment decorators are applied. For PATCH operations, TypeSpec uses the `ArmResourcePatchAsync` template, which allows customization of the PATCH request body and follows the required 202 pattern for LROs. If the issue involves naming discrepancies for request payload parameters, you can use the `@@clientName` augment decorator to rename the `properties` parameter in the PATCH operation template. Here's an example:\n\n```tsp\ninterface Widgets {\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\n}\n\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\n```\n\nAdditionally, ensure that your `tspConfig.yaml` file is configured correctly to handle read-only status schemas if related violations occur. For example:\n\n```yaml\ntspconfig.yaml\nemit:\n  - \"@azure-tools/typespec-autorest\"\noptions:\n  \"@azure-tools/typespec-autorest\":\n    use-read-only-status-schema: true\n```\n\nIf the issue persists, you may need to review the generated TypeSpec for compliance with ARM RPC rules and address any linting violations highlighted during compilation.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#installation.md\n- document_title: Installation\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/installation\n- document_content: # getstarted#installation.md\n\n# Installation\n\n## Try TypeSpec without installing anything\n\nYou can try TypeSpec on the web without installing anything.\r\n\r\n- [TypeSpec playground](https://aka.ms/trytypespec)\r\n- [TypeSpec playground for Azure services](https://azure.github.io/typespec-azure/playground)\n\n## Installing TypeSpec core toolset\n\nSee https://typespec.io/docs to install the base requirements for working with TypeSpec:\r\n\r\n- NodeJS\r\n- Typespec CLI\r\n- VSCode or VS extension\n\n## Create an Azure TypeSpec project\n\n[See next doc](./createproject.md)\n\n## Additional tooling\n\n- `tsp-client`: A CLI tool that provides several commands to help during the TypeSpec development process, such as converting a swagger specification to a TypeSpec project, providing a simple interface to generate client libraries within the `azure-sdk-for-<language>` repositories, and more. For more information on the CLI tool, see the [tsp-client usage](https://aka.ms/azsdk/tsp-client) documentation\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n", "latency": 11.75034236907959, "response_length": 1266}
{"query": "Should TypeSpec generate the C# property as a Guid instead of a string when marked with @format('uuid')?", "ground_truth": "Yes, TypeSpec should generate the C# property as a Guid instead of a string when marked with @format('uuid'). This translation from uuid to Guid in C# is considered a valuable contribution and should be implemented. However, it's important to also include validation for any type marked with @format(uuid) to ensure it is a valid Guid. The use of Guids, especially in Azure Resource Manager (ARM) specifications, is subject to approval on a case-by-case basis due to concerns about their construction and serialization/deserialization. If Guids are absolutely required, approval from the Azure API review board is necessary.", "response": "No, TypeSpec should not generate the C# property as a `Guid` when marked with `@format('uuid')`. The `@format` decorator in TypeSpec is only meant to represent a known pattern for a string, such as 'uuid', and does not change the underlying type from `string`. Instead, if you want to represent a UUID in TypeSpec and have it mapped to a `Guid` in C#, you should use the `Azure.Core.uuid` type provided by the Azure Core library. This type is specifically designed to represent UUIDs and will be correctly emitted as `Guid` in C#.", "context": "- document_dir: typespec_docs\n- document_filename: standard-library#built-in-decorators.md\n- document_title: Built-in Decorators\n- document_link: https://typespec.io/docs/standard-library/built-in-decorators\n- document_content: # standard-library#built-in-decorators.md\n\n# Built-in Decorators\n\n## TypeSpec\n\n### `@continuationToken` {#@continuationToken}\n\nPagination property defining the token to get to the next page.\r\nIt MUST be specified both on the request parameter and the response.\r\n```typespec\r\n@continuationToken\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @continuationToken continuationToken: string;\r\n}\r\n@list op listPets(@continuationToken continuationToken: string): Page<Pet>;\r\n```\n\n### `@defaultVisibility` {#@defaultVisibility}\n\nDeclares the default visibility modifiers for a visibility class.\r\n\r\nThe default modifiers are used when a property does not have any visibility decorators\r\napplied to it.\r\n\r\nThe modifiers passed to this decorator _MUST_ be members of the target Enum.\r\n```typespec\r\n@defaultVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | the list of modifiers to use as the default visibility modifiers. |\n\n### `@discriminated` {#@discriminated}\n\nSpecify that this union is discriminated.\r\n```typespec\r\n@discriminated(options?: valueof DiscriminatedOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `DiscriminatedOptions`](./built-in-data-types.md#DiscriminatedOptions) | Options to configure the serialization of the discriminated union. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminated\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"kind\": \"cat\",\r\n  \"value\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"kind\": \"dog\",\r\n  \"value\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\r\n\r\n##### Custom property names\r\n\r\n\r\n```typespec\r\n@discriminated(#{discriminatorPropertyName: \"dataKind\", envelopePropertyName: \"data\"})\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"dataKind\": \"cat\",\r\n  \"data\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"dataKind\": \"dog\",\r\n  \"data\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\r\n```typespec\r\n@discriminator(propertyName: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| propertyName | [valueof `string`](#string) | The property name to use for discrimination |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet{ kind: string }\r\n\r\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\r\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\r\n```\n\n### `@doc` {#@doc}\n\nAttach a documentation string. Content support CommonMark markdown formatting.\r\n```typespec\r\n@doc(doc: valueof string, formatArgs?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n| formatArgs | `{}` | Record with key value pair that can be interpolated in the doc. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@doc(\"Represent a Pet available in the PetStore\")\r\nmodel Pet {}\r\n```\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\r\n```typespec\r\n@encode(encodingOrEncodeAs: Scalar | valueof string | EnumMember, encodedAs?: Scalar)\r\n```\r\n\r\n#### Target\r\n\r\n`Scalar | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| encodingOrEncodeAs | `Scalar` \\| `valueof string \\| EnumMember` | Known name of an encoding or a scalar type to encode as(Only for numeric types to encode as string). |\r\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\r\n\r\n#### Examples\r\n##### offsetDateTime encoded with rfc7231\r\n\r\n\r\n```tsp\r\n@encode(\"rfc7231\")\r\nscalar myDateTime extends offsetDateTime;\r\n```\r\n\r\n##### utcDateTime encoded with unixTimestamp\r\n\r\n\r\n```tsp\r\n@encode(\"unixTimestamp\", int32)\r\nscalar myDateTime extends unixTimestamp;\r\n```\r\n\r\n##### encode numeric type to string\r\n\r\n\r\n```tsp\r\nmodel Pet {\r\n  @encode(string) id: int64;\r\n}\r\n```\n\n### `@encodedName` {#@encodedName}\n\nProvide an alternative name for this type when serialized to the given mime type.\r\n```typespec\r\n@encodedName(mimeType: valueof string, name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mimeType | [valueof `string`](#string) | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| name | [valueof `string`](#string) | Alternative name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Certificate {\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"expiry\")\r\n  expireAt: int32;\r\n}\r\n```\r\n\r\n##### Invalid values\r\n\r\n\r\n```typespec\r\n@encodedName(\"application/merge-patch+json\", \"exp\")\r\n             ^ error cannot use subtype\r\n```\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\r\n```typespec\r\n@error\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@error\r\nmodel PetStoreError {\r\n  code: string;\r\n  message: string;\r\n}\r\n```\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\r\n```typespec\r\n@errorsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@errorsDoc(\"Errors doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@example` {#@example}\n\nProvide an example value for a data type.\r\n```typespec\r\n@example(example: valueof unknown, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Scalar | Union | ModelProperty | UnionVariant`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | `valueof unknown` | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@example(#{name: \"Fluffy\", age: 2})\r\nmodel Pet {\r\n name: string;\r\n age: int32;\r\n}\r\n```\n\n### `@firstLink` {#@firstLink}\n\nPagination property defining a link to the first page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@firstLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\r\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\r\nThe format names are open ended and are left to emitter to interpret.\r\n```typespec\r\n@format(format: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| format | [valueof `string`](#string) | format name. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\r\n```typespec\r\n@friendlyName(name: valueof string, formatArgs?: unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| name | [valueof `string`](#string) | name the template instance should take |\r\n| formatArgs | `unknown` | Model with key value used to interpolate the name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@friendlyName(\"{name}List\", T)\r\nmodel List<Item> {\r\n  value: Item[];\r\n  nextLink: string;\r\n}\r\n```\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\r\n```typespec\r\n@inspectType(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\r\n```typespec\r\n@inspectTypeName(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@invisible` {#@invisible}\n\nIndicates that a property is not visible in the given visibility class.\r\n\r\nThis decorator removes all active visibility modifiers from the property within\r\nthe given visibility class, making it invisible to any context that selects for\r\nvisibility modifiers within that class.\r\n```typespec\r\n@invisible(visibilityClass: Enum)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilityClass | `Enum` | The visibility class to make the property invisible within. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  @invisible(Lifecycle)\r\n  hidden_property: string;\r\n}\r\n```\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\r\n```typespec\r\n@key(altName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| altName | [valueof `string`](#string) | Name of the property. If not specified, the decorated property name is used. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Pet {\r\n  @key id: string;\r\n}\r\n```\n\n### `@lastLink` {#@lastLink}\n\nPagination property defining a link to the last page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@lastLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation that returns a paginated list of items.\r\n```typespec\r\n@list\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\nNone\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\r\n```typespec\r\n@maxItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxItems(5)\r\nmodel Endpoints is string[];\r\n```\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\r\n```typespec\r\n@maxLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxLength(20)\r\nscalar Username extends string;\r\n```\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\r\n```typespec\r\n@maxValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValue(200)\r\nscalar Age is int32;\r\n```\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@maxValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValueExclusive(50)\r\nscalar distance is float64;\r\n```\n\n### `@mediaTypeHint` {#@mediaTypeHint}\n\nApplies a media type hint to a TypeSpec type. Emitters and libraries may choose to use this hint to determine how a\r\ntype should be serialized. For example, the `@typespec/http` library will use the media type hint of the response\r\nbody type as a default `Content-Type` if one is not explicitly specified in the operation.\r\n\r\nMedia types (also known as MIME types) are defined by RFC 6838. The media type hint should be a valid media type\r\nstring as defined by the RFC, but the decorator does not enforce or validate this constraint.\r\n\r\nNotes: the applied media type is _only_ a hint. It may be overridden or not used at all. Media type hints are\r\ninherited by subtypes. If a media type hint is applied to a model, it will be inherited by all other models that\r\n`extend` it unless they delcare their own media type hint.\r\n```typespec\r\n@mediaTypeHint(mediaType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Scalar | Enum | Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mediaType | [valueof `string`](#string) | The media type hint to apply to the target type. |\r\n\r\n#### Examples\r\n##### create a model that serializes as XML by default\r\n\r\n\r\n```tsp\r\n@mediaTypeHint(\"application/xml\")\r\nmodel Example {\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n```\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\r\n```typespec\r\n@minItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minItems(1)\r\nmodel Endpoints is string[];\r\n```\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\r\n```typespec\r\n@minLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minLength(2)\r\nscalar Username extends string;\r\n```\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\r\n```typespec\r\n@minValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValue(18)\r\nscalar Age is int32;\r\n```\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@minValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValueExclusive(0)\r\nscalar distance is float64;\r\n```\n\n### `@nextLink` {#@nextLink}\n\nPagination property defining a link to the next page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@nextLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@offset` {#@offset}\n\nPagination property defining the number of items to skip.\r\n```typespec\r\n@offset\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@offset skip: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@opExample` {#@opExample}\n\nProvide example values for an operation's parameters and corresponding return type.\r\n```typespec\r\n@opExample(example: valueof OperationExample, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | [valueof `OperationExample`](./built-in-data-types.md#OperationExample) | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@opExample(#{parameters: #{name: \"Fluffy\", age: 2}, returnType: #{name: \"Fluffy\", age: 2, id: \"abc\"})\r\nop createPet(pet: Pet): Pet;\r\n```\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\r\n```typespec\r\n@overload(overloadbase: Operation)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\r\n@overload(upload)\r\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\r\n@overload(upload)\r\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\r\n```\n\n### `@pageIndex` {#@pageIndex}\n\nPagination property defining the page index.\r\n```typespec\r\n@pageIndex\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageItems` {#@pageItems}\n\nSpecify the the property that contains the array of page items.\r\n```typespec\r\n@pageItems\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageSize` {#@pageSize}\n\nSpecify the pagination parameter that controls the maximum number of items to include in a page.\r\n```typespec\r\n@pageSize\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nDeclares the visibility constraint of the parameters of a given operation.\r\n\r\nA parameter or property nested within a parameter will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@parameterVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the parameters of this operation. |\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\r\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\r\nAdvanced features like look-around, capture groups, and references are not supported.\r\n\r\nThis decorator may optionally provide a custom validation _message_. Emitters may choose to use the message to provide\r\ncontext when pattern validation fails. For the sake of consistency, the message should be a phrase that describes in\r\nplain language what sort of content the pattern attempts to validate. For example, a complex regular expression that\r\nvalidates a GUID string might have a message like \"Must be a valid GUID.\"\r\n```typespec\r\n@pattern(pattern: valueof string, validationMessage?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | bytes | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| pattern | [valueof `string`](#string) | Regular expression. |\r\n| validationMessage | [valueof `string`](#string) | Optional validation message that may provide context when validation fails. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@pattern(\"[a-z]+\", \"Must be a string consisting of only lower case letters and of at least one character.\")\r\nscalar LowerAlpha extends string;\r\n```\n\n### `@prevLink` {#@prevLink}\n\nPagination property defining a link to the previous page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@prevLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@removeVisibility` {#@removeVisibility}\n\nRemoves visibility modifiers from a property.\r\n\r\nIf the visibility modifiers for a visibility class have not been initialized,\r\nthis decorator will use the default visibility modifiers for the visibility\r\nclass as the default modifier set.\r\n```typespec\r\n@removeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\nThe property to remove visibility from.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | The visibility modifiers to remove from the target property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  // This property will have all Lifecycle visibilities except the Read\r\n  // visibility, since it is removed.\r\n  @removeVisibility(Lifecycle.Read)\r\n  secret_property: string;\r\n}\r\n```\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\r\n```typespec\r\n@returnsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@returnsDoc(\"Returns doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nDeclares the visibility constraint of the return type of a given operation.\r\n\r\nA property within the return type of the operation will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@returnTypeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the return type of this operation. |\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\r\n```typespec\r\n@secret\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@secret\r\nscalar Password is string;\r\n```\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\r\n```typespec\r\n@service(options?: valueof ServiceOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `ServiceOptions`](./built-in-data-types.md#ServiceOptions) | Optional configuration for the service. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service title\r\n\r\n```typespec\r\n@service(#{title: \"Pet store\"})\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service version\r\n\r\n```typespec\r\n@service(#{version: \"1.0\"})\r\nnamespace PetStore;\r\n```\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\r\n```typespec\r\n@summary(summary: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| summary | [valueof `string`](#string) | Summary string. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@summary(\"This is a pet\")\r\nmodel Pet {}\r\n```\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\r\n```typespec\r\n@tag(tag: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| tag | [valueof `string`](#string) | Tag value |\n\n### `@visibility` {#@visibility}\n\nSets the visibility modifiers that are active on a property, indicating that it is only considered to be present\r\n(or \"visible\") in contexts that select for the given modifiers.\r\n\r\nA property without any visibility settings applied for any visibility class (e.g. `Lifecycle`) is considered to have\r\nthe default visibility settings for that class.\r\n\r\nIf visibility for the property has already been set for a visibility class (for example, using `@invisible` or\r\n`@removeVisibility`), this decorator will **add** the specified visibility modifiers to the property.\r\n\r\nSee: [Visibility](https://typespec.io/docs/language-basics/visibility)\r\n\r\nThe `@typespec/http` library uses `Lifecycle` visibility to determine which properties are included in the request or\r\nresponse bodies of HTTP operations. By default, it uses the following visibility settings:\r\n\r\n- For the return type of operations, properties are included if they have `Lifecycle.Read` visibility.\r\n- For POST operation parameters, properties are included if they have `Lifecycle.Create` visibility.\r\n- For PUT operation parameters, properties are included if they have `Lifecycle.Create` or `Lifecycle.Update` visibility.\r\n- For PATCH operation parameters, properties are included if they have `Lifecycle.Update` visibility.\r\n- For DELETE operation parameters, properties are included if they have `Lifecycle.Delete` visibility.\r\n- For GET or HEAD operation parameters, properties are included if they have `Lifecycle.Query` visibility.\r\n\r\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type |\n\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibilities which apply to this property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  // The service will generate an ID, so you don't need to send it.\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // The service will store this secret name, but won't ever return it.\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  // The regular name has all vi\r\n  name: string;\r\n}\r\n```\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\r\n\r\nThis will set the visibility modifiers of all key properties in the model if the visibility is not already _explicitly_ set,\r\nbut will not change the visibility of any properties that have visibility set _explicitly_, even if the visibility\r\nis the same as the default visibility.\r\n\r\nVisibility may be set explicitly using any of the following decorators:\r\n\r\n- `@visibility`\r\n- `@removeVisibility`\r\n- `@invisible`\r\n```typespec\r\n@withDefaultKeyVisibility(visibility: valueof EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibility | `valueof EnumMember` | The desired default visibility value. If a key property already has visibility set, it will not be changed. |\n\n### `@withLifecycleUpdate` {#@withLifecycleUpdate}\n\nTransforms the `target` model to include only properties that are visible during the\r\n\"Update\" lifecycle phase.\r\n\r\nAny nested models of optional properties will be transformed into the \"CreateOrUpdate\"\r\nlifecycle phase instead of the \"Update\" lifecycle phase, so that nested models may be\r\nfully updated.\r\n```typespec\r\n@withLifecycleUpdate\r\n```\r\n\r\n#### Target\r\nThe model to apply the transformation to.\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@withLifecycleUpdate\r\nmodel DogUpdate {\r\n  ...Dog\r\n}\r\n```\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\r\n```typespec\r\n@withOptionalProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#prevent-format.md\n- document_title: prevent-format\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/prevent-format\n- document_content: # libraries#azure-core#rules#prevent-format.md\n\n# prevent-format\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/prevent-format\r\n```\r\n\r\nUsing the `@format` decorator is disallowed. While in OpenAPI `format:` was used to both represent a known string format and a more precise type, in TypeSpec `@format` is only meant to represent a known pattern for a string. This means that using `@format` would result in a `string` type with some validation.\n\n## Mapping of format to types\n\n| Format   | Type                               |\r\n| -------- | ---------------------------------- |\r\n| `int32`  | `int32`                            |\r\n| `uri`    | `url`                              |\r\n| `url`    | `url`                              |\r\n| `uuid`   | `Azure.Core.uuid`                  |\r\n| `eTag`   | `Azure.Core.eTag`                  |\r\n| `arm-id` | `Azure.Core.armResourceIdentifier` |\r\n| `ipv4`   | `Azure.Core.ipV4Address`           |\r\n| `ipv6`   | `Azure.Core.ipV6Address`           |\r\n| `ipv6`   | `Azure.Core.azureLocation`         |\n\n## Examples\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @format(\"uuid\")\r\n  id: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  id: Azure.Core.uuid;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#cli.md\n- document_title: OpenAPI3 to TypeSpec\n- document_link: https://typespec.io/docs/emitters/openapi3/cli\n- document_content: # emitters#openapi3#cli.md\n\n# OpenAPI3 to TypeSpec\n\n:::caution\r\nThe OpenAPI3 to TypeSpec conversion purpose is a one time conversion to help you get started with TypeSpec.\r\nThe output can change in future versions of TypeSpec without being considered a breaking change.\r\n:::\n\n## Converting OpenAPI 3 into TypeSpec\n\nThis package includes the `tsp-openapi3` CLI for converting OpenAPI 3 specs into TypeSpec.\r\nThe generated TypeSpec depends on the `@typespec/http`, `@typespec/openapi` and `@typespec/openapi3` libraries.\n\n### Usage\n\n1. via the command line\r\n\r\n```bash\r\ntsp-openapi3 ./openapi3spec.yml --output-dir ./tsp-output\r\n```\n\n### tsp-openapi3 arguments\n\nThe path to the OpenAPI3 yaml or json file **must** be passed as a position argument.\r\n\r\nThe named arguments are:\r\n\r\n| Name       | Type    | Required | Description                                                                              |\r\n| ---------- | ------- | -------- | ---------------------------------------------------------------------------------------- |\r\n| output-dir | string  | required | The output directory for generated TypeSpec files. Will be created if it does not exist. |\r\n| help       | boolean | optional | Show help.                                                                               |\n\n## Examples\n\n### 1. Convert component schemas into models\n\nAll schemas present at `#/components/schemas` will be converted into a model or scalar as appropriate.\r\n\r\n<table>\r\n<tr>\r\n<td>OpenAPI3</td>\r\n<td>TypeSpec</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 1.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```yml\r\ncomponents:\r\n  schemas:\r\n    Widget:\r\n      type: object\r\n      required:\r\n        - id\r\n        - weight\r\n        - color\r\n      properties:\r\n        id:\r\n          type: string\r\n        weight:\r\n          type: integer\r\n          format: int32\r\n        color:\r\n          type: string\r\n          enum:\r\n            - red\r\n            - blue\r\n    uuid:\r\n      type: string\r\n      format: uuid\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```tsp\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## Detailed Example for Converting Component Schemas\n\nThis example demonstrates how to convert component schemas from OpenAPI3 to TypeSpec.\n\n### OpenAPI3\n\n```yml\r\ncomponents:\r\n  schemas:\r\n    Product:\r\n      type: object\r\n      required:\r\n        - id\r\n        - name\r\n      properties:\r\n        id:\r\n          type: string\r\n        name:\r\n          type: string\r\n        price:\r\n          type: number\r\n          format: float\r\n```\n\n### TypeSpec\n\n```tsp\r\nmodel Product {\r\n  id: string;\r\n  name: string;\r\n  price: float;\r\n}\r\n```\r\n\r\nIn this example, the `Product` schema from OpenAPI3 is converted into a TypeSpec model.\n\n## Detailed Example for Converting Component Parameters\n\nThis example demonstrates how to convert component parameters from OpenAPI3 to TypeSpec.\n\n### OpenAPI3\n\n```yml\r\ncomponents:\r\n  parameters:\r\n    ProductId:\r\n      name: id\r\n      in: path\r\n      required: true\r\n      schema:\r\n        type: string\r\n```\n\n### TypeSpec\n\n```tsp\r\nmodel Product {\r\n  @path id: string;\r\n}\r\n```\r\n\r\nIn this example, the `ProductId` parameter from OpenAPI3 is converted into a TypeSpec model with a `@path` decorator.\n\n## Detailed Example for Converting Path Routes to Operations\n\nThis example demonstrates how to convert path routes from OpenAPI3 to TypeSpec operations.\n\n### OpenAPI3\n\n```yml\r\npaths:\r\n  /products/{id}:\r\n    get:\r\n      operationId: getProduct\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          description: Successful response\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Product\"\r\n```\n\n### TypeSpec\n\n```tsp\r\n/**\r\n * Successful response\r\n */\r\nmodel getProduct200ApplicationJsonResponse {\r\n  @statusCode statusCode: 200;\r\n  @bodyRoot body: Product;\r\n}\r\n\r\n@route(\"/products/{id}\") @get op getProduct(@path id: string): getProduct200ApplicationJsonResponse;\r\n```\r\n\r\nIn this example, the `getProduct` path route from OpenAPI3 is converted into a TypeSpec operation with a response model.\n\n### 2. Convert component parameters into models or fields\n\nAll parameters present at `#/components/parameters` will be converted to a field in a model. If the model doesn't exist in `#/components/schemas`, then it will be created.\r\n\r\n<table>\r\n<tr>\r\n  <td>OpenAPI3</td>\r\n  <td>TypeSpec</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 2.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```yml\r\ncomponents:\r\n  parameters:\r\n    Widget.id:\r\n      name: id\r\n      in: path\r\n      required: true\r\n      schema:\r\n        type: string\r\n  schemas:\r\n    Widget:\r\n      type: object\r\n      required:\r\n        - id\r\n        - weight\r\n        - color\r\n      properties:\r\n        id:\r\n          type: string\r\n        weight:\r\n          type: integer\r\n          format: int32\r\n        color:\r\n          type: string\r\n          enum:\r\n            - red\r\n            - blue\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```tsp\r\nmodel Widget {\r\n  @path id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n```\r\n\r\n</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 2.2  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```yml\r\ncomponents:\r\n  parameters:\r\n    Foo.id:\r\n      name: id\r\n      in: path\r\n      required: true\r\n      schema:\r\n        type: string\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```tsp\r\nmodel Foo {\r\n  @path id: string;\r\n}\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n### 3. Convert path routes to operations\n\nAll routes using one of the HTTP methods supported by `@typespec/http` will be converted into operations at the file namespace level. A model is also generated for each operation response.\r\n\r\nAt this time, no automatic operation grouping under interfaces is performed.\r\n\r\n<table>\r\n<tr>\r\n  <td>OpenAPI3</td>\r\n  <td>TypeSpec</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 3.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```yml\r\npaths:\r\n  /{id}:\r\n    get:\r\n      operationId: readWidget\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Widget\"\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```tsp\r\n/**\r\n * The request has succeeded.\r\n */\r\nmodel readWidget200ApplicationJsonResponse {\r\n  @statusCode statusCode: 200;\r\n  @bodyRoot body: Widget;\r\n}\r\n\r\n@route(\"/{id}\") @get op readWidget(@path id: string): readWidget200ApplicationJsonResponse;\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n", "latency": 12.506041765213013, "response_length": 530}
{"query": "What is the correct way to mark an enum with modelAsString: false?", "ground_truth": "To mark an enum with modelAsString: false, currently, you should use the @fixed decorator and suppress any warnings. However, this approach is in the process of being deprecated. In the future, enums will be automatically treated as fixed, and for extensible enums, a union with a string variant should be used instead. This change will be enforced starting from next week.", "response": "To mark an enum with `modelAsString: false`, you should convert the enum into a union type that includes the base scalar type (e.g., `string`) as one of its variants. This approach ensures extensibility, as Azure services no longer treat enums as extensible. For example:\n\n```tsp\nunion PetKind {\n  Cat: \"Cat\",\n  Dog: \"Dog\",\n  string,\n}\n```\n\nThis union type effectively replaces the traditional enum and allows for extensibility by including the `string` variant. If you see the linter warning `@azure-tools/typespec-azure-core/no-enum`, it also provides an automatic code fix in VS Code.", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the (ℹ) bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Models with additional properties\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\n### Discriminator\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\n### Nullable\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-enum.md\n- document_title: no-enum\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n- document_content: # libraries#azure-core#rules#no-enum.md\n\n# no-enum\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-enum\r\n```\r\n\r\nAzure services favor extensible enums to avoid breaking changes as new enum values are added. TypeSpec enums are closed.\r\nUsing a union with the base scalar(`string`, `int32`, `int64`, etc.) as a variant instead of an enum makes it extensible.\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\r\n\r\nOk. Enum is allowed for versioning purposes.\r\n\r\n```tsp\r\nenum Version {\r\n  2021_01_01: \"2021-01-01\",\r\n  2022_01_01: \"2022-01-01\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#identifiers.md\n- document_title: Identifiers\n- document_link: https://typespec.io/docs/language-basics/identifiers\n- document_content: # language-basics#identifiers.md\n\n# Identifiers\n\nIdentifiers are used to name models, enums, properties, and other entities in TypeSpec. An identifier is a sequence of one or more characters that must start with a letter, emoji, underscore, or dollar sign, and be followed by letters, numbers, emoji, underscores, or dollar signs. TypeSpec implements [UAX31-R1b stable identifiers](http://www.unicode.org/reports/tr31/#R1b) with the [emoji profile](http://www.unicode.org/reports/tr31/#Emoji_Profile).\r\n\r\nExamples:\r\n\r\n- ✅ `cat`\r\n- ✅ `Dog`\r\n- ✅ `_Item2`\r\n- ✅ `$money$`\r\n- ✅ `🎉`\r\n- ✅ `🚀`\r\n- ❌ `1cat`\r\n- ❌ `*dog`\n\n## Reserved identifiers\n\nAll keywords are reserved identifiers in TypeSpec. However they can still be used when escaping with wrapping with `\\`` characters.\r\n\r\n```tsp\r\nmodel `enum` {}\r\n```\n", "latency": 13.073312997817993, "response_length": 587}
{"query": "Should the @fixed decorator be used and the warning suppressed, or is there another method?", "ground_truth": "Yes, the @fixed decorator should be used and the warning suppressed for now. However, this method is being phased out. In the future, enums will automatically be considered fixed, and for extensible enums, it is recommended to use a union with a string variant.", "response": "The decision to use the `@fixed` decorator or suppress the warning depends on the specific situation. If the warning is valid and the rule violation can be resolved by following the linting advice, it is recommended to use the appropriate decorator (e.g., `@armResourceAction`) to fix the issue. This ensures compliance with ARM RPC rules and maintains the integrity of your TypeSpec code.\n\nHowever, if the warning is a false positive or there is an approved reason for not adhering to the rule, you can suppress the warning using the `#suppress` directive. Suppression should include a clear justification for why the rule is being bypassed.\n\nFor example:\n\nTo fix the warning:\n```typespec\n@armResourceAction(ZeroTrustResource)\n/** Gets the Zero Trust URL for this resource */\n@post\ngetZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\n```\n\nTo suppress the warning:\n```typespec\n#suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\n/** Gets the Zero Trust URL for this resource */\n@post\ngetZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\n```", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#suppresswarnings.md\n- document_title: How to suppress warnings\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\n- document_content: # troubleshoot#suppresswarnings.md\n\n# How to suppress warnings\n\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\n\n## Symptoms\n\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\n\n## Cause\n\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\n\n## Workaround\n\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\r\n\r\nFor example:\r\n\r\n```tsp\r\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\r\n/** An array of details about specific errors that led to this reported error. */\r\ndetails: Error[];\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#directives.md\n- document_title: Directives\n- document_link: https://typespec.io/docs/language-basics/directives\n- document_content: # language-basics#directives.md\n\n# Directives\n\nDirectives are predefined annotations that attach to the syntax nodes unlike decorators which will cary over with `model is`, `op is`, etc. This means any syntax node is able to have a directive(e.g `alias`).\r\n\r\nThese are the available directives:\r\n\r\n- [#deprecated](#deprecated)\r\n- [#suppress](#suppress)\n\n## #deprecated\n\nThe deprecated directive allows marking a node and through it its type as deprecated. It takes a single argument which is the deprecation message.\r\n\r\n```tsp\r\n#deprecated \"Use NewUser instead\"\r\nmodel LegacyUser {}\r\n```\r\n\r\nUsing that type will result in a deprecation warning:\r\n\r\n```tsp\r\nmodel Post {\r\n  author: LegacyUser;\r\n  //      ^ warning: Deprecated: Use NewUser instead\r\n}\r\n```\r\n\r\n<!-- cspell:disable -->\r\n\r\n```ansi frame=\"terminal\"\r\n$ tsp compile .\r\n\r\nDiagnostics were reported during compilation:\r\n\r\n\u001b[36mmain.tsp\u001b[39m:\u001b[33m5\u001b[39m:\u001b[33m11\u001b[39m - \u001b[33mwarning\u001b[39m\u001b[90m deprecated\u001b[39m: Deprecated: Use NewUser instead\r\n> 5 |   author: LegacyUser;\r\n    |           ^^^^^^^^^^\r\n\r\nFound  1 warning.\r\n```\r\n\r\n<!-- cspell:enable -->\r\n\r\nAdding another `#suppress` on a node that reports a deprecation warning will suppress the warning automatically.\r\n\r\n```tsp\r\nmodel Post {\r\n  #suppress \"Use newAuthor property instead\"\r\n  author: LegacyUser; // no need to also suppress the deprecated diagnostic about usage of LegacyUser\r\n}\r\n```\n\n### Api\n\nA library or emitter can check if a type was annotated with the deprecated directive using the `isDeprecated` method and/or get the message using `getDeprecationDetails`.\r\n\r\n```ts\r\nimport { getDeprecationDetails, isDeprecated } from \"@typespec/compiler\";\r\nconst isDeprecated = isDeprecated(program, type);\r\nconst details = getDeprecationDetails(program, type);\r\n```\n\n## #suppress\n\nSuppress directive allows suppressing a specific warning diagnostic. It takes 2 arguments:\r\n\r\n- The diagnostic code to suppress\r\n- A message to justify the suppression\r\n\r\n:::note\r\nErrors are not suppressable\r\n:::\r\n\r\n```tsp\r\nmodel Post {\r\n  #suppress \"deprecated\" \"We are not ready to migrate yet\"\r\n  author: LegacyUser;\r\n}\r\n```\r\n\r\n```tsp\r\n#suppress \"@typespec/http/no-service-found\" \"standard library route\"\r\nnamespace Lib {\r\n  @route(\"/test\") op get(): string;\r\n}\r\n```\n\n### Api\n\nThere is currently no exposed api to resolve suppresssions\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#models.md\n- document_title: Models\n- document_link: https://typespec.io/docs/language-basics/models\n- document_content: # language-basics#models.md\n\n# Models\n\nModels in TypeSpec are utilized to define the structure or schema of data.\n\n## Types of models\n\nModels can be categorized into two main types:\r\n\r\n- [Record](#record)\r\n- [Array](#array)\n\n### Record\n\nA Record model is a structure that consists of named fields, referred to as properties.\r\n\r\n- The name can be an [`identifier`](./identifiers.md) or `string literal`.\r\n- The type can be any type reference.\r\n- Properties are arranged in a specific order. Refer to [property ordering](#property-ordering) for more details.\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\r\n\r\n#### Optional properties\r\n\r\nProperties can be designated as optional by using the `?` symbol.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string;\r\n}\r\n```\r\n\r\n#### Default values\r\n\r\nProperties can be assigned a default value using the `=` operator.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string = \"wild\";\r\n  age: uint8 = 0;\r\n}\r\n```\r\n\r\n#### Property ordering\r\n\r\nProperties are arranged in the order they are defined in the source. Properties acquired via `model is` are placed before properties defined in the model body. Properties obtained via `...` are inserted at the point where the spread appears in the source.\r\n\r\nExample:\r\n\r\n```tsp\r\nmodel Pet {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n\r\nmodel HasHome {\r\n  address: string;\r\n}\r\n\r\nmodel Cat is Pet {\r\n  meow: boolean;\r\n  ...HasHome;\r\n  furColor: string;\r\n}\r\n\r\n// The resulting property order for Cat is:\r\n// name, age, meow, address, furColor\r\n```\n\n### Additional properties\n\nThe `Record<T>` model can be used to define a model with an arbitrary number of properties of type T. It can be combined with a named model to provide some known properties.\r\n\r\nThere are three ways to achieve this, each with slightly different semantics:\r\n\r\n- Using the `...` operator\r\n- Using the `is` operator\r\n- Using the `extends` operator\r\n\r\n#### Using the `...` operator\r\n\r\nSpreading a Record into your model implies that your model includes all the properties you have explicitly defined, plus any additional properties defined by the Record. This means that a property in the model could be of a different and incompatible type with the Record value type.\r\n\r\n```tsp\r\n// In this example, the Person model has a property `age` that is an int32, but also has other properties that are all strings.\r\nmodel Person {\r\n  age: int32;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\n#### Using the `is` operator\r\n\r\nWhen using `is Record<T>`, it indicates that all properties of this model are of type T. This means that each property explicitly defined in the model must also be of type T.\r\n\r\nThe example above would be invalid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  age: int32;\r\n  //   ^ int32 is not assignable to string\r\n}\r\n```\r\n\r\nBut the following would be valid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  name: string;\r\n}\r\n```\r\n\r\n#### Using the `extends` operator\r\n\r\nThe `extends` operator has similar semantics to `is`, but it defines the relationship between the two models. In many languages, this would probably result in the same emitted code as `is` and it is recommended to use `is Record<T>` instead.\r\n\r\n```tsp\r\nmodel Person extends Record<string> {\r\n  name: string;\r\n}\r\n```\n\n### Special property types\n\n#### `never`\r\n\r\nA model property can be declared as having the type `never`. This can be interpreted as the model not having that property.\r\n\r\nThis can be useful in a model template to omit a property.\r\n\r\n```typespec\r\nmodel Address<TState> {\r\n  state: TState;\r\n  city: string;\r\n  street: string;\r\n}\r\n\r\nmodel UKAddress is Address<never>;\r\n```\r\n\r\n:::note\r\nThe responsibility of removing `never` properties lies with the emitter. The TypeSpec compiler will not automatically omit them.\r\n:::\n\n### Array\n\nArrays are models created using the `[]` syntax, which is a shorthand for using the `Array<T>` model type.\n\n## Model composition\n\n### Spread\n\nThe spread operator (`...`) copies the members of a source model into a target model. This operation doesn't create any nominal relationship between the source and target, making it useful when you want to reuse common properties without generating complex inheritance relationships.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Dog {\r\n  ...Animal;\r\n  ...Pet;\r\n}\r\n\r\n// The Dog model is equivalent to the following declaration:\r\nmodel Dog {\r\n  species: string;\r\n  name: string;\r\n}\r\n```\n\n### Extends\n\nThere are times when you want to create an explicit relationship between two models, such as when you're generating class definitions in languages that support inheritance. The `extends` keyword can be used to establish this relationship.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Dog extends Animal {}\r\n```\n\n### Is\n\nThere are instances when you want to create a new type that is an exact copy of an existing type but with additional properties or metadata, without creating a nominal inheritance relationship. The `is` keyword can be used for this purpose. It copies all the properties (like spread), but also copies [decorators](./decorators.md) as well. A common use case is to provide a better name to a [template](#model-templates) instantiation:\r\n\r\n```typespec\r\n@decorator\r\nmodel Thing<T> {\r\n  property: T;\r\n}\r\n\r\nmodel StringThing is Thing<string>;\r\n\r\n// The StringThing declaration is equivalent to the following declaration:\r\n@decorator\r\nmodel StringThing {\r\n  property: string;\r\n}\r\n```\n\n## Model templates\n\nRefer to [templates](./templates.md) for more details on templates.\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Meta type references\n\nSome model property meta types can be referenced using `::`.\r\n\r\n| Name | Example          | Description                              |\r\n| ---- | ---------------- | ---------------------------------------- |\r\n| type | `Pet.name::type` | Reference the type of the model property |\n", "latency": 15.387624263763428, "response_length": 1207}
{"query": "How should enums with modelAsString attributes be described in a new API version using TypeSpec?", "ground_truth": "Enums with modelAsString attributes in a new API version using TypeSpec should be described using the @fixed decorator for now, with the warning suppressed. This approach is temporary, as the process is moving towards automatically treating enums as fixed. For extensible enums, a union with a string variant should be utilized. This change will be enforced in the near future.", "response": "In a new API version using TypeSpec, enums with `modelAsString` attributes can be described by using the `@renamedFrom` decorator to indicate changes in the enum values or structure. This ensures backward compatibility and allows the OpenAPI emitter to generate the correct schema for each version. For example:\n\n```typespec\n@versioned(MyNamespace.Versions)\nnamespace MyNamespace;\n\nenum Versions {\n  v1,\n  v2,\n}\n\nenum Status {\n  @renamedFrom(Versions.v2, \"OldStatus\")\n  Active: \"active\",\n  Inactive: \"inactive\",\n}\n```\n\nThis approach ensures that the OpenAPI emitter generates the correct `enum` schema for each version, reflecting changes in the enum values or names.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#openapi3#openapi.md\n- document_title: OpenAPI v3 emitter\n- document_link: https://typespec.io/docs/emitters/openapi3/openapi\n- document_content: # emitters#openapi3#openapi.md\n\n# OpenAPI v3 emitter\n\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\r\n\r\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\n\n## Server Details\n\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\r\n\r\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\r\n\r\n```typespec\r\n@server(\"https://api.example.com/v1\", \"Primary production endpoint\")\r\n@server(\"https://api-dev.example.com/v1\", \"Development endpoint\")\r\nnamespace MyService;\r\n```\n\n## Operations\n\nEach TypeSpec operation is converted into an OpenAPI operation.\n\n### HTTP Method\n\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\r\n\r\n- `@get`\r\n- `@post`\r\n- `@put`\r\n- `@patch`\r\n- `@delete`\r\n\r\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\r\n\r\n```typespec\r\n// Explicitly declared as GET /{id}\r\n@get\r\nop getUser(@path id: string): User;\r\n\r\n// Explicitly declared as POST /\r\n@post\r\nop createUser(user: User): User;\r\n\r\n// Automatically detected as GET /{id}\r\nop getUser(@path id: string): User;\r\n\r\n// Automatically detected as POST /\r\nop createUser(user: User): User;\r\n```\n\n### Operation Path\n\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\r\n\r\n- Individual operations\r\n- Interfaces (groups of operations)\r\n- Namespaces\r\n\r\nWhen you apply routes to multiple levels, they're combined to form the complete path:\r\n\r\n```typespec\r\n@route(\"/api\")\r\nnamespace MyService {\r\n  @route(\"/users\")\r\n  interface Users {\r\n    // Results in GET /api/users/{id}\r\n    @route(\"/{id}\")\r\n    @get\r\n    getUser(@path id: string): User;\r\n  }\r\n}\r\n```\r\n\r\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\r\n\r\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\r\n\r\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### Description\n\nThe operation's description comes from the documentation of the TypeSpec operation.\r\n\r\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n\r\n@doc(\"Retrieves a user by their unique identifier.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no documentation is provided, the description field is omitted.\r\n\r\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\n\n### Summary\n\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\n@summary(\"Get a User by ID.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no `@summary` is provided, the summary field is omitted.\r\n\r\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\n\n### Operation ID\n\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\r\n\r\n```typespec\r\n@operationId(\"getUserById\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nIf not explicitly defined, the operation ID defaults to:\r\n\r\n- The operation name (when the operation is not in an interface)\r\n- The interface name followed by the operation name (when in an interface)\r\n\r\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\n\n### Parameters and Request Body\n\nTypeSpec operation parameters map to OpenAPI parameters and request body.\r\n\r\n#### Parameter Location\r\n\r\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\r\n\r\n- `@query` - Query parameter in the URL\r\n- `@header` - HTTP header parameter\r\n- `@path` - Path parameter in the URL\r\n\r\nParameters without these decorators are assumed to be in the request body.\r\n\r\n```typespec\r\nop createUser(\r\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\r\n  // to the `content-type` header\r\n  @header contentType: string,\r\n\r\n  @query include: string,\r\n  @path id: string,\r\n\r\n  // The request body will be a JSON object `{ \"user\": <User> }`\r\n  user: User, // This goes in the request body\r\n): User;\r\n```\r\n\r\n#### Request Body\r\n\r\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\r\n\r\n```typespec\r\n// The request body will be a JSON object that _only_ contains the User at the top level.\r\nop createUser(@body user: User): User;\r\n```\r\n\r\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\r\n\r\n```typespec\r\nop updateUser(@path id: string, @body user?: User): User;\r\n```\r\n\r\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../..\n\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\n### Responses\n\nstatus code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\r\n\r\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\nThe operation's return type(s) translate into OpenAPI responses.\r\n\r\n#### Status Codes\r\n\r\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  body: User;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse;\r\n```\r\n\r\nYou can define multiple response types to handle different status codes:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  user: User;\r\n}\r\n\r\nmodel UserNotFoundResponse {\r\n  @statusCode\r\n  code: 404;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\r\n```\r\n\r\n#### Error Responses\r\n\r\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \"default\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\r\n\r\n```typespec\r\n@error\r\nmodel ErrorResponse {\r\n  @statusCode\r\n  code: 404 | 500;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): User | ErrorResponse;\r\n```\r\n\r\n#### Response Body\r\n\r\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode code: 200;\r\n\r\n  // If the status code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\n\n### Tags\n\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\r\n\r\n```typespec\r\n@tag(\"Users\")\r\nop getUser(id: string): User;\r\n\r\n// Or at interface/namespace level\r\n@tag(\"Users\")\r\ninterface UserOperations {\r\n  getUser(id: string): User;\r\n  createUser(@body user: User): User;\r\n}\r\n```\r\n\r\nTags from operations, interfaces, and enclosing namespaces are combined.\r\n\r\n[tag-decorator]: ../../standard-library/built-in-decorators.md#@tag\n\n### Deprecated\n\nMark an operation as deprecated using the (built-in) `#deprecated` directive.\r\n\r\n```typespec\r\n#deprecated \"Use getUser instead\"\r\nop fetchUser(id: string): User;\r\n```\r\n\r\nThis sets the `deprecated` field to `true` in the OpenAPI operation.\n\n### External Documentation\n\nAdd external documentation links using the [(OpenAPI) `@externalDocs` decorator](../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.externalDocs):\r\n\r\n```typespec\r\n@externalDocs(\"https://example.com/docs/users\", \"Additional user documentation\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nThe external documentation links are specific to the OpenAPI emitter and will not be used by any other emitters unless they are designed to interoperate with OpenAPI.\n\n### Specification Extensions\n\nAdd custom OpenAPI extensions for your use cases using the [(OpenAPI) `@extension` decorator][openapi-extension-decorator].\r\n\r\n```typespec\r\n@extension(\"x-ms-pageable\", #{ nextLinkName: \"nextLink\" })\r\nop listUsers(): UserList;\r\n```\r\n\r\nThe first argument to `@extension` becomes a key in the operation object, and the second argument is any JSON/YAML-like value. This decorator may be used to add arbitrary customization/extension to many OpenAPI constructs including schemas for TypeSpec types, operations, etc.\r\n\r\n[openapi-extension-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.extension\n\n## Models and Enums\n\nTypeSpec models and enums convert to OpenAPI schemas.\n\n### Schema Location\n\nModels are handled differently based on how they're defined:\r\n\r\n- **Named models**: defined in `components/schemas` section.\r\n- **Inline models**: defined inline where used.\r\n- **Template instances**: treated as inline unless they have a [(built-in) `@friendlyName` decorator][friendlyname], which causes them to be treated as named models.\r\n\r\n[friendlyname]: ../../standard-library/built-in-decorators.md#@friendlyName\n\n### Type Mapping\n\nThis table shows how TypeSpec types map to OpenAPI/JSON Schema types:\r\n\r\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\r\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\r\n| `int32`          | `type: integer, format: int32`    |                                                                           |\r\n| `int64`          | `type: integer, format: int64`    |                                                                           |\r\n| `float32`        | `type: number, format: float`     |                                                                           |\r\n| `float64`        | `type: number, format: double`    |                                                                           |\r\n| `string`         | `type: string`                    |                                                                           |\r\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\r\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `boolean`        | `type: boolean`                   |                                                                           |\r\n| `plainDate`      | `type: string, format: date`      |                                                                           |\r\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n### Data Validation Decorators\n\nThe tables below show how various built-in decorators add validation constraints to model properties:\r\n\r\n**For numeric types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                      |\r\n| ------------------ | -------- | --------------------------- | ---------------------------- |\r\n| `@minValue(value)` | built-in | `minimum: value`            | `@minValue(0) age: int32;`   |\r\n| `@maxValue(value)` | built-in | `maximum: value`            | `@maxValue(120) age: int32;` |\r\n\r\n**For string types:**\r\n\r\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Example                                 |\r\n| ------------------- | -------- | --------------------------- | --------------------------------------- |\r\n| `@format(name)`     | built-in | `format: name`              | `@format(\"email\") email: string;`       |\r\n| `@minLength(value)` | built-in | `minLength: value`          | `@minLength(8) password: string;`       |\r\n| `@maxLength(value)` | built-in | `maxLength: value`          | `@maxLength(50) name: string;`          |\r\n| `@pattern(regex)`   | built-in | `pattern: regex`            | `@pattern(\"^[A-Z]{2}$\") state: string;` |\r\n| `@secret`           | built-in | `format: password`          | `@secret password: string;`             |\r\n\r\n**For array types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                         |\r\n| ------------------ | -------- | --------------------------- | ------------------------------- |\r\n| `@minItems(value)` | built-in | `minItems: value`           | `@minItems(1) tags: string[];`  |\r\n| `@maxItems(value)` | built-in | `maxItems: value`           | `@maxItems(10) tags: string[];` |\n\n### Using External References\n\nThe [`@useRef` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.useRef) configures a TypeSpec model with a reference to an external schema that will be used in place of references to that model's schema:\r\n\r\n```typespec\r\n// Whenever the OpenAPI emitter would try to reference the Sku model's schema, it will reference the below\r\n// external schema instead.\r\n@useRef(\"common.json#/components/schemas/Sku\")\r\nmodel Sku {\r\n  name: string;\r\n  tier: string;\r\n}\r\n```\n\n### Enums\n\nTypeSpec enums and unions convert to OpenAPI enum schemas. You can define enums in two ways:\r\n\r\n**TypeSpec enum declaration:**\r\n\r\n```typespec\r\nenum Color {\r\n  Red: \"red\",\r\n  Blue: \"blue\",\r\n  Green: \"green\",\r\n}\r\n```\r\n\r\n**Union of literal values:**\r\n\r\n```typespec\r\nmodel Settings {\r\n  // `status` can be any of the following strings.\r\n  status: \"Running\" | \"Stopped\" | \"Failed\";\r\n}\r\n```\r\n\r\nBoth approaches result in an OpenAPI schema with a type of `string` and an `enum` array containing the specified values.\n\n## Model Composition\n\nTypeSpec offers several ways to compose models.\n\n### Spread Operator\n\nThe spread operator copies properties from one model to another without creating a semantic relationship:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n}\r\n\r\nmodel UserProfile {\r\n  name: string;\r\n\r\n  // Copy all the properties of Address into this model as if they were declared here.\r\n  ...Address;\r\n\r\n  email: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, the result is a flat schema named `UserProfile` with the properties of `Address` declared inline.\n\n### Extends Keyword\n\nThe `extends` keyword creates an inheritance relationship:\r\n\r\n```typespec\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  breed: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, this creates a schema `Dog` that references the schema `Pet` using `allOf`.\r\n\r\n#### Discriminated Union with Extends\r\n\r\nYou can create discriminated type hierarchies using the `@discriminator` decorator:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  kind: \"dog\"; // Must be a literal string value\r\n  breed: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  kind: \"cat\"; // Must be a literal string value\r\n  whiskerCount: int32;\r\n}\r\n```\r\n\r\nThis creates a discriminator object in the OpenAPI schema with a mapping from discriminator values to schemas.\n\n### Is Keyword\n\nThe `is` keyword creates a new model with the same shape as another model:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n}\r\n\r\nmodel ShippingDetails is Address {\r\n  zipCode: string; // Additional property\r\n}\r\n```\r\n\r\nIn OpenAPI, `ShippingDetails` is an independent schema with all properties from `Address` plus `zipCode`.\n\n### Unions\n\nUnions represent values that could be one of several types:\r\n\r\n**Union type alias:**\r\n\r\n```typespec\r\nalias PetType = Dog | Cat | Hamster;\r\n```\r\n\r\n**Named union declaration:**\r\n\r\n```typespec\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\r\n\r\nBy default, unions emit as `anyOf` in OpenAPI. You can use the [`@oneOf` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.oneOf) on a named union declaration to emit it as `oneOf` instead:\r\n\r\n```typespec\r\n@oneOf\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\n\n## Encoding and Formats\n\nThe `@encode` decorator lets you control how TypeSpec types are serialized. The general pattern is:\r\n\r\n```typespec\r\n@encode(\"<encoding name>\", encodingTargetType) property: trueType;\r\n```\r\n\r\nWhere:\r\n\r\n- `\"<encoding name>\"`: The format or method of encoding (e.g., `\"base64\"`, `\"rfc3339\"`, `\"unixTimestamp\"`)\r\n- `encodingTargetType`: The type to encode to and decode from (e.g., `int32`, `string`)\r\n- `trueType`: The \"true\" semantic data type of the property (e.g., `duration`, `utcDateTime`)\r\n\r\nThe emitter follows these rules to determine the OpenAPI format:\r\n\r\n1. For date/time types:\r\n\r\n   - `@encode(\"rfc3339\", string) _: utcDateTime` → `type: string, format: date-time`\r\n   - `@encode(\"rfc7231\", string) _: utcDateTime` → `type: string, format: http-date`\r\n   - `@encode(\"unixTimestamp\", int32) _: utcDateTime` → `type: integer, format: unixtime`\r\n\r\n2. For other types, the format comes from either the encoding name or the `encodingTargetType`'s format.\r\n\r\nThis table summarizes common encodings:\r\n\r\n| TypeSpec with encoding                           | OpenAPI 3 result                  |\r\n| ------------------------------------------------ | --------------------------------- |\r\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    |\r\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  |\r\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` |\r\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` |\n\n## Security Definitions\n\nUse the [(HTTP) `@useAuth` decorator][http-useauth-decorator] to define authentication and security schemes for your API.\r\n\r\nFor example, to define an authentication/authorization scheme based on Microsoft Entra ID:\r\n\r\n```typespec\r\n@useAuth(EntraIDToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** Microsoft Entra ID OAuth2 Flow */\r\nmodel EntraIDToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\nAuthentication/authorization is a complex and highly configurable feature. See the [`@useAuth` decorator documentation for more information][http-useauth-decorator].\r\n\r\n[http-useauth-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.useAuth\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 10.281980752944946, "response_length": 667}
{"query": "How do I resolve the compilation errors in routes.tsp when generating the dotnet SDK?", "ground_truth": "To resolve compilation errors in routes.tsp when generating the dotnet SDK, you should use the @pollingOperation decorator to specify which operation can be used to check the status of the Long Running Operation (LRO). Additionally, ensure that your TypeSpec is correctly updated to reflect any changes in the operation signatures or response handling, particularly for operations with a 202 response code, which must specify `x-ms-long-running-operation: true`. For defining custom LRO patterns in TypeSpec, refer to the documentation and examples provided in the Azure/cadl-ranch repository on GitHub. If you encounter issues with LroExtension rules or need further guidance on updating your TypeSpec, consider reviewing examples of services that have handled a 202 response code or seeking assistance from the community or specific contributors mentioned.", "response": "Sorry, I can't answer this question, could you please provide more information?", "context": "- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-csharp#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-csharp/project\n- document_content: # emitters#servers#http-server-csharp#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Layout\n\nThe code layout inside the 'generated' folder is as follows:\r\n\r\n- **generated**\r\n\r\n  - **controllers**: A set of ASP.Net core MVC controllers representing the operations in the spec, one for each interface or namespace with operations\r\n  - **lib**: A set of library files used in implementing generated models and controllers\r\n  - **models**: A set of models, each serving one of two distinct purposes:\r\n    - Request/Response Models: Represent the data used in requests and responses.\r\n    - Exception Models: Represent errors. These models inherit from `HttpServiceException` and are designed to encapsulate error details, making them suitable for throwing and handling exceptions.\r\n  - **operations**: A set of interfaces called by the controllers, that should be implemented with the business logic for each operation.\r\n\r\n  You should recompile whenever you make changes in your TypeSpec and these files will be replaced inline to reflect the spec changes, without changing any of your hand-written implementation in the project.\n\n## Scaffolding\n\nIf you use the scaffolding cli (hscs-scaffold) or use the `--emit-mocks \"mocks-and-project-files\"` option on compilation, a fully-functional .Net 9 project will be created with mock implementations of your business\r\nlogic, ready to compile and run.\r\n\r\nThe following additional files will be generated. It is expected that you will edit or replace these\r\nfiles as you implement your service, so you should only regenerate them when needed.\r\nTo protect from inadvertently changing any edits you may have made to these files,\r\nthese files will be overwritten by the emitter unless you specify the `--overwrite` option.\r\n\r\n- **ServiceProject.csproj**: The project file\r\n- **Program.cs**: Entry point that sets up the app\r\n- **appSettings.Development.json**: Configuration settings for the development environment\r\n- **appSettings.json**: Configuration settings for the production environment\r\n- **Properties**\r\n  - **launchSettings.json**: Launch configurations for the service (including local ports)\r\n- **mocks**: Simple implementations of business logic interfaces that return simple responses.\r\n  this allows testing your service out before writing any implementation code.\r\n\r\n  - **MockRegistration.cs**: Called from the Program.cs startup, registers each of the business\r\n    logic implementations in the dependency injection container.\r\n  - **IInitializer.cs**: Interface used in the mocks to create responses.\r\n  - **Initializer.cs**: Implementation of the interface to create mock responses.\n\n### Generating a Project and Mock Implementations using `tsp compile`\n\nIf you downloaded the `tsp` standalone component and you don't have `node` and `npm` installed, you will not be able to use the `hscs-scaffold` command to create an ASP.Net project. Instead, you can use compiler options, for example, the following command will create a new project using the TypeSpec in the current directory, enabling SwaggerUI, and overwriting any existing mocks or project files:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --emit @typespec/openapi3 --option @typespec/http-server-csharp.emit-mocks=emit-mocks-and-project-files --option @typespec/http-server-csharp.use-swaggerui=true --option @typespec/http-server-csharp.overwrite=true\r\n```\r\n\r\nOnce you have customized the project, you can generate new mocks for any new APIs while leaving existing implementations unchanged using:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --option @typespec/http-server-csharp.emit-mocks=mocks-only\r\n```\n\n## SwaggerUI\n\nIf you include the `@typespec/openapi3` emitter in your typespec project, you can include a\r\nSwaggerUI endpoint in the generated service using the `--use-swaggerui` option. This endpoint\r\nprovides a visual representation of operations and provides a web GUI client connected to the service that you can use right away to try out service operations.\n\n## How Components Work Together\n\n### Controllers\n\nThe generated controllers automatically listen at the routes you specified in TypeSpec. Controllers perform validation of input requests, call your implementation of business logic interfaces to perform the operation, and return the appropriate Http response.\n\n### Business Logic Interfaces\n\nYou must implement business loginc interfaces to perform the work of each operation. There is one\r\nbusiness logic interface for each `interface` type in your spec, or for each namespace that contain operations. Business logic can assume that input types meet the constraints specified in TypeSpec and are responsible for returning the response type for the operation.\r\n\r\nYou can use the `--emit-mocks` option to emit mock implementations of your business logic, these mocks demonstrate a simple implementation that returns responses that match the response type in TypeSpec. They also show how to use `IHttpContextAccessor` to access additional details of the Http request and response.\n\n### Discovery using the ASP.Net Core Dependency Injection Container\n\nThe Controllers find your business logic implementation through the ASP.Net dependency injection container. At server start, you register each of your implementations with the dependency injection container and they will automatically be instantiated and used by the controllers.\r\n\r\nIf you use the `--emit-mocks` option, sample code registering mock implementations is emitted to `mocks/MockRegistration.cs`.\n\n### Models\n\nModel classes represent the data passed in Http requests and response and the data that passes from the front end controllers to your business logic.\r\n\r\nModels are partial, so you can add additional members for internal usage as needed by putting a partial class definition with additional members outside the `generated` folder in your project.\n\n### Next Steps\n\nAfter successful generation, you should:\r\n\r\n- Use the SwaggerUI endpoint to test out the running service\r\n- Implement the business logic interfaces for your operations\r\n- Update MockRegistration.cs, or register each of your interfaces as part of application startup\r\n- Update configuration to suit your needs\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#rest-api-publish#buildpipelines.md\n- document_title: Using Build Pipelines with TypeSpec\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/buildpipelines\n- document_content: # howtos#rest-api-publish#buildpipelines.md\n\n# Using Build Pipelines with TypeSpec\n\nThis doc will help you get started with using TypeSpec in your build pipelines in your own repository. [See here for more how to use in the azure-rest-api-specs repo](./checking-in-api-specs-guide.md)\n\n## Table of Contents\n\n1. [Introduction](#introduction)\r\n1. [Azure DevOps Pipelines](#azure-devops-pipelines)\n\n## Introduction\n\n### Dependencies\n\nIn order to build TypeSpec in your build pipeline, you will need to ensure that the following are available or are automatically installed by your project:\r\n\r\n1. NodeJS 22.x LTS (Recommended)\r\n2. TypeSpec compilation tools (via npm package)\n\n## Azure DevOps Pipelines\n\nDepending on your project, you may need to add NodeJS and install NPM packages for TypeSpec.\r\nThe following Azure Devops Pipeline tasks can be modified and added to your pipeline yaml file if you do not already utilize NodeJS in your project.\r\n\r\n```yaml title=\".azure-pipelines.yml\"\n\n# Install NodeJS\n\n- task: NodeTool@0\r\n  inputs:\r\n    versionSpec: \"22.x\"\r\n    checkLatest: false\n\n# Install dependencies\n\n- script: npm install\r\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\n\n# Build\n\n- script: npx tsp compile .\r\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\r\n```\r\n\r\nThis is sufficient if you are building via a csproj file which triggers the tsp compile and finds the tsp compiler itself.\r\n\r\nYou may also need to add additional steps to compile your typespec files separately. An example of a basic pipeline is provided below.\n\n### Example Pipeline Configuration\n\nNote: This example assumes that your TypeSpec folder is at the root of your repository.\r\n\r\n```yaml title=\".azure-pipelines.yml\"\r\ntrigger:\r\n  - main\r\npool:\r\n  vmImage: ubuntu-latest\r\nsteps:\r\n  - task: NodeTool@0\r\n    inputs:\r\n      versionSpec: \"18.17.0\"\r\n  - script: npm install\r\n  - script: npx tsp compile .\r\n  - task: PublishPipelineArtifact@1\r\n    displayName: Publish TypeSpec Output Folder\r\n    inputs:\r\n      targetPath: \"tsp-output\"\r\n      artifact: \"tsp-output\"\r\n      publishLocation: \"pipeline\"\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n", "latency": 4.97347617149353, "response_length": 79}
{"query": "Should we share the data model of FaceList between request and response, and set default RecognitionModel to Reco01?", "ground_truth": "Yes, separate model definitions for request and response should be used to accurately reflect the actual behavior. This is because setting a default value for a property indicates a service default, which does not necessarily impact its presence in a response. Additionally, to prevent roundtripping results when 'returnRecognitionModel' is false, it's advisable to have two different models and possibly model this as two separate logical operations with a shared route.", "response": "Yes, you can share the data model of `FaceList` between request and response in TypeSpec. This approach is consistent with TypeSpec's ability to define shared models and apply visibility modifiers to tailor the model for specific contexts, such as requests and responses. Additionally, setting a default `RecognitionModel` to `Reco01` can be achieved by defining a default value for the property in the model. Here's an example:\n\n```tsp\nmodel FaceList {\n  id: string;\n  name: string;\n  @default(\"Reco01\")\n  recognitionModel: string;\n}\n\n@route(\"/facelist\")\ninterface FaceListService {\n  @post createFaceList(@body faceList: FaceList): Created<FaceList>;\n  @get getFaceList(@path id: string): Ok<FaceList>;\n}\n```\n\nIn this example:\n- The `FaceList` model is shared between the request (`createFaceList`) and response (`getFaceList`).\n- The `recognitionModel` property is set to a default value of `Reco01` using the `@default` decorator.\n\nThis approach ensures consistency and reduces duplication in your API definitions.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-csharp#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-csharp/project\n- document_content: # emitters#servers#http-server-csharp#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Layout\n\nThe code layout inside the 'generated' folder is as follows:\r\n\r\n- **generated**\r\n\r\n  - **controllers**: A set of ASP.Net core MVC controllers representing the operations in the spec, one for each interface or namespace with operations\r\n  - **lib**: A set of library files used in implementing generated models and controllers\r\n  - **models**: A set of models, each serving one of two distinct purposes:\r\n    - Request/Response Models: Represent the data used in requests and responses.\r\n    - Exception Models: Represent errors. These models inherit from `HttpServiceException` and are designed to encapsulate error details, making them suitable for throwing and handling exceptions.\r\n  - **operations**: A set of interfaces called by the controllers, that should be implemented with the business logic for each operation.\r\n\r\n  You should recompile whenever you make changes in your TypeSpec and these files will be replaced inline to reflect the spec changes, without changing any of your hand-written implementation in the project.\n\n## Scaffolding\n\nIf you use the scaffolding cli (hscs-scaffold) or use the `--emit-mocks \"mocks-and-project-files\"` option on compilation, a fully-functional .Net 9 project will be created with mock implementations of your business\r\nlogic, ready to compile and run.\r\n\r\nThe following additional files will be generated. It is expected that you will edit or replace these\r\nfiles as you implement your service, so you should only regenerate them when needed.\r\nTo protect from inadvertently changing any edits you may have made to these files,\r\nthese files will be overwritten by the emitter unless you specify the `--overwrite` option.\r\n\r\n- **ServiceProject.csproj**: The project file\r\n- **Program.cs**: Entry point that sets up the app\r\n- **appSettings.Development.json**: Configuration settings for the development environment\r\n- **appSettings.json**: Configuration settings for the production environment\r\n- **Properties**\r\n  - **launchSettings.json**: Launch configurations for the service (including local ports)\r\n- **mocks**: Simple implementations of business logic interfaces that return simple responses.\r\n  this allows testing your service out before writing any implementation code.\r\n\r\n  - **MockRegistration.cs**: Called from the Program.cs startup, registers each of the business\r\n    logic implementations in the dependency injection container.\r\n  - **IInitializer.cs**: Interface used in the mocks to create responses.\r\n  - **Initializer.cs**: Implementation of the interface to create mock responses.\n\n### Generating a Project and Mock Implementations using `tsp compile`\n\nIf you downloaded the `tsp` standalone component and you don't have `node` and `npm` installed, you will not be able to use the `hscs-scaffold` command to create an ASP.Net project. Instead, you can use compiler options, for example, the following command will create a new project using the TypeSpec in the current directory, enabling SwaggerUI, and overwriting any existing mocks or project files:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --emit @typespec/openapi3 --option @typespec/http-server-csharp.emit-mocks=emit-mocks-and-project-files --option @typespec/http-server-csharp.use-swaggerui=true --option @typespec/http-server-csharp.overwrite=true\r\n```\r\n\r\nOnce you have customized the project, you can generate new mocks for any new APIs while leaving existing implementations unchanged using:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --option @typespec/http-server-csharp.emit-mocks=mocks-only\r\n```\n\n## SwaggerUI\n\nIf you include the `@typespec/openapi3` emitter in your typespec project, you can include a\r\nSwaggerUI endpoint in the generated service using the `--use-swaggerui` option. This endpoint\r\nprovides a visual representation of operations and provides a web GUI client connected to the service that you can use right away to try out service operations.\n\n## How Components Work Together\n\n### Controllers\n\nThe generated controllers automatically listen at the routes you specified in TypeSpec. Controllers perform validation of input requests, call your implementation of business logic interfaces to perform the operation, and return the appropriate Http response.\n\n### Business Logic Interfaces\n\nYou must implement business loginc interfaces to perform the work of each operation. There is one\r\nbusiness logic interface for each `interface` type in your spec, or for each namespace that contain operations. Business logic can assume that input types meet the constraints specified in TypeSpec and are responsible for returning the response type for the operation.\r\n\r\nYou can use the `--emit-mocks` option to emit mock implementations of your business logic, these mocks demonstrate a simple implementation that returns responses that match the response type in TypeSpec. They also show how to use `IHttpContextAccessor` to access additional details of the Http request and response.\n\n### Discovery using the ASP.Net Core Dependency Injection Container\n\nThe Controllers find your business logic implementation through the ASP.Net dependency injection container. At server start, you register each of your implementations with the dependency injection container and they will automatically be instantiated and used by the controllers.\r\n\r\nIf you use the `--emit-mocks` option, sample code registering mock implementations is emitted to `mocks/MockRegistration.cs`.\n\n### Models\n\nModel classes represent the data passed in Http requests and response and the data that passes from the front end controllers to your business logic.\r\n\r\nModels are partial, so you can add additional members for internal usage as needed by putting a partial class definition with additional members outside the `generated` folder in your project.\n\n### Next Steps\n\nAfter successful generation, you should:\r\n\r\n- Use the SwaggerUI endpoint to test out the running service\r\n- Implement the business logic interfaces for your operations\r\n- Update MockRegistration.cs, or register each of your interfaces as part of application startup\r\n- Update configuration to suit your needs\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#visibility.md\n- document_title: Visibility\n- document_link: https://typespec.io/docs/language-basics/visibility\n- document_content: # language-basics#visibility.md\n\n# Visibility\n\n**Visibility** is a language feature that allows you to share a model between multiple operations and define in which contexts\r\nproperties of the model are \"visible.\" Visibility is a very powerful feature that allows you to define different \"views\"\r\nof a model within different operations or contexts.\r\n\r\n**Note** ⚠️: Enum-based visibility as described in this document _replaces_ visibility strings that you may have used\r\nin the past. The system is backwards-compatible with visibility strings, but you should use enum-based visibility for\r\nnew specifications. String-based visibility (e.g. `@visibility(\"create\")`) may be deprecated and removed in future\r\nversions of TypeSpec.\n\n## Basic concepts\n\n- Visibility applies to _model properties_ only. It is used to determine when an emitter should include or exclude a\r\n  property in a certain context.\r\n- Visibility is defined using a _visibility class_. A visibility class is an `enum` that defines the visibility modifiers\r\n  (or flags) that can be applied to a property. Any `enum` can serve as a visibility class.\r\n- Visibility classes have a _default_ visibility, which is the set of visibility modifiers that are applied _by default_\r\n  to a property if the visibility is not explicitly set.\n\n## Lifecycle visibility\n\nschema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/ExampleUpdate\"\r\ncomponents:\r\n  schemas:\r\n    Example:\r\n      type: object\r\n      required:\r\n        - id\r\n        - name\r\n        - description\r\n      properties:\r\n        id:\r\n          type: string\r\n          readOnly: true\r\n        name:\r\n          type: string\r\n        description:\r\n          type: string\r\n    ExampleUpdate:\r\n      type: object\r\n      properties:\r\n        description:\r\n          type: string\r\n```\r\n\r\nNotice:\r\n\r\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\r\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\r\n  when updating the resource.\r\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\r\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\r\n  visibility of the properties in the model.\n\nTypeSpec provides a built-in visibility called \"resource lifecycle visibility.\" This visibility allows you to declare\r\nwhether properties are visible when passing a resource to or reading a resource from an API endpoint. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  /**\r\n   * The unique identifier of this resource.\r\n   *\r\n   * The ID is automatically generated by the service, so it cannot be set when the resource is created or updated,\r\n   * but the server will return it when the resource is read.\r\n   */\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  /**\r\n   * The name of this resource.\r\n   *\r\n   * The name can be set when the resource is created, but may not be changed.\r\n   */\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  /**\r\n   * The description of this resource.\r\n   *\r\n   * By default, properties are visible in all lifecycle phases, so this property\r\n   * is present in all lifecycle phases.\r\n   */\r\n  description: string;\r\n}\r\n```\r\n\r\nIn the above example, each property of the `Example` model has a lifecycle visibility that instructs emitters to include\r\nor exclude the property when creating, updating, or reading the `Example` resource.\r\n\r\nTypeSpec's HTTP library, OpenAPI emitter, and other standard functionality use the `Lifecycle` visibility to create\r\ndifferent views of the `Example` model based on which lifecycle phase is used in a particular operation.\r\n\r\nIn the following example, the type of the input and output of each operation is affected by the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\n\nby the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @get read(@path id: string): Ok<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the PATCH verb, it uses the `Update` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @patch update(@path id: string, @body example: Example): Ok<Example> | Error;\r\n}\r\n```\r\n\r\nThe above interface generates the following OpenAPIv3 schemas:\r\n\r\n```yml\r\npaths:\r\n  /example:\r\n    post:\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Example\"\r\n  /example/{id}:\r\n    get:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\n### Lifecycle modifiers\n\nThe following visibility modifiers are available in the `Lifecycle` visibility class:\r\n\r\n- `Create`: The property is visible when the resource is created. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `POST` operation.\r\n- `Read`: The property is visible when the resource is read. This visibility is checked, for example, when a property is\r\n  returned in an HTTP `GET` operation.\r\n- `Update`: The property is visible when the resource is updated. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `PATCH` or `PUT` operation.\r\n- `Delete`: The property is visible when a resource is deleted. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `DELETE` operation.\r\n- `Query`: The property is visible when a resource is passed as a parameter in a query. This visibility is checked, for\r\n  example, when a property is a parameter in an HTTP `GET` operation (**this should not be confused with an HTTP query\r\n  parameter defined using `@query`**).\n\n### Lifecycle visibility transforms\n\nYou can explicitly compute the shape of a model within a _specific_ lifecycle phase by using the four built-in\r\ntemplates for lifecycle transforms:\r\n\r\n- `Create<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Create` lifecycle\r\n  phase, recursively.\r\n- `Read<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Read` lifecycle phase,\r\n  recursively.\r\n- `Update<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Update` lifecycle\r\n  phase, with the types of the properties set to `CreateOrUpdate<T>`, recursively.\r\n- `CreateOrUpdate<T>`: creates a copy of `T` with only the properties that have _either_ the `Create` or `Update`\r\n  visibility modifiers enabled, recursively.\r\n- `Delete<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Delete` modifier enabled,\r\n  recursively.\r\n- `Query<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Query` modifier enabled,\r\n  recursively.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\nmodel ReadExample is Read<Example>;\r\n\r\nmodel CreateExample is Create<Example>;\r\n\r\nmodel UpdateExample is Update<Example>;\r\n\r\nmodel CreateOrUpdateExample is CreateOrUpdate<Example>;\r\n```\r\n\r\nWhen you use these templates, the resulting models have no `Lifecycle` visibility modifiers applied, so that any\r\nemitters or libraries that use lifecycle visibility will not alter them further.\n\n## Visibility modifiers\n\nEach property has its own set of _active visibility modifiers_ for each visibility class. The active modifiers can be\r\nchanged using the decorators described in this section.\r\n\r\n**Note**: Changing the visibility for one visibility class _does not_ affect other visibility classes. If you change the\r\nvisibility for the `Lifecycle` visibility class, it will not affect the modifiers that are active for _any_ other\r\nvisibility classes.\n\n### `@visibility`\n\nThe `@visibility` decorator _enables_ visibility modifiers. It takes a list of visibility modifiers as arguments and\r\nsets them on the property. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create, Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has the `Create` and `Read` visibility modifiers enabled.\r\n\r\nIf visibility has _already_ been set explicitly on a property, the `@visibility` decorator _ADDS_ its own visibility\r\nmodifiers to the currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create)\r\n@visibility(Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has both the `Create` and `Read` visibility modifiers enabled, but _not_ the `Update`\r\nvisibility modifier. The `@visibility` decorator starts from an _empty_ set of modifiers and adds the `Create` modifier,\r\nthen adds the `Read` modifier.\n\n### `@removeVisibility`\n\nThe `@removeVisibility` decorator _disables_ visibility modifiers. It takes a list of visibility modifiers as arguments\r\nand removes them from the property. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\nname: string;\r\n```\r\n\r\nThis use of `@removeVisibility` is equivalent to the above examples with the `@visibility` decorator, but it uses the `@removeVisibility`\r\ndecorator to remove the `Update` visibility modifier from the `name` property rather than adding the `Create` and `Read`\r\nvisibility modifiers. The `@removeVisibility` decorator starts from the _default_ set of visibility modifiers and removes\r\nthe `Update` modifier.\r\n\r\nIf the visibility has _already_ been set on a property, the `@removeVisibility` decorator _removes_ its visibility from\r\nthe currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\n@removeVisibility(Lifecycle.Create)\r\nid: string;\r\n```\r\n\r\nIn this example, the `id` property has the `Update` and `Create` visibility modifiers removed, but it retains the `Read`\r\nvisibility modifier.\n\n### `@invisible`\n\nThe `@invisible` decorator _disables all visibility modifiers_ on a property within a given visibility class. For example:\r\n\r\n```typespec\r\n@invisible(Lifecycle)\r\ninvisible: string;\r\n```\r\n\r\nIn this example, the `invisible` property has _no_ visibility modifiers enabled in the `Lifecycle` visibility class.\n\n## Visibility filters\n\nThe `@withVisibilityFilter` decorator allows you to transform a model by applying a visibility filter to it. A\r\nvisibility filter is an object that defines constraints on which visibility modifiers must be enabled/disabled for a\r\nproperty to be visible. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\n@withVisibilityFilter(#{ all: [Lifecycle.Create, Lifecycle.Read] })\r\nmodel CreateAndReadExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ any: [Lifecycle.Create, Lifecycle.Update] })\r\nmodel CreateOrUpdateExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ none: [Lifecycle.Update] })\r\nmodel NonUpdateExample {\r\n  ...Example;\r\n}\r\n```\r\n\r\nIn the above example, the `CreateAndReadExample` model is a copy of the `Example` model with only the the properties\r\nthat have _BOTH_ the `Create` and `Read` visibility modifiers enabled (i.e. only the `name` property). The\r\n`CreateOrUpdateExample` model is a copy of the `Example` model with only the properties that have _EITHER_ the `Create`\r\nor `Update` visibility modifiers enabled (i.e. the `id` and `name` properties). The `NonUpdateExample` model is a copy\r\nof the `Example` model with only the properties that _do not_ have the `Update` visibility modifier enabled (i.e. the\r\n`id` and `name` properties).\r\n\r\n**Note**: For `Lifecycle` visibility, you should ordinarily use the `Create`, `Read`, `Update`, and `CreateOrUpdate`\r\ntemplates instead of `@withVisibilityFilter` directly, but you can use `@withVisibilityFilter` to create custom \"views\"\r\nof a model that use visibility classes other than `Lifecycle` or custom filter logic.\n\n## Visibility classes\n\nAny TypeSpec `enum` can serve as a visibility class. The members of the `enum` define the visibility modifiers in the\r\nclass. For example, the following is the definition of the `Lifecycle` visibility class defined in the TypeSpec standard\r\nlibrary:\r\n\r\n```typespec\r\nenum Lifecycle {\r\n  Create,\r\n  Read,\r\n  Update,\r\n}\r\n```\r\n\r\nThis visibility class defines three visibility modifiers: `Create`, `Read`, and `Update`. By default, all properties\r\nhave _ALL_ three visibilities in the `Lifecycle` enum enabled.\n\n### Setting default visibility\n\nYou can set the default visibility for a visibility class by declaring it on the enum using the `@defaultVisibility`\r\ndecorator:\r\n\r\n```typespec\r\n@defaultVisibility(Example.A)\r\nenum Example {\r\n  A,\r\n  B,\r\n}\r\n```\r\n\r\nIn this example, any property that does not declare an `Example` visibility modifier will have the `A` visibility by\r\ndefault.\r\n\r\n**Note**: While you can define your own visibility classes, emitters _will not recognize them_ unless they have been\r\nprogrammed to do so. You can leverage custom visibility classes in your own emitters, but they will have no effect on\r\nthe standard emitters unless those emitters choose to adopt and recognize those visibility classes as meaningful. The\r\n`Lifecycle` visibility class is a standard visibility class that is recognized by several emitters. You can, however,\r\nuse your own visibility classes with the built in `@withVisibilityFilter` decorator to transform your models in whatever\r\nways you see fit.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#07-custom-response-models.md\n- document_title: Custom Response Models\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/07-custom-response-models\n- document_content: # getting-started#getting-started-rest#07-custom-response-models.md\n\n# Custom Response Models\n\n## Introduction\n\nIn this section, we'll focus on creating custom response models and demonstrate how to use them in your API operations. We'll also incorporate predefined response models from the TypeSpec HTTP library.\n\n## Introduction to Custom Response Models\n\nCustom response models allow you to define structured responses for your API operations. They help ensure consistency and clarity in your API responses. TypeSpec defines response models for common HTTP responses in the [HTTP library](https://typespec.io/docs/libraries/http/reference), which we can incorporate into our custom response models.\n\n### Common HTTP Status Codes and TypeSpec Response Models\n\nHere are some common HTTP status codes and their equivalent TypeSpec response models from the TypeSpec HTTP library:\r\n\r\n| **HTTP Status Code** | **Meaning**                                                                 | **TypeSpec Response Model** |\r\n| -------------------- | --------------------------------------------------------------------------- | --------------------------- |\r\n| 200 OK               | The request was successful, and the server returned the requested resource. | `OkResponse`                |\r\n| 201 Created          | The request was successful, and a new resource was created.                 | `CreatedResponse`           |\r\n| 204 No Content       | The request was successful, but there is no content to return.              | `NoContentResponse`         |\r\n| 400 Bad Request      | The server could not understand the request due to invalid syntax.          | `BadRequestResponse`        |\r\n| 401 Unauthorized     | The client must authenticate itself to get the requested response.          | `UnauthorizedResponse`      |\r\n| 403 Forbidden        | The client does not have access rights to the content.                      | `ForbiddenResponse`         |\r\n| 404 Not Found        | The server cannot find the requested resource.                              | `NotFoundResponse`          |\n\n### Benefits of Using Custom Response Models\n\n- **Reducing Duplication**: By defining common response structures once, you can reuse them across multiple operations.\r\n- **Improving Readability**: Custom response models make your API definitions clearer and easier to understand.\r\n- **Minimizing Errors**: Consistent response models help reduce the likelihood of errors in your API responses.\n\n## Creating Custom Response Models\n\nLet's start by defining and extending some custom response models. These models will incorporate existing response models from the TypeSpec HTTP library to ensure consistency.\n\n### Example: Defining and Extending Custom Response Models\n\n```tsp\r\nmodel PetListResponse {\r\n  ...OkResponse;\r\n  ...Body<Pet[]>;\r\n}\r\n\r\nmodel PetResponse {\r\n  ...OkResponse;\r\n  ...Body<Pet>;\r\n}\r\n\r\nmodel PetCreatedResponse {\r\n  ...CreatedResponse;\r\n  ...Body<Pet>;\r\n}\r\n\r\nmodel PetErrorResponse {\r\n  ...BadRequestResponse;\r\n  ...Body<ValidationError>;\r\n}\r\n\r\nmodel PetNotFoundResponse {\r\n  ...NotFoundResponse;\r\n  ...Body<NotFoundError>;\r\n}\r\n\r\nmodel PetUnauthorizedResponse {\r\n  ...UnauthorizedResponse;\r\n  ...Body<UnauthorizedError>;\r\n}\r\n\r\nmodel PetSuccessResponse {\r\n  ...OkResponse;\r\n  ...Body<string>;\r\n}\r\n\r\nmodel PetNoContentResponse {\r\n  ...NoContentResponse;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `PetListResponse` extends `OkResponse` and includes a body with an array of `Pet` objects.\r\n- `PetResponse` extends `OkResponse` and includes a body with a single `Pet` object.\r\n- `PetCreatedResponse` extends `CreatedResponse` and includes a body with a newly created `Pet` object.\r\n- `PetErrorResponse` extends `BadRequestResponse` and includes a body with a `ValidationError` object.\r\n- `PetNotFoundResponse` extends `NotFoundResponse` and includes a body with a `NotFoundError` object.\r\n- `PetUnauthorizedResponse` extends `UnauthorizedResponse` and includes a body with an `UnauthorizedError` object.\r\n- `PetSuccessResponse` extends `OkResponse` and includes a body with a success message.\r\n- `PetNoContentResponse` extends `NoContentResponse` for situations where the request succeeded but there is no content to return.\r\n\r\n**Note**: Base response models like `OkResponse`, `CreatedResponse`, `BadRequestResponse`, `NotFoundResponse`, and `UnauthorizedResponse` are imported from the TypeSpec [HTTP data types library](../../../libraries/http/reference/data-types/), which we're importing in our project as `@typespec/http`.\n\n## Using Custom Response Models in Operations\n\nNow that we have defined our custom response models, let's use them in our API operations.\n\n### Example: Applying Custom Response Models to Operations\n\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  // highlight-next-line\r\n  op listPets(...CommonParameters): PetListResponse;\r\n\r\n  @get\r\n  // highlight-start\r\n  op getPet(@path petId: int32, @header ifMatch?: string): PetResponse | PetNotFoundResponse;\r\n  // highlight-end\r\n  @useAuth(BearerAuth)\r\n  @post\r\n  // highlight-start\r\n  op createPet(@body pet: Pet):\r\n    | PetCreatedResponse\r\n    | PetAcceptedResponse\r\n    | PetErrorResponse\r\n    | PetUnauthorizedResponse;\r\n  // highlight-end\r\n\r\n  @useAuth(BearerAuth)\r\n  @put\r\n  // highlight-start\r\n  op updatePet(@path petId: int32, @body pet: Pet):\r\n    | PetResponse\r\n    | PetErrorResponse\r\n    | PetUnauthorizedResponse\r\n    | PetNotFoundResponse\r\n    | InternalServerErrorResponse;\r\n  // highlight-end\r\n\r\n  @useAuth(BearerAuth)\r\n  @delete\r\n  // highlight-start\r\n  op deletePet(@path petId: int32): PetNoContentResponse | PetUnauthorizedResponse;\r\n  // highlight-end\r\n\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @body toys: Toy[];\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @body updatedToy: Toy;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    };\r\n  }\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n// highlight-start\r\nmodel PetListResponse {\r\n  ...OkResponse;\r\n  ...Body<Pet[]>;\r\n}\r\n\r\nmodel PetResponse {\r\n  ...OkResponse;\r\n  ...Body<Pet>;\r\n}\r\n\r\nmodel PetCreatedResponse {\r\n  ...CreatedResponse;\r\n  ...Body<Pet>;\r\n}\r\n\r\nmodel PetAcceptedResponse {\r\n  ...AcceptedResponse;\r\n  ...Body<Pet>;\r\n}\r\n\r\nmodel PetErrorResponse {\r\n  ...BadRequestResponse;\r\n  ...Body<ValidationError>;\r\n}\r\n\r\nmodel PetNotFoundResponse {\r\n  ...NotFoundResponse;\r\n  ...Body<NotFoundError>;\r\n}\r\n\r\nmodel PetUnauthorizedResponse {\r\n  ...UnauthorizedResponse;\r\n  ...Body<UnauthorizedError>;\r\n}\r\n\r\nmodel PetSuccessResponse {\r\n  ...OkResponse;\r\n  ...Body<string>;\r\n}\r\n\r\nmodel PetNoContentResponse {\r\n  ...NoContentResponse;\r\n}\r\n// highlight-end\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  // highlight-next-line\r\n  op listPets(...CommonParameters): PetListResponse;\r\n\r\n  @get\r\n  // highlight-start\r\n  op getPet(@path petId: int32, @header ifMatch?: string): PetResponse | PetNotFoundResponse;\r\n  // highlight-end\r\n  @useAuth(BearerAuth)\r\n  @post\r\n  // highlight-start\r\n  op createPet(@body pet: Pet):\r\n    | PetCreatedResponse\r\n    | PetAcceptedResponse\r\n    | PetErrorResponse\r\n    | PetUnauthorizedResponse;\r\n  // highlight-end\n\nupdatedToy: Toy;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    };\r\n  }\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `listPets` operation uses the `PetListResponse` custom response model.\r\n- The `getPet` operation uses the `PetResponse` and `PetNotFoundResponse` custom response models.\r\n- The `createPet` operation uses the `PetCreatedResponse`, `PetAcceptedResponse`, `PetErrorResponse`, and `PetUnauthorizedResponse` custom response models.\r\n- The `updatePet` operation uses the `PetResponse`, `PetErrorResponse`, `PetUnauthorizedResponse`, `PetNotFoundResponse`, and `InternalServerErrorResponse` custom response models.\r\n- The `deletePet` operation uses the `PetNoContentResponse` and `PetUnauthorizedResponse` custom response models.\r\n\r\nNote that we could also define custom response models for the `Toys` operations, similar to the `Pets` operations. But for brevity, we're omitting them in this example.\n\n## Conclusion\n\nIn this section, we focused on creating custom response models in your REST API. By defining and extending custom response models, we can reduce duplication, improve readability, and minimize errors in our API responses. We also incorporated existing response models from the TypeSpec HTTP library to ensure consistency and clarity.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 14.244751930236816, "response_length": 1018}
{"query": "How do I pass the enum value as a string in Typespec?", "ground_truth": "To pass an enum value as a string in Typespec, you should use a union instead of an enum, as enums are not assignable to strings within the Typespec type system.", "response": "To pass an enum value as a string in TypeSpec, you can use the `valueof` constraint in templates or unions. If you need to define an extensible enum that can be passed as a string, you should use a union where one of the variants is `string`. For example:\n\n```typespec\nunion PetKind {\n  Cat: \"Cat\",\n  Dog: \"Dog\",\n  string,\n}\n\nalias Example = TakesValue<PetKind.Cat>;\n```\n\nThis approach allows you to pass enum values as strings while maintaining extensibility. Additionally, you can use the `valueof` constraint in templates to accept literal values or enum members directly:\n\n```typespec\nalias TakesValue<StringType extends string, StringValue extends valueof string> = {\n  @doc(StringValue)\n  property: StringType;\n};\n\nalias Example = TakesValue<\"Cat\", \"Dog\">;\n```", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#templates.md\n- document_title: Templates\n- document_link: https://typespec.io/docs/language-basics/templates\n- document_content: # language-basics#templates.md\n\n# Templates\n\nTemplates are a powerful tool that allow users to customize certain aspects of a type. Similar to generics in other programming languages, templates define template parameters that users can specify when referencing the type.\r\n\r\nTemplates can be applied to:\r\n\r\n- [aliases](./alias.md)\r\n- [models](./models.md)\r\n- [operations](./operations.md)\r\n- [interfaces](./interfaces.md)\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Default values\n\nYou can assign a default value to a template parameter using `= <value>`.\r\n\r\n```typespec\r\nmodel Page<Item = string> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n```\n\n## Parameter constraints\n\nYou can impose constraints on template parameters using the `extends` keyword. For details on how validation works, refer to the [type relations](./type-relations.md) documentation.\r\n\r\n```typespec\r\nalias Foo<Type extends string> = Type;\r\n```\r\n\r\nIf you try to instantiate Foo with an argument that does not meet the `string` constraint, you will encounter an error:\r\n\r\n```typespec\r\nalias Bar = Foo<123>;\r\n                ^ Type '123' is not assignable to type 'TypeSpec.string'\r\n```\r\n\r\nA template parameter constraint can also be a model expression:\r\n\r\n```typespec\r\n// Expect Type to be a model with property name: string\r\nalias Foo<Type extends {name: string}> = Type;\r\n```\r\n\r\nDefault values for template parameters must also adhere to the constraint:\r\n\r\n```typespec\r\nalias Foo<Type extends string = \"Abc\">  = Type;\r\n// Invalid\r\nalias Bar<Type extends string = 123>  = Type;\r\n                             ^ Type '123' is not assignable to type 'TypeSpec.string'\r\n```\r\n\r\nAlso, all optional arguments must be placed at the end of the template. A required argument cannot follow an optional argument:\r\n\r\n```typespec\r\n// Invalid\r\nalias Foo<T extends string = \"Abc\", U> = ...;\r\n                                    ^ Required template arguments must not follow optional template arguments\r\n```\n\n## Named template arguments\n\nTemplate arguments can also be specified by name. This allows you to specify them out of order and omit optional arguments. This can be particularly useful when dealing with templates that have many arguments with defaults:\r\n\r\n```typespec\r\nalias Test<T, U extends numeric = int32, V extends string = \"example\"> = {\r\n  t: T;\r\n  v: V;\r\n};\r\n\r\n// Specify the argument V by name to skip argument U, since U is optional and we\r\n// are okay with its default\r\nalias Example1 = Test<unknown, V = \"example1\">;\r\n\r\n// Even all three arguments can be specified out of order\r\nalias Example2 = Test<V = \"example2\", T = unknown, U = uint64>;\r\n```\r\n\r\nHowever, once a template argument is specified by name, all subsequent arguments must also be specified by name:\r\n\r\n```typespec\r\n// Invalid\r\nalias Example3 = Test<\r\n  V = \"example3\",\r\n  unknown,\r\n  ^^^^^^^ Positional template arguments cannot follow named arguments in the same argument list.\r\n>;\r\n```\r\n\r\nSince template arguments can be specified by name, the names of template parameters are part of the template's public API. **Renaming a template parameter may break existing specifications that use the template.**\r\n\r\n**Note**: Template arguments are evaluated in the order the parameters are defined in the template _definition_, not the order in which they are written in the template _instance_. While this is usually inconsequential, it may be important in some cases where evaluating a template argument may trigger decorators with side effects.\n\n## Templates with values\n\nTemplates can be declared to accept values using a `valueof` constraint. This is useful for providing default values and parameters for decorators that take values.\r\n\r\n```typespec\r\nalias TakesValue<StringType extends string, StringValue extends valueof string> = {\r\n  @doc(StringValue)\r\n  property: StringType;\r\n};\r\n\r\nalias M1 = TakesValue<\"a\", \"b\">;\r\n```\r\n\r\nWhen a passing a literal or an enum or union member reference directly as a template parameter that accepts either a type or a value, we pass the value. In particular, `StringTypeOrValue` is a value with the string literal type `\"a\"`.\r\n\r\n```typespec\r\nalias TakesTypeOrValue<StringTypeOrValue extends string | (valueof string)> = {\r\n  @customDecorator(StringOrValue)\r\n  property: string;\r\n};\r\n\r\nalias M1 = TakesValue<\"a\">;\r\n```\r\n\r\nThe [`typeof` operator](./values.md#the-typeof-operator) can be used to get the declared type of a value if needed.\n\n### Template parameter value types\n\nWhen a template is instantiated with a value, the type of the value and the result of the `typeof` operator is determined based on the argument rather than the template parameter constraint. This follows the same rules as [const declaration type inference](./values.md#const-declarations). In particular, inside the template `TakesValue`, the type of `StringValue` is the string literal type `\"b\"`. If we passed a `const` instead, the type of the value would be the const's type. In the following example, the type of `property` in `M1` is `\"a\" | \"b\"`.\r\n\r\n```typespec\r\nalias TakesValue<StringValue extends valueof string> = {\r\n  @doc(StringValue)\r\n  property: typeof StringValue;\r\n};\r\n\r\nconst str: \"a\" | \"b\" = \"a\";\r\nalias M1 = TakesValue<str>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the (ℹ) bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#enums.md\n- document_title: Enums\n- document_link: https://typespec.io/docs/language-basics/enums\n- document_content: # language-basics#enums.md\n\n# Enums\n\nEnums, short for enumerations, provide a way for developers to define a collection of named constants. They are useful for documenting the purpose of the code or for establishing a set of distinct scenarios. Enums can be either numeric or string-based. For other data types, consider using [unions](./unions.md).\n\n## The basics\n\nYou can declare enums using the `enum` keyword. The members of an enum are separated by commas `,` and can be either [`identifier`](./identifiers.md) TypeSpecs or `string literal`s.\r\n\r\n```typespec\r\nenum Direction {\r\n  North,\r\n  East,\r\n  South,\r\n  West,\r\n}\r\n```\r\n\r\nIn the above example, we haven't defined the representation of the constants. Depending on the context, enums might be handled differently.\n\n## Assigning values to enums\n\nYou can assign custom values to enum members using the `:` operator.\r\n\r\n```typespec\r\nenum Direction {\r\n  North: \"north\",\r\n  East: \"east\",\r\n  South: \"south\",\r\n  West: \"west\",\r\n}\r\n```\r\n\r\nThese values can also be integers.\r\n\r\n```typespec\r\nenum Foo {\r\n  One: 1,\r\n  Ten: 10,\r\n  Hundred: 100,\r\n  Thousand: 1000,\r\n}\r\n```\r\n\r\nOr even floating-point numbers.\r\n\r\n```typespec\r\nenum Hour {\r\n  Zero: 0,\r\n  Quarter: 0.25,\r\n  Half: 0.5,\r\n  ThreeQuarter: 0.75,\r\n}\r\n```\n\n## Combining enums\n\nYou can combine enums using the spread `...` pattern. This copies all the members from the source enum to the target enum, but it doesn't establish any reference between the source and target enums.\r\n\r\n```typespec\r\nenum DirectionExt {\r\n  ...Direction,\r\n  `North East`,\r\n  `North West`,\r\n  `South East`,\r\n  `South West`,\r\n}\r\n```\n\n## How to reference enum members\n\nYou can reference enum members using the `.` operator for identifiers.\r\n\r\n```typespec\r\nalias North = Direction.North;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Models with additional properties\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\n### Discriminator\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\n### Nullable\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#xml#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/xml/reference/decorators\n- document_content: # libraries#xml#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.Xml\n\n### `@attribute` {#@TypeSpec.Xml.attribute}\n\nSpecify that the target property should be encoded as an XML attribute instead of node.\r\n\r\n```typespec\r\n@TypeSpec.Xml.attribute\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n##### Default\r\n\r\n```tsp\r\nmodel Blob {\r\n  id: string;\r\n}\r\n```\r\n\r\n```xml\r\n<Blob>\r\n  <id>abcdef</id>\r\n</Blob>\r\n```\r\n\r\n##### With `@attribute`\r\n\r\n```tsp\r\nmodel Blob {\r\n  @attribute id: string;\r\n}\r\n```\r\n\r\n```xml\r\n<Blob id=\"abcdef\">\r\n</Blob>\r\n```\n\n### `@name` {#@TypeSpec.Xml.name}\n\nProvide the name of the XML element or attribute. This means the same thing as\r\n`@encodedName(\"application/xml\", value)`\r\n\r\n```typespec\r\n@TypeSpec.Xml.name(name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description                              |\r\n| ---- | ---------------- | ---------------------------------------- |\r\n| name | `valueof string` | The name of the XML element or attribute |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@name(\"XmlBook\")\r\nmodel Book {\r\n  @name(\"XmlId\") id: string;\r\n  @encodedName(\"application/xml\", \"XmlName\") name: string;\r\n  content: string;\r\n}\r\n```\r\n\r\n```xml\r\n<XmlBook>\r\n  <XmlId>string</XmlId>\r\n  <XmlName>string</XmlName>\r\n  <content>string</content>\r\n</XmlBook>\r\n```\n\n### `@ns` {#@TypeSpec.Xml.ns}\n\nSpecify the XML namespace for this element. It can be used in 2 different ways:\r\n\r\n1. `@ns(\"http://www.example.com/namespace\", \"ns1\")` - specify both namespace and prefix\r\n2. `@Xml.ns(Namespaces.ns1)` - pass a member of an enum decorated with `@nsDeclaration`\r\n\r\n```typespec\r\n@TypeSpec.Xml.ns(ns: string | EnumMember, prefix?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type                   | Description                                                                       |\r\n| ------ | ---------------------- | --------------------------------------------------------------------------------- |\r\n| ns     | `string \\| EnumMember` | The namespace URI or a member of an enum decorated with `@nsDeclaration`.         |\r\n| prefix | `valueof string`       | The namespace prefix. Required if the namespace parameter was passed as a string. |\r\n\r\n#### Examples\r\n\r\n##### With strings\r\n\r\n```tsp\r\n@ns(\"https://example.com/ns1\", \"ns1\")\r\nmodel Foo {\r\n  @ns(\"https://example.com/ns1\", \"ns1\")\r\n  bar: string;\r\n\r\n  @ns(\"https://example.com/ns2\", \"ns2\")\r\n  bar: string;\r\n}\r\n```\r\n\r\n##### With enum\r\n\r\n```tsp\r\n@Xml.nsDeclarations\r\nenum Namespaces {\r\n  ns1: \"https://example.com/ns1\",\r\n  ns2: \"https://example.com/ns2\",\r\n}\r\n\r\n@Xml.ns(Namespaces.ns1)\r\nmodel Foo {\r\n  @Xml.ns(Namespaces.ns1)\r\n  bar: string;\r\n\r\n  @Xml.ns(Namespaces.ns2)\r\n  bar: string;\r\n}\r\n```\n\n### `@nsDeclarations` {#@TypeSpec.Xml.nsDeclarations}\n\nMark an enum as declaring XML namespaces. See `@ns`\r\n\r\n```typespec\r\n@TypeSpec.Xml.nsDeclarations\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@unwrapped` {#@TypeSpec.Xml.unwrapped}\n\nSpecify that the target property shouldn't create a wrapper node. This can be used to flatten list nodes into the model node or to include raw text in the model node.\r\nIt cannot be used with `@attribute`.\r\n\r\n```typespec\r\n@TypeSpec.Xml.unwrapped\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n##### Array property default\r\n\r\n```tsp\r\nmodel Pet {\r\n  tags: Tag[];\r\n}\r\n```\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsTags>\r\n    <XmlTag>\r\n      <name>string</name>\r\n    </XmlTag>\r\n  </ItemsTags>\r\n</XmlPet>\r\n```\r\n\r\n##### Array property with `@unwrapped`\r\n\r\n```tsp\r\nmodel Pet {\r\n  @unwrapped tags: Tag[];\r\n}\r\n```\r\n\r\n```xml\r\n<XmlPet>\r\n  <XmlTag>\r\n    <name>string</name>\r\n  </XmlTag>\r\n</XmlPet>\r\n```\r\n\r\n##### String property default\r\n\r\n```tsp\r\nmodel BlobName {\r\n  content: string;\r\n}\r\n```\r\n\r\n```xml\r\n<BlobName>\r\n  <content>\r\n    abcdef\r\n  </content>\r\n</BlobName>\r\n```\r\n\r\n##### Array property with `@unwrapped`\r\n\r\n```tsp\r\nmodel BlobName {\r\n  @unwrapped content: string;\r\n}\r\n```\r\n\r\n```xml\r\n<BlobName>\r\n  abcdef\r\n</BlobName>\r\n```\n", "latency": 14.877046823501587, "response_length": 766}
{"query": "Which decorator should be used for properties that are required for creation but cannot be updated after that?", "ground_truth": "Use the `@createOnly` decorator for properties that are required for creation but cannot be updated afterwards.", "response": "The `@visibility` decorator should be used to mark properties that are required for creation but cannot be updated afterward. Specifically, you can use the `Lifecycle.Create` visibility modifier to indicate that the property is visible during the creation phase but not during the update phase. For example:\n\n```typespec\nmodel Example {\n  @visibility(Lifecycle.Create)\n  name: string;\n}\n```\n\nIn this example, the `name` property is required during the creation phase but cannot be updated later. This ensures that the property is included in the schema for creation operations but excluded from update operations.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#visibility.md\n- document_title: Visibility\n- document_link: https://typespec.io/docs/language-basics/visibility\n- document_content: # language-basics#visibility.md\n\n# Visibility\n\n**Visibility** is a language feature that allows you to share a model between multiple operations and define in which contexts\r\nproperties of the model are \"visible.\" Visibility is a very powerful feature that allows you to define different \"views\"\r\nof a model within different operations or contexts.\r\n\r\n**Note** ⚠️: Enum-based visibility as described in this document _replaces_ visibility strings that you may have used\r\nin the past. The system is backwards-compatible with visibility strings, but you should use enum-based visibility for\r\nnew specifications. String-based visibility (e.g. `@visibility(\"create\")`) may be deprecated and removed in future\r\nversions of TypeSpec.\n\n## Basic concepts\n\n- Visibility applies to _model properties_ only. It is used to determine when an emitter should include or exclude a\r\n  property in a certain context.\r\n- Visibility is defined using a _visibility class_. A visibility class is an `enum` that defines the visibility modifiers\r\n  (or flags) that can be applied to a property. Any `enum` can serve as a visibility class.\r\n- Visibility classes have a _default_ visibility, which is the set of visibility modifiers that are applied _by default_\r\n  to a property if the visibility is not explicitly set.\n\n## Lifecycle visibility\n\nschema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/ExampleUpdate\"\r\ncomponents:\r\n  schemas:\r\n    Example:\r\n      type: object\r\n      required:\r\n        - id\r\n        - name\r\n        - description\r\n      properties:\r\n        id:\r\n          type: string\r\n          readOnly: true\r\n        name:\r\n          type: string\r\n        description:\r\n          type: string\r\n    ExampleUpdate:\r\n      type: object\r\n      properties:\r\n        description:\r\n          type: string\r\n```\r\n\r\nNotice:\r\n\r\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\r\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\r\n  when updating the resource.\r\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\r\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\r\n  visibility of the properties in the model.\n\nTypeSpec provides a built-in visibility called \"resource lifecycle visibility.\" This visibility allows you to declare\r\nwhether properties are visible when passing a resource to or reading a resource from an API endpoint. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  /**\r\n   * The unique identifier of this resource.\r\n   *\r\n   * The ID is automatically generated by the service, so it cannot be set when the resource is created or updated,\r\n   * but the server will return it when the resource is read.\r\n   */\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  /**\r\n   * The name of this resource.\r\n   *\r\n   * The name can be set when the resource is created, but may not be changed.\r\n   */\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  /**\r\n   * The description of this resource.\r\n   *\r\n   * By default, properties are visible in all lifecycle phases, so this property\r\n   * is present in all lifecycle phases.\r\n   */\r\n  description: string;\r\n}\r\n```\r\n\r\nIn the above example, each property of the `Example` model has a lifecycle visibility that instructs emitters to include\r\nor exclude the property when creating, updating, or reading the `Example` resource.\r\n\r\nTypeSpec's HTTP library, OpenAPI emitter, and other standard functionality use the `Lifecycle` visibility to create\r\ndifferent views of the `Example` model based on which lifecycle phase is used in a particular operation.\r\n\r\nIn the following example, the type of the input and output of each operation is affected by the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\n\nby the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @get read(@path id: string): Ok<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the PATCH verb, it uses the `Update` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @patch update(@path id: string, @body example: Example): Ok<Example> | Error;\r\n}\r\n```\r\n\r\nThe above interface generates the following OpenAPIv3 schemas:\r\n\r\n```yml\r\npaths:\r\n  /example:\r\n    post:\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Example\"\r\n  /example/{id}:\r\n    get:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\n### Lifecycle modifiers\n\nThe following visibility modifiers are available in the `Lifecycle` visibility class:\r\n\r\n- `Create`: The property is visible when the resource is created. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `POST` operation.\r\n- `Read`: The property is visible when the resource is read. This visibility is checked, for example, when a property is\r\n  returned in an HTTP `GET` operation.\r\n- `Update`: The property is visible when the resource is updated. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `PATCH` or `PUT` operation.\r\n- `Delete`: The property is visible when a resource is deleted. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `DELETE` operation.\r\n- `Query`: The property is visible when a resource is passed as a parameter in a query. This visibility is checked, for\r\n  example, when a property is a parameter in an HTTP `GET` operation (**this should not be confused with an HTTP query\r\n  parameter defined using `@query`**).\n\n### Lifecycle visibility transforms\n\nYou can explicitly compute the shape of a model within a _specific_ lifecycle phase by using the four built-in\r\ntemplates for lifecycle transforms:\r\n\r\n- `Create<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Create` lifecycle\r\n  phase, recursively.\r\n- `Read<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Read` lifecycle phase,\r\n  recursively.\r\n- `Update<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Update` lifecycle\r\n  phase, with the types of the properties set to `CreateOrUpdate<T>`, recursively.\r\n- `CreateOrUpdate<T>`: creates a copy of `T` with only the properties that have _either_ the `Create` or `Update`\r\n  visibility modifiers enabled, recursively.\r\n- `Delete<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Delete` modifier enabled,\r\n  recursively.\r\n- `Query<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Query` modifier enabled,\r\n  recursively.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\nmodel ReadExample is Read<Example>;\r\n\r\nmodel CreateExample is Create<Example>;\r\n\r\nmodel UpdateExample is Update<Example>;\r\n\r\nmodel CreateOrUpdateExample is CreateOrUpdate<Example>;\r\n```\r\n\r\nWhen you use these templates, the resulting models have no `Lifecycle` visibility modifiers applied, so that any\r\nemitters or libraries that use lifecycle visibility will not alter them further.\n\n## Visibility modifiers\n\nEach property has its own set of _active visibility modifiers_ for each visibility class. The active modifiers can be\r\nchanged using the decorators described in this section.\r\n\r\n**Note**: Changing the visibility for one visibility class _does not_ affect other visibility classes. If you change the\r\nvisibility for the `Lifecycle` visibility class, it will not affect the modifiers that are active for _any_ other\r\nvisibility classes.\n\n### `@visibility`\n\nThe `@visibility` decorator _enables_ visibility modifiers. It takes a list of visibility modifiers as arguments and\r\nsets them on the property. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create, Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has the `Create` and `Read` visibility modifiers enabled.\r\n\r\nIf visibility has _already_ been set explicitly on a property, the `@visibility` decorator _ADDS_ its own visibility\r\nmodifiers to the currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create)\r\n@visibility(Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has both the `Create` and `Read` visibility modifiers enabled, but _not_ the `Update`\r\nvisibility modifier. The `@visibility` decorator starts from an _empty_ set of modifiers and adds the `Create` modifier,\r\nthen adds the `Read` modifier.\n\n### `@removeVisibility`\n\nThe `@removeVisibility` decorator _disables_ visibility modifiers. It takes a list of visibility modifiers as arguments\r\nand removes them from the property. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\nname: string;\r\n```\r\n\r\nThis use of `@removeVisibility` is equivalent to the above examples with the `@visibility` decorator, but it uses the `@removeVisibility`\r\ndecorator to remove the `Update` visibility modifier from the `name` property rather than adding the `Create` and `Read`\r\nvisibility modifiers. The `@removeVisibility` decorator starts from the _default_ set of visibility modifiers and removes\r\nthe `Update` modifier.\r\n\r\nIf the visibility has _already_ been set on a property, the `@removeVisibility` decorator _removes_ its visibility from\r\nthe currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\n@removeVisibility(Lifecycle.Create)\r\nid: string;\r\n```\r\n\r\nIn this example, the `id` property has the `Update` and `Create` visibility modifiers removed, but it retains the `Read`\r\nvisibility modifier.\n\n### `@invisible`\n\nThe `@invisible` decorator _disables all visibility modifiers_ on a property within a given visibility class. For example:\r\n\r\n```typespec\r\n@invisible(Lifecycle)\r\ninvisible: string;\r\n```\r\n\r\nIn this example, the `invisible` property has _no_ visibility modifiers enabled in the `Lifecycle` visibility class.\n\n## Visibility filters\n\nThe `@withVisibilityFilter` decorator allows you to transform a model by applying a visibility filter to it. A\r\nvisibility filter is an object that defines constraints on which visibility modifiers must be enabled/disabled for a\r\nproperty to be visible. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\n@withVisibilityFilter(#{ all: [Lifecycle.Create, Lifecycle.Read] })\r\nmodel CreateAndReadExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ any: [Lifecycle.Create, Lifecycle.Update] })\r\nmodel CreateOrUpdateExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ none: [Lifecycle.Update] })\r\nmodel NonUpdateExample {\r\n  ...Example;\r\n}\r\n```\r\n\r\nIn the above example, the `CreateAndReadExample` model is a copy of the `Example` model with only the the properties\r\nthat have _BOTH_ the `Create` and `Read` visibility modifiers enabled (i.e. only the `name` property). The\r\n`CreateOrUpdateExample` model is a copy of the `Example` model with only the properties that have _EITHER_ the `Create`\r\nor `Update` visibility modifiers enabled (i.e. the `id` and `name` properties). The `NonUpdateExample` model is a copy\r\nof the `Example` model with only the properties that _do not_ have the `Update` visibility modifier enabled (i.e. the\r\n`id` and `name` properties).\r\n\r\n**Note**: For `Lifecycle` visibility, you should ordinarily use the `Create`, `Read`, `Update`, and `CreateOrUpdate`\r\ntemplates instead of `@withVisibilityFilter` directly, but you can use `@withVisibilityFilter` to create custom \"views\"\r\nof a model that use visibility classes other than `Lifecycle` or custom filter logic.\n\n## Visibility classes\n\nAny TypeSpec `enum` can serve as a visibility class. The members of the `enum` define the visibility modifiers in the\r\nclass. For example, the following is the definition of the `Lifecycle` visibility class defined in the TypeSpec standard\r\nlibrary:\r\n\r\n```typespec\r\nenum Lifecycle {\r\n  Create,\r\n  Read,\r\n  Update,\r\n}\r\n```\r\n\r\nThis visibility class defines three visibility modifiers: `Create`, `Read`, and `Update`. By default, all properties\r\nhave _ALL_ three visibilities in the `Lifecycle` enum enabled.\n\n### Setting default visibility\n\nYou can set the default visibility for a visibility class by declaring it on the enum using the `@defaultVisibility`\r\ndecorator:\r\n\r\n```typespec\r\n@defaultVisibility(Example.A)\r\nenum Example {\r\n  A,\r\n  B,\r\n}\r\n```\r\n\r\nIn this example, any property that does not declare an `Example` visibility modifier will have the `A` visibility by\r\ndefault.\r\n\r\n**Note**: While you can define your own visibility classes, emitters _will not recognize them_ unless they have been\r\nprogrammed to do so. You can leverage custom visibility classes in your own emitters, but they will have no effect on\r\nthe standard emitters unless those emitters choose to adopt and recognize those visibility classes as meaningful. The\r\n`Lifecycle` visibility class is a standard visibility class that is recognized by several emitters. You can, however,\r\nuse your own visibility classes with the built in `@withVisibilityFilter` decorator to transform your models in whatever\r\nways you see fit.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#built-in-data-types.md\n- document_title: Built-in Data types\n- document_link: https://typespec.io/docs/standard-library/built-in-data-types\n- document_content: # standard-library#built-in-data-types.md\n\n# Built-in Data types\n\n## TypeSpec\n\n### `Array` {#Array}\n\n```typespec\r\nmodel Array<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the array elements |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Create` {#Create}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" resource lifecycle phase.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Create<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has only the `name` field.\r\nmodel CreateDog is Create<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `CreateOrUpdate` {#CreateOrUpdate}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" or \"Update\" resource lifecycle phases.\r\n\r\nThe \"CreateOrUpdate\" lifecycle phase is used by default for properties passed as parameters to operations\r\nthat can create _or_ update data, like HTTP PUT operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` or `Lifecycle.Update` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel CreateOrUpdate<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create)\r\n  immutableSecret: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `immutableSecret`, `secretName`, and `name` fields, but not the `id` field.\r\nmodel CreateOrUpdateDog is CreateOrUpdate<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DefaultKeyVisibility` {#DefaultKeyVisibility}\n\nApplies a visibility setting to a collection of properties.\r\n```typespec\r\nmodel DefaultKeyVisibility<Source, Visibility>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Visibility | The visibility to apply to all properties. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Delete` {#Delete}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Delete\" resource lifecycle phase.\r\n\r\nThe \"Delete\" lifecycle phase is used for properties passed as parameters to operations\r\nthat delete data, like HTTP DELETE operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Delete` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Delete<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // Set when the Dog is removed from our data store. This happens when the\r\n  // Dog is re-homed to a new owner.\r\n  @visibility(Lifecycle.Delete)\r\n  nextOwner: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `nextOwner` and `name` fields, but not the `id` field.\r\nmodel DeleteDog is Delete<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DiscriminatedOptions` {#DiscriminatedOptions}\n\nOptions for `@discriminated` decorator.\r\n```typespec\r\nmodel DiscriminatedOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| envelope? | `\"object\" \\| \"none\"` | How is the discriminated union serialized. |\r\n| discriminatorPropertyName? | [`string`](#string) | Name of the discriminator property |\r\n| envelopePropertyName? | [`string`](#string) | Name of the property envelopping the data |\n\n### `ExampleOptions` {#ExampleOptions}\n\nOptions for example decorators\r\n```typespec\r\nmodel ExampleOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | The title of the example |\r\n| description? | [`string`](#string) | Description of the example |\n\n### `OmitDefaults` {#OmitDefaults}\n\nRepresents a collection of properties with default values omitted.\r\n```typespec\r\nmodel OmitDefaults<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread property defaults are all omitted. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OmitProperties` {#OmitProperties}\n\nRepresents a collection of omitted properties.\r\n```typespec\r\nmodel OmitProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to omit. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OperationExample` {#OperationExample}\n\nOperation example configuration.\r\n```typespec\r\nmodel OperationExample\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| parameters? | `unknown` | Example request body. |\r\n| returnType? | `unknown` | Example response body. |\n\n### `OptionalProperties` {#OptionalProperties}\n\nRepresents a collection of optional properties.\r\n```typespec\r\nmodel OptionalProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all optional. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `PickProperties` {#PickProperties}\n\nRepresents a collection of properties with only the specified keys included.\r\n```typespec\r\nmodel PickProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to include. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Query` {#Query}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Query\" resource lifecycle phase.\r\n\r\nThe \"Query\" lifecycle phase is used for properties passed as parameters to operations\r\nthat read data, like HTTP GET or HEAD operations. This should not be confused for\r\nthe `@query` decorator, which specifies that the property is transmitted in the\r\nquery string of an HTTP request.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Query` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Query<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // When getting information for a Dog, you can set this field to true to include\r\n  // some extra information about the Dog's pedigree that is normally not returned.\r\n  // Alternatively, you could just use a separate option parameter to get this\r\n  // information.\r\n  @visibility(Lifecycle.Query)\r\n  includePedigree?: boolean;\r\n\r\n  name: string;\r\n\r\n  // Only included if `includePedigree` is set to true in the request.\r\n  @visibility(Lifecycle.Read)\r\n  pedigree?: string;\r\n}\r\n\r\n// This model will have the `includePedigree` and `name` fields, but not `id` or `pedigree`.\r\nmodel QueryDog is Query<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Read` {#Read}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Read\" resource lifecycle phase.\r\n\r\nThe \"Read\" lifecycle phase is used for properties returned by operations that read data, like\r\nHTTP GET operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Read` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Read<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has the `id` and `name` fields, but not `secretName`.\r\nmodel ReadDog is Read<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Record` {#Record}\n\n```typespec\r\nmodel Record<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the properties |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `ServiceOptions` {#ServiceOptions}\n\nService options.\r\n```typespec\r\nmodel ServiceOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | Title of the service. |\r\n| version? | [`string`](#string) | Version of the service. |\n\n### `Update` {#Update}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Update\" resource lifecycle phase.\r\n\r\nThe \"Update\" lifecycle phase is used for properties passed as parameters to operations\r\nthat update data, like HTTP PATCH operations.\r\n\r\nThis transformation will include only the properties that have the `Lifecycle.Update`\r\nvisibility modifier, and the types of all properties will be replaced with the\r\nequivalent `CreateOrUpdate` transformation.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Update<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `secretName` and `name` fields, but not the `id` field.\r\nmodel UpdateDog is Update<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `UpdateableProperties` {#UpdateableProperties}\n\nRepresents a collection of updateable properties.\r\n```typespec\r\nmodel UpdateableProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all updateable. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `VisibilityFilter` {#VisibilityFilter}\n\nA visibility filter, used to specify which properties should be included when\r\nusing the `withVisibilityFilter` decorator.\r\n\r\nThe filter matches any property with ALL of the following:\r\n- If the `any` key is present, the property must have at least one of the specified visibilities.\r\n- If the `all` key is present, the property must have all of the specified visibilities.\r\n- If the `none` key is present, the property must have none of the specified visibilities.\r\n```typespec\r\nmodel VisibilityFilter\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| any? | `EnumMember[]` |  |\r\n| all? | `EnumMember[]` |  |\r\n| none? | `EnumMember[]` |  |\n\n### `ArrayEncoding` {#ArrayEncoding}\n\nEncoding for serializing arrays\r\n```typespec\r\nenum ArrayEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| pipeDelimited |  | Each values of the array is separated by a \\| |\r\n| spaceDelimited |  | Each values of the array is separated by a <space> |\n\n### `BytesKnownEncoding` {#BytesKnownEncoding}\n\nKnown encoding to use on bytes\r\n```typespec\r\nenum BytesKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| base64 | `\"base64\"` | Encode to Base64 |\r\n| base64url | `\"base64url\"` | Encode to Base64 Url |\n\n### `DateTimeKnownEncoding` {#DateTimeKnownEncoding}\n\nKnown encoding to use on utcDateTime or offsetDateTime\r\n```typespec\r\nenum DateTimeKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| rfc3339 | `\"rfc3339\"` | RFC 3339 standard. https://www.ietf.org/rfc/rfc3339.txt<br />Encode to string. |\r\n| rfc7231 | `\"rfc7231\"` | RFC 7231 standard. https://www.ietf.org/rfc/rfc7231.txt<br />Encode to string. |\r\n| unixTimestamp | `\"unixTimestamp\"` | Encode a datetime to a unix timestamp.<br />Unix timestamps are represented as an integer number of seconds since the Unix epoch and usually encoded as an int32. |\n\n### `DurationKnownEncoding` {#DurationKnownEncoding}\n\nKnown encoding to use on duration\r\n```typespec\r\nenum DurationKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| ISO8601 | `\"ISO8601\"` | ISO8601 duration |\r\n| seconds | `\"seconds\"` | Encode to integer or float |\n\n### `Lifecycle` {#Lifecycle}\n\nA visibility class for resource lifecycle phases.\r\n\r\nThese visibilities control whether a property is visible during the various phases of a resource's lifecycle.\r\n```typespec\r\nenum Lifecycle\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| Create |  | The property is visible when a resource is being created. |\r\n| Read |  | The property is visible when a resource is being read. |\r\n| Update |  | The property is visible when a resource is being updated. |\r\n| Delete |  | The property is visible when a resource is being deleted. |\r\n| Query |  | The property is visible when a resource is being queried.<br /><br />In HTTP APIs, this visibility applies to parameters of GET or HEAD operations. |\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n @visibility(Lifecycle.Read)\r\n id: int32;\r\n\r\n @visibility(Lifecycle.Create, Lifecycle.Update)\r\n secretName: string;\r\n\r\n name: string;\r\n}\r\n```\r\n\r\nIn this example, the `id` property is only visible during the read phase, and the `secretName` property is only visible\r\nduring the create and update phases. This means that the server will return the `id` property when returning a `Dog`,\r\nbut the client will not be able to set or update it. In contrast, the `secretName` property can be set when creating\r\nor updating a `Dog`, but the server will never return it. The `name` property has no visibility modifiers and is\r\ntherefore visible in all phases.\n\n### `boolean` {#boolean}\n\nBoolean with `true` and `false` values.\r\n```typespec\r\nscalar boolean\r\n```\n\n### `bytes` {#bytes}\n\nRepresent a byte array\r\n```typespec\r\nscalar bytes\r\n```\n\n### `decimal` {#decimal}\n\nA decimal number with any length and precision. This represent any `decimal` value possible.\r\nIt is commonly represented as `BigDecimal` in some languages.\r\n```typespec\r\nscalar decimal\r\n```\n\n### `decimal128` {#decimal128}\n\nA 128-bit decimal number.\r\n```typespec\r\nscalar decimal128\r\n```\n\n### `duration` {#duration}\n\nA duration/time period. e.g 5s, 10h\r\n```typespec\r\nscalar duration\r\n```\n\n### `float` {#float}\n\nA number with decimal value\r\n```typespec\r\nscalar float\r\n```\n\n### `float32` {#float32}\n\nA 32 bit floating point number. (`±1.5 x 10^−45` to `±3.4 x 10^38`)\r\n```typespec\r\nscalar float32\r\n```\n\n### `float64` {#float64}\n\nA 64 bit floating point number. (`±5.0 × 10^−324` to `±1.7 × 10^308`)\r\n```typespec\r\nscalar float64\r\n```\n\n### `int16` {#int16}\n\nA 16-bit integer. (`-32,768` to `32,767`)\r\n```typespec\r\nscalar int16\r\n```\n\n### `int32` {#int32}\n\nA 32-bit integer. (`-2,147,483,648` to `2,147,483,647`)\r\n```typespec\r\nscalar int32\r\n```\n\n### `int64` {#int64}\n\nA 64-bit integer. (`-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`)\r\n```typespec\r\nscalar int64\r\n```\n\n### `int8` {#int8}\n\nA 8-bit integer. (`-128` to `127`)\r\n```typespec\r\nscalar int8\r\n```\n\n### `integer` {#integer}\n\nA whole number. This represent any `integer` value possible.\r\nIt is commonly represented as `BigInteger` in some languages.\r\n```typespec\r\nscalar integer\r\n```\n\n### `numeric` {#numeric}\n\nA numeric type\r\n```typespec\r\nscalar numeric\r\n```\n\n### `offsetDateTime` {#offsetDateTime}\n\nA date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"\r\n```typespec\r\nscalar offsetDateTime\r\n```\n\n### `plainDate` {#plainDate}\n\nA date on a calendar without a time zone, e.g. \"April 10th\"\r\n```typespec\r\nscalar plainDate\r\n```\n\n### `plainTime` {#plainTime}\n\nA time on a clock without a time zone, e.g. \"3:00 am\"\r\n```typespec\r\nscalar plainTime\r\n```\n\n### `safeint` {#safeint}\n\nAn integer that can be serialized to JSON (`−9007199254740991 (−(2^53 − 1))` to `9007199254740991 (2^53 − 1)` )\r\n```typespec\r\nscalar safeint\r\n```\n\n### `string` {#string}\n\nA sequence of textual characters.\r\n```typespec\r\nscalar string\r\n```\n\n### `uint16` {#uint16}\n\nA 16-bit unsigned integer (`0` to `65,535`)\r\n```typespec\r\nscalar uint16\r\n```\n\n### `uint32` {#uint32}\n\nA 32-bit unsigned integer (`0` to `4,294,967,295`)\r\n```typespec\r\nscalar uint32\r\n```\n\n### `uint64` {#uint64}\n\nA 64-bit unsigned integer (`0` to `18,446,744,073,709,551,615`)\r\n```typespec\r\nscalar uint64\r\n```\n\n### `uint8` {#uint8}\n\nA 8-bit unsigned integer (`0` to `255`)\r\n```typespec\r\nscalar uint8\r\n```\n\n### `unixTimestamp32` {#unixTimestamp32}\n\nRepresent a 32-bit unix timestamp datetime with 1s of granularity.\r\nIt measures time by the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970.\r\n```typespec\r\nscalar unixTimestamp32\r\n```\n\n### `url` {#url}\n\nRepresent a URL string as described by https://url.spec.whatwg.org/\r\n```typespec\r\nscalar url\r\n```\n\n### `utcDateTime` {#utcDateTime}\n\nAn instant in coordinated universal time (UTC)\"\r\n```typespec\r\nscalar utcDateTime\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmResourcePatchSync<Resource, ResourceProperties>;`  |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                         |\r\n| -------------------- | ----------- | -------- | --------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                             |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`   |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmResourcePatchSync<Resource, ResourceProperties>;` |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                    |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`            |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason fro choosing another PATCH operation.\r\n\r\n| Operation Description             | TypeSpec                                                            |\r\n| --------------------------------- | ------------------------------------------------------------------- |\r\n| Sync Updateable Properties PATCH  | `update is ArmResourcePatchSync<ResourceType, ResourceProperties>`  |\r\n| Async Updateable Properties PATCH | `update is ArmResourcePatchAsync<ResourceType, ResourceProperties>` |\r\n| Sync TagsOnly PATCH               | `update is ArmTagsPatchSync<ResourceType>`                          |\r\n| Async TagsOnly PATCH              | `update is ArmTagsPatchAsync<ResourceType>`                         |\r\n| Sync Custom PATCH                 | `update is ArmCustomPatchSync<ResourceType, PatchRequest>`          |\r\n| Async Custom PATCH                | `update is ArmCustomPatchAsync<ResourceType, PatchRequest>`         |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n", "latency": 8.566693305969238, "response_length": 613}
